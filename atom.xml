<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ray Taylor Lin&#39;s world</title>
  <subtitle>林寿山的技术博客 Ray Taylor Lin&#39;s world</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://raytaylorlin.com/"/>
  <updated>2016-06-17T06:16:11.682Z</updated>
  <id>http://raytaylorlin.com/</id>
  
  <author>
    <name>Ray Taylor Lin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>游戏引擎中的资源与文件系统</title>
    <link href="http://raytaylorlin.com/tech/game/engine/resources-and-file-system/"/>
    <id>http://raytaylorlin.com/tech/game/engine/resources-and-file-system/</id>
    <published>2016-06-17T06:10:20.000Z</published>
    <updated>2016-06-17T06:16:11.682Z</updated>
    
    <content type="html">&lt;p&gt;载入及管理多种媒体，是游戏引擎必须具备的能力。多数引擎会采用某种类型的资源（或资产）管理器，载入并管理游戏所需的资源，并确保在同一时间每个媒体文件只可载入一份。每个资源管理器都会大量使用文件系统。本文将介绍现代三维游戏引擎中的各种文件系统API，再分析典型资源管理器的运作方式。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-文件系统&quot;&gt;&lt;a href=&quot;#1-文件系统&quot; class=&quot;headerlink&quot; title=&quot;1. 文件系统&quot;&gt;&lt;/a&gt;1. 文件系统&lt;/h1&gt;&lt;h2 id=&quot;1-1-文件名和路径&quot;&gt;&lt;a href=&quot;#1-1-文件名和路径&quot; class=&quot;headerlink&quot; title=&quot;1.1 文件名和路径&quot;&gt;&lt;/a&gt;1.1 文件名和路径&lt;/h2&gt;&lt;p&gt;关于文件和文件夹路径的概念，绝对路径和相对路径的概念，它们在各种操作系统之间的区别，属于常识范畴，此处不赘述。&lt;/p&gt;
&lt;p&gt;关于搜寻路径，是指含若干个路径（以特殊字符分隔）的字符串，寻找文件时会从这些路径逐个寻找，PATH环境变量就是一种搜寻路径。在运行期搜寻资产是费时的做法，而通常资产路径会在运行期之前就得知，所以应该完全避免搜寻资产。&lt;/p&gt;
&lt;p&gt;关于路径API，一般用于对路径进行多种操作，如分离“目录/文件名/扩展名”、使路径规范化、绝对和相对路径互转等等。游戏引擎通常会实现或封装轻量化的路径处理API，以便实现跨平台，从各种特殊的储存媒体（如记忆棒、DVD盘、网络文件系统等等）中存取数据，以及提供操作系统API未能提供的功能，如串流（即在游戏运行中同时载入数据）。&lt;/p&gt;
&lt;h2 id=&quot;1-2-基本文件I-O&quot;&gt;&lt;a href=&quot;#1-2-基本文件I-O&quot; class=&quot;headerlink&quot; title=&quot;1.2 基本文件I/O&quot;&gt;&lt;/a&gt;1.2 基本文件I/O&lt;/h2&gt;&lt;h3 id=&quot;1-2-1-文件I-O-API&quot;&gt;&lt;a href=&quot;#1-2-1-文件I-O-API&quot; class=&quot;headerlink&quot; title=&quot;1.2.1 文件I/O API&quot;&gt;&lt;/a&gt;1.2.1 文件I/O API&lt;/h3&gt;&lt;p&gt;许多游戏引擎都会把文件I/O API封装成自定义的API，这样至少有三个好处：保证I/O API在所有目标平台上均有相同行为；API可以简化到只剩下实际需要的函数，使维护开支维持最小限度；可提供延伸功能，如处理各种特殊的储存媒体（同自定义路径处理API）。&lt;/p&gt;
&lt;p&gt;每次调用输入/输出，都需要称为缓冲区的数据区块，以供程序和磁盘之间传送字节。当API负责管理数据缓冲，就称之为有缓冲功能的API，否则为无缓冲。C标准程序库中，以f开头的文件API是带缓冲的，如&lt;code&gt;fopen()&lt;/code&gt;，没有f开头是无缓冲的，如&lt;code&gt;read()&lt;/code&gt;。有时自行管理缓冲区是有必要的。例如往日志写数据可能会显著降低性能，可以先把数据累积在内存缓冲，满溢后才写进盘内，甚至把缓冲输出函数置于另一线程里，以避免令主游戏循环发生流水线停顿。&lt;/p&gt;
&lt;h3 id=&quot;1-2-2-同步与异步&quot;&gt;&lt;a href=&quot;#1-2-2-同步与异步&quot; class=&quot;headerlink&quot; title=&quot;1.2.2 同步与异步&quot;&gt;&lt;/a&gt;1.2.2 同步与异步&lt;/h3&gt;&lt;p&gt;C标准库的两种文件I/O库都是同步的，即程序发出I/O请求以后，必须等待读/写数据完毕，程序才能继续运行。为了提高用户体验，往往要使用串流来载入资源，这必须使用异步文件I/O库。多数异步I/O库容许主程序在请求发出后一段时间，等待I/O操作完成才继续运行。有些异步I/O库容许程序员取得某异步操作所需时间的估算，一些API也可以为请求设置时限，并设置请求超时的安排（例如取消请求、通知程序、继续尝试等）。&lt;/p&gt;
&lt;p&gt;异步I/O操作常有不同的优先权，例如从硬盘中串流音频，并且在串流其他资源时播放音频，显然前者优先权高于后者。异步I/O系统必须能暂停较低优先权的请求，才可以让较高优先权的I/O请求有机会在时限前完成。&lt;/p&gt;
&lt;p&gt;关于异步操作（不局限于文件I/O）的实现原理，一般是利用另一线程进行同步操作来实现。主线程调用异步函数时，会把请求放入一个队列，并立即传回。同时，I/O线程从队列中取出请求，并以阻塞I/O函数处理这些请求。请求的工作完成后，就会调用主线程之前提供的回调函数告之该操作己完成。若主线程选择等待完成I/O请求，就会使用信号量处理（每个请求对应一个信号量，主线程把自身处于休眠状态，等待I/O线程在完成请求工作后通知信号量）。&lt;/p&gt;
&lt;h1 id=&quot;2-资源管理器&quot;&gt;&lt;a href=&quot;#2-资源管理器&quot; class=&quot;headerlink&quot; title=&quot;2. 资源管理器&quot;&gt;&lt;/a&gt;2. 资源管理器&lt;/h1&gt;&lt;p&gt;资源管理器由两部分组成：一部分负责管理离线工具链，用来创建资产并把它们转换成引擎可用的形式；另一部分在执行期管理资源，确保资源在使用前已载入内存，不需要时从内存卸下。&lt;/p&gt;
&lt;h2 id=&quot;2-1-离线资源管理与工具链&quot;&gt;&lt;a href=&quot;#2-1-离线资源管理与工具链&quot; class=&quot;headerlink&quot; title=&quot;2.1 离线资源管理与工具链&quot;&gt;&lt;/a&gt;2.1 离线资源管理与工具链&lt;/h2&gt;&lt;h3 id=&quot;2-1-1-资产的版本控制&quot;&gt;&lt;a href=&quot;#2-1-1-资产的版本控制&quot; class=&quot;headerlink&quot; title=&quot;2.1.1 资产的版本控制&quot;&gt;&lt;/a&gt;2.1.1 资产的版本控制&lt;/h3&gt;&lt;p&gt;有些游戏团队使用源码版本控制工具来管理资源。艺术资产通常有极大的数据量，直接从中央版本库复制到本地往往是低效的。以下是一些参考解决方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用如Alienbrain这种特别针对极大量数据的商业VCS&lt;/li&gt;
&lt;li&gt;在VCS上精心设计一套系统，保证用户只会取得其真正所需的文件到本地&lt;/li&gt;
&lt;li&gt;顽皮狗开发了一款私有工具。用户拥有资产版本库的完整本地视图，只要文件未签出，本地就一直是UNIX的符号链接（Windows可以使用junction实现）以消除数据复制。当签出文件时则移除符号链接，更换为本地副本，签入时则相反。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;2-1-2-资源数据库&quot;&gt;&lt;a href=&quot;#2-1-2-资源数据库&quot; class=&quot;headerlink&quot; title=&quot;2.1.2 资源数据库&quot;&gt;&lt;/a&gt;2.1.2 资源数据库&lt;/h3&gt;&lt;p&gt;游戏引擎不会使用多数资产原本的格式，而是需要通过一些资产调节管道转换资产，转换过程中每个资源都会产生&lt;strong&gt;元数据&lt;/strong&gt;描述如何对资源进行处理。例如描述压缩纹理时，使用哪种压缩方法；描述导出动画片段时，导出哪个范围的帧。大型游戏需要“资源数据库”来管理资源管道所需的数据。无论采用什么形式，数据库都需要提供以下功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以一致的方式处理多种类型的资源&lt;/li&gt;
&lt;li&gt;创建、删除、查看、移动磁盘位置和修改资源&lt;/li&gt;
&lt;li&gt;资源交叉引用其他资源，并维持数据库内的引用完整性&lt;/li&gt;
&lt;li&gt;保存版本历史，含完整日志记录、改动者及事由&lt;/li&gt;
&lt;li&gt;支持不同形式的搜索和查询&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;2-1-3-一些成功的资源数据库设计&quot;&gt;&lt;a href=&quot;#2-1-3-一些成功的资源数据库设计&quot; class=&quot;headerlink&quot; title=&quot;2.1.3 一些成功的资源数据库设计&quot;&gt;&lt;/a&gt;2.1.3 一些成功的资源数据库设计&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;虚幻3：由万用工具UnrealEd管理，它是引擎的一部分&lt;ul&gt;
&lt;li&gt;优点：创建资产后能立即看到资产在游戏中运行的模样；以单一、整合、一致的界面管理所有类型的资源；资产必须明确导入数据库，制作初期便可检查资源有效性&lt;/li&gt;
&lt;li&gt;缺点：所有资源存于少量的大型二进制包文件，不利于VCS合并；资源重命名或移动时，使用虚拟对象，即把旧资源映射到新名称/位置，问题是虚拟对象会闲置、累积起来造成问题，尤其是删除资源时变得严重&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;顽皮狗的《神秘海域》引擎&lt;ul&gt;
&lt;li&gt;最初使用MySQL存储资源元数据，并编写自制GUI工具Builder管理，后改用Perforce以提供版本控制，元数据改为XML&lt;/li&gt;
&lt;li&gt;Builder管理演员（包含行为的动态对象）和关卡（含静态背景网格和关卡信息等）两种类型的资源，动画可以组成名为动画包（buddle）的伪文件夹&lt;/li&gt;
&lt;li&gt;引擎含一组基于命令行的工具，用于查询数据库，处理资源原生DCC文件，生成某演员或关卡&lt;/li&gt;
&lt;li&gt;优点：资源粒度小；Builder仅提供必需的特性；源文件映射显而易见，用户容易得知某资源由哪些资产而来；容易更改DCC数据的到处及处理方式；依赖系统会自动处理，生成资产非常容易&lt;/li&gt;
&lt;li&gt;缺点：欠缺预览资产的可视化工具；各种类型的工具没有完全整合&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;OGRE：拥有一个颇完备、设计非常好的运行时资源管理器，通过一组简单一致又有扩展性的接口就能载入任何类型的资源。缺点在于仅是运行时方案，本身提供的离线处理很弱&lt;/li&gt;
&lt;li&gt;微软的XNA：通过VS IDE的项目管理及生成系统，把游戏资产以同样形式管理及生成&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;2-1-4-资产调节管道&quot;&gt;&lt;a href=&quot;#2-1-4-资产调节管道&quot; class=&quot;headerlink&quot; title=&quot;2.1.4 资产调节管道&quot;&gt;&lt;/a&gt;2.1.4 资产调节管道&lt;/h3&gt;&lt;p&gt;资产调节管道用于将DCC原生格式文件转换成引擎可用的形式，一般经过3个处理阶段：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;导出器：为DCC工具编写自定义插件，将数据导出为某种中间格式。如果DCC不提供自定义方法，则应该把数据存成开放格式，或比较直观的文本格式，或其他可做反向工程的原生格式&lt;/li&gt;
&lt;li&gt;资源编译器：对DCC导出的数据进行一定处理，如把网格的三角形重新排列成三角形带，或压缩纹理。并非所有数据都要编译&lt;/li&gt;
&lt;li&gt;资源链接器：将多个资源先结合成单个有用的包，如复杂的三维模型，然后才载入至游戏引擎。并非所有数据都要链接&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如同程序的源文件，各资产之间也有依赖关系，例如某网格引用若干个材质，这些材质又引用多个纹理。这些依赖关系通常会影响资产在管道内的处理次序，也可告诉我们，当某个源资产做出改动后，要重新生成哪些资产。每个资产调节管道都需要一组规则来描述资产间的依赖关系，并自己搭建系统或使用像make这样的工具来以正确顺序生成资产。一定要管理好资产间的依赖。&lt;/p&gt;
&lt;h2 id=&quot;2-2-运行时资源管理&quot;&gt;&lt;a href=&quot;#2-2-运行时资源管理&quot; class=&quot;headerlink&quot; title=&quot;2.2 运行时资源管理&quot;&gt;&lt;/a&gt;2.2 运行时资源管理&lt;/h2&gt;&lt;h3 id=&quot;2-2-1-运行时资源管理器的责任&quot;&gt;&lt;a href=&quot;#2-2-1-运行时资源管理器的责任&quot; class=&quot;headerlink&quot; title=&quot;2.2.1 运行时资源管理器的责任&quot;&gt;&lt;/a&gt;2.2.1 运行时资源管理器的责任&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;确保任何时候，同一个资源在内存中只有一份副本&lt;/li&gt;
&lt;li&gt;管理每个资源的生命期&lt;/li&gt;
&lt;li&gt;处理复合资源的载入（如三维模型）&lt;/li&gt;
&lt;li&gt;维护引用完整性：包括单个资源内的交叉引用，以及资源间的交叉引用&lt;/li&gt;
&lt;li&gt;管理资源载入后的内存用量，确保资源储存在内存中合适的地方&lt;/li&gt;
&lt;li&gt;容许按资源类型，载入资源后执行自定义的处理&lt;/li&gt;
&lt;li&gt;通常提供统一的易扩展的接口管理多种资源类型&lt;/li&gt;
&lt;li&gt;若引擎支持，则要处理串流&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;2-2-1-资源文件及目录组织&quot;&gt;&lt;a href=&quot;#2-2-1-资源文件及目录组织&quot; class=&quot;headerlink&quot; title=&quot;2.2.1 资源文件及目录组织&quot;&gt;&lt;/a&gt;2.2.1 资源文件及目录组织&lt;/h3&gt;&lt;p&gt;资源一般储存为磁盘上的文件，并位于使创作者方便而组织的树状目录中。但引擎通常不会理会资源被放置于资源树中的哪个位置，引擎会把多个资源包裹为单一文件，这种手法能将寻道时间、开启每个文件的时间、从文件读至内存的时间都降到最低。&lt;/p&gt;
&lt;p&gt;OGRE使用ZIP存档资源，因为ZIP是开放格式，内部虚拟文件有相对路径，可被压缩（载入数据后解压所花的时间，通常比读取无压缩数据所花的时间少），并可视为模块（例如把需要本地化的资产打包，针对不同语言制作不同版本的ZIP）。虚幻3采取类似的手法，但是其所有资源都必须置于大型的pak自定义格式文件中，并不容许资源以盘上独立文件出现。&lt;/p&gt;
&lt;h3 id=&quot;2-2-2-资源文件格式和GUID&quot;&gt;&lt;a href=&quot;#2-2-2-资源文件格式和GUID&quot; class=&quot;headerlink&quot; title=&quot;2.2.2 资源文件格式和GUID&quot;&gt;&lt;/a&gt;2.2.2 资源文件格式和GUID&lt;/h3&gt;&lt;p&gt;每类资源都可能有不同的文件格式。单一文件格式也可储存多种不同类型的资产，如Granny的文件格式可轻易用来储存任何种类的数据。许多引擎会自定义文件格式，因为引擎所需部分信息可能没有标准格式可以支持，以及对资源脱机处理，以让其遵从某种内存布局加速运行时载入。&lt;/p&gt;
&lt;p&gt;所有资源都需要GUID来识别，最常见就是使用资源的文件系统路径（操作系统保证两个文件不能有相同的路径），也有使用128位散列GUID的。虚幻3的GUID格式是包名和包内资源路径串接而成，像《战争机器》的一个资源GUID为&lt;code&gt;Locust_Boomer.PhysicalMaterials.LocustBommerLeather&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;2-2-3-资源注册表&quot;&gt;&lt;a href=&quot;#2-2-3-资源注册表&quot; class=&quot;headerlink&quot; title=&quot;2.2.3 资源注册表&quot;&gt;&lt;/a&gt;2.2.3 资源注册表&lt;/h3&gt;&lt;p&gt;资源管理器都含某种形式的资源注册表，以&lt;strong&gt;保证在任何时间，载入内存的每个资源只会有一份副本&lt;/strong&gt;。最简单的实现方法是使用字典，键为资源的GUID，而值是指向内存中资源的指针。资源载入内存时，加进资源注册表字典。卸下资源时，就删除其注册表记录。&lt;/p&gt;
&lt;p&gt;若不能从表中找到请求的资源，最直觉的处理手法就是自动载入该资源。但这样做可能会因为临时从硬盘或光驱等缓慢设备读取数据而严重拖慢游戏帧率。因此引擎可采取这两种替代手法：游戏进行中完全禁止加载资源（游戏关卡的所有资源在游戏进行前全部加载，那时候通常是loading界面）；或资源以相对较难实现的异步形式加载，如玩关卡A时，关卡B的资源在后台加载。&lt;/p&gt;
&lt;h3 id=&quot;2-2-4-资源生命期&quot;&gt;&lt;a href=&quot;#2-2-4-资源生命期&quot; class=&quot;headerlink&quot; title=&quot;2.2.4 资源生命期&quot;&gt;&lt;/a&gt;2.2.4 资源生命期&lt;/h3&gt;&lt;p&gt;资源管理器的职责之一是自动管理资源生命期，或对游戏提供所需API供手动管理。每个资源对生命期有不同需求：游戏持续的所有时间（如角色网格、纹理、动画，HUD的纹理字形等等），持续某一关卡的时间，短于所在关卡的时间（如过场动画），即时串流（如BGM、环境音效等）。&lt;/p&gt;
&lt;p&gt;某资源的载入时期通常在玩家第一次看见该资源便能决定，但何时卸下资源归还内存，就难以回答，因为可能存在多个关卡共享的资源。解决方案之一就是对资源引用计数，即载入新关卡时，遍历所需资源并引用加1，再遍历即将结束的关卡的资源，所有引用减1。下图给出了资源引用计数的例子。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://raytaylorlin-blog.qiniudn.com/image%2Fengine%2F%E8%BD%BD%E5%85%A5%E6%88%96%E5%8D%B8%E4%B8%8B%E4%B8%A4%E4%B8%AA%E5%85%B3%E5%8D%A1%E6%97%B6%E8%B5%84%E6%BA%90%E7%9A%84%E5%BC%95%E7%94%A8%E5%8F%98%E5%8C%96.jpg&quot; alt=&quot;载入或卸下两个关卡时资源的引用变化&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-2-5-资源的内存管理&quot;&gt;&lt;a href=&quot;#2-2-5-资源的内存管理&quot; class=&quot;headerlink&quot; title=&quot;2.2.5 资源的内存管理&quot;&gt;&lt;/a&gt;2.2.5 资源的内存管理&lt;/h3&gt;&lt;p&gt;资源加载的内存位置可能不同，像纹理、顶点缓冲、着色器驻留在显存，大部分资源驻留在主内存。设计游戏引擎时，有时用已有的内存分配器来设计资源系统，有时则要让内存分配器配合资源管理所需。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于堆栈分配器：若游戏是以线性关卡为中心，且内存足够容纳各个完整关卡，则可用堆栈分配器。注意栈顶端先分配驻留资源（LSR，各关卡共享的资源），再分配关卡所需内存。&lt;/li&gt;
&lt;li&gt;基于池分配器：因为每个内存组块大小相同，要注意设计资源数据时，必须避免大型连续数据结构，容许资源能被切割成同等大小的块。这种分配方式天生的问题就是文件内&lt;strong&gt;最后的组块&lt;/strong&gt;空间被浪费。选择组块大小时，可以考虑设为操作系统I/O缓冲区大小的倍数，如512KB。&lt;/li&gt;
&lt;li&gt;资源组块分配器：专为解决上述组块浪费内存而设的分配模式。只需管理一个链表，内含所有未用满内存的组块以及自由内存块的位置及大小。这种方案有一个问题是卸下资源内存时，其“边角”的组块也会同时消失。解决方案是只利用该种分配器分配&lt;strong&gt;和对应关卡生命期相同的内存&lt;/strong&gt;，这需要独立地管理每个关卡的组块，且用户请求分配时指明从哪个关卡分配内存。&lt;/li&gt;
&lt;li&gt;分段资源文件：将资源文件分为若干段，每段分为若干个组块（与池分配器配合）。各段的作用不同，有的是为主内存而设的数据，有的是仅在载入过程中使用、载入后被弃置的临时数据，有的是发行版本不会载入的调试信息&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;2-2-6-资源的交叉引用&quot;&gt;&lt;a href=&quot;#2-2-6-资源的交叉引用&quot; class=&quot;headerlink&quot; title=&quot;2.2.6 资源的交叉引用&quot;&gt;&lt;/a&gt;2.2.6 资源的交叉引用&lt;/h3&gt;&lt;p&gt;资源的交叉引用意味着资源间的依赖性，所以资源数据库可以表达为依赖对象所组成的有向图。交叉引用可以分为内部（单个文件里对象间的引用）和外部（引用另一个文件的对象）。下图给出了资源数据库的交叉引用例子。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://raytaylorlin-blog.qiniudn.com/image%2Fengine%2F%E8%B5%84%E6%BA%90%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BA%A4%E5%8F%89%E5%BC%95%E7%94%A8%E4%BE%8B%E5%AD%90.png&quot; alt=&quot;资源数据库的交叉引用例子&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;2-2-6-1-处理资源内部引用&quot;&gt;&lt;a href=&quot;#2-2-6-1-处理资源内部引用&quot; class=&quot;headerlink&quot; title=&quot;2.2.6.1 处理资源内部引用&quot;&gt;&lt;/a&gt;2.2.6.1 处理资源内部引用&lt;/h4&gt;&lt;p&gt;在C++中， 由于指针的内存地址总会变，而且离开运行中的程序就失去意义，所以不能用指针来表示对象间的依赖。可以将资源引用存为GUID（全局唯一的字符串或散列码），资源管理器要维护一个全局资源查找表，其中键为GUID，值为资源在内存中的地址。&lt;/p&gt;
&lt;p&gt;储存对象到二进制文件的另一常用方法是，把指针转换为为文件偏移值，并建立指针修正表。下图给出了储存二进制文件以及将文件载入内存的指针修正示意，具体过程为：①把每个对象的内存影响遍历一次，顺序写至文件成为连续映像；②写进文件的代码，清楚知道对象的数据类型和类，也就知道每个对象的指针在哪里，把这些指针位置储存到指针修正表并一同写进文件；③载入文件至内存时，映像内对象仍保持连续，并凭借修正表修正所有指针。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://raytaylorlin-blog.qiniudn.com/image%2Fengine%2F%E5%82%A8%E5%AD%98%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E4%BB%A5%E5%8F%8A%E5%B0%86%E6%96%87%E4%BB%B6%E8%BD%BD%E5%85%A5%E5%86%85%E5%AD%98%E7%9A%84%E6%8C%87%E9%92%88%E4%BF%AE%E6%AD%A3%E7%A4%BA%E6%84%8F.jpg&quot; alt=&quot;储存二进制文件以及将文件载入内存的指针修正示意&quot;&gt;&lt;/p&gt;
&lt;p&gt;从文件载入C++对象，必须调用对象的构造函数。这个问题有两个常见解决方案：使用纯C结构体来储存数据或使用无虚函数、只含不做事情的平凡构造函数的C++ struct/class；表里记录对象属于哪个类，并使用&lt;a href=&quot;https://en.wikipedia.org/wiki/Placement_syntax&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;placement new&lt;/a&gt;语法调用构造函数，像下面的代码所示。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void* pObject = ConvertOffsetToPointer(objectOffset);
::new(pObject) ClassName;  // placement new语法，ClassName为对象所属的类名
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;2-2-6-2-处理资源外部引用&quot;&gt;&lt;a href=&quot;#2-2-6-2-处理资源外部引用&quot; class=&quot;headerlink&quot; title=&quot;2.2.6.2 处理资源外部引用&quot;&gt;&lt;/a&gt;2.2.6.2 处理资源外部引用&lt;/h4&gt;&lt;p&gt;以上提及的两个方案，仅对资源内部引用有效。要正确表示外部引用，除了指明偏移值或GUID，还要加上资源对象所属文件的路径。一般做法是：载入每个资源文件时，扫描文件中的交叉引用表，并载入所有被外部引用但未载入的资源文件，当载入所有互相依赖的资源时，就用主查找表把所有指针转换成真实的内存地址。&lt;/p&gt;
&lt;h3 id=&quot;2-2-7-资源载入后初始化&quot;&gt;&lt;a href=&quot;#2-2-7-资源载入后初始化&quot; class=&quot;headerlink&quot; title=&quot;2.2.7 资源载入后初始化&quot;&gt;&lt;/a&gt;2.2.7 资源载入后初始化&lt;/h3&gt;&lt;p&gt;有一些资源载入内存时需要进行一些无法避免的初始化，例如三维网格的顶点和索引载入主内存后，几乎总是要传送至显存，而且只能在运行时进行。在C++中，可以使用多态为每个类设置如&lt;code&gt;Init()&lt;/code&gt;和&lt;code&gt;Destroy()&lt;/code&gt;的虚函数用于独立初始化和销毁工作。载入后初始化和资源内存分配策略息息相关，有时初始化会在文件的数据上新增数据（如额外计算类中的成员数据），有时初始化的数据用来取代己载入的数据（如引擎载入过时格式的网格数据，自动转换为最新格式，以保证向后兼容）。可以采用先载入到临时内存区域，初始化完成后再把相关数据复制到内存最终位置。&lt;/p&gt;
&lt;p&gt;参考文献：电子工业出版社《游戏引擎架构》第6章&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;载入及管理多种媒体，是游戏引擎必须具备的能力。多数引擎会采用某种类型的资源（或资产）管理器，载入并管理游戏所需的资源，并确保在同一时间每个媒体文件只可载入一份。每个资源管理器都会大量使用文件系统。本文将介绍现代三维游戏引擎中的各种文件系统API，再分析典型资源管理器的运作方式。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="游戏开发" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
      <category term="游戏引擎" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    
      <category term="游戏引擎" scheme="http://raytaylorlin.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
      <category term="架构" scheme="http://raytaylorlin.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>游戏引擎支持系统（下）</title>
    <link href="http://raytaylorlin.com/tech/game/engine/engine-support-system-2/"/>
    <id>http://raytaylorlin.com/tech/game/engine/engine-support-system-2/</id>
    <published>2016-06-12T12:33:11.000Z</published>
    <updated>2016-06-12T12:33:13.452Z</updated>
    
    <content type="html">&lt;p&gt;游戏编程中需要使用各种各样的集合型数据结构，称为容器或集合。字符串看似是个简单基本的数据类型，但在游戏引擎中会涉及许多设计问题和限制。此外，游戏引擎总是伴随大量可调校的选项，有的通过游戏中的选项菜单给玩家调校，有的则只为游戏开发团队设置，在正式发行时被隐掉或去除。&lt;/p&gt;
&lt;p&gt;本文将接着&lt;a href=&quot;/tech/game/engine/engine-support-system-1/&quot;&gt;上一篇&lt;/a&gt;，从游戏引擎的角度描述容器、字符串和引擎配置等游戏引擎支持系统。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-容器&quot;&gt;&lt;a href=&quot;#1-容器&quot; class=&quot;headerlink&quot; title=&quot;1. 容器&quot;&gt;&lt;/a&gt;1. 容器&lt;/h1&gt;&lt;p&gt;常见的容器类型包括但不限于：数组、动态数组（可变长）、链表 、堆栈、队列、双端队列、优先队列（二叉堆）、树、二叉查找树（红黑树、伸展树、AVL树等）、字典、集合、图、有向非循环图。常见操作有：插入、移除、顺序访问/迭代、随机访问、查找、排序等等。&lt;/p&gt;
&lt;p&gt;访问容器元素通常都会使用迭代器，它“知道”如何高效地访问容器中的某个元素，移至下一个元素，并用某种方式表示是否遍历完所有元素。使用迭代器的好处是：避免破坏容器类的封装，简化迭代过程。&lt;/p&gt;
&lt;h2 id=&quot;1-1-是否建立自定义的容器类&quot;&gt;&lt;a href=&quot;#1-1-是否建立自定义的容器类&quot; class=&quot;headerlink&quot; title=&quot;1.1 是否建立自定义的容器类&quot;&gt;&lt;/a&gt;1.1 是否建立自定义的容器类&lt;/h2&gt;&lt;p&gt;许多游戏引擎会提供常见容器的自定义实现，而非使用第三方库，原因如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;完全掌控：控制数据结构的内存需求、具体算法、分配内存时机等&lt;/li&gt;
&lt;li&gt;优化的机会：如借助游戏机独有的硬件功能来优化&lt;/li&gt;
&lt;li&gt;可定制性：提供第三方库不常见的功能，如搜寻n个最相关的元素&lt;/li&gt;
&lt;li&gt;消除外部依赖：使用第三方库有无法自行调试维护的风险&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第三方库功能强大，使用方便，但有时并不适合游戏引擎。如果决定要使用第三方库，要对它们的优缺点有全方位的了解。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;STL&lt;ul&gt;
&lt;li&gt;优点：功能丰富；跨平台；几乎所有C++编译器都自带&lt;/li&gt;
&lt;li&gt;缺点：学习曲线陡峭；相比自定义数据结构速度较慢；占用更多内存；进行许多动态内存分配；各编译器的实现微小差异导致移植多平台麻烦&lt;/li&gt;
&lt;li&gt;STL比较适合PC上的引擎，而不适用于游戏主机&lt;/li&gt;
&lt;li&gt;使用经验：用某个STL类前，充分认识其效能和内存特性；避免在可能的性能瓶颈处使用STL；占小量内存的情况才使用STL；若引擎需要支持多平台，推荐会用STLport&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Boost&lt;ul&gt;
&lt;li&gt;优点：提供许多STL没有的有用功能；提供解决STL设计或实现上的问题的替代方案；有效处理智能指针这种复杂问题；文档写得很好（也是优秀的学习材料）&lt;/li&gt;
&lt;li&gt;缺点：生成颇大的.lib文件，不适合小型项目；不保证支持向后兼容；小心阅读许可证内容&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://loki-lib.sourceforge.net/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Loki&lt;/a&gt;：其模板元编程功能极其强大，但代码可能望而生畏，难以使用，而且某些元件依赖编译器的“副作用”行为。Loki不适合胆小者，但是其设计理念非常值得学习&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-2-一些常用数据结构的使用建议&quot;&gt;&lt;a href=&quot;#1-2-一些常用数据结构的使用建议&quot; class=&quot;headerlink&quot; title=&quot;1.2 一些常用数据结构的使用建议&quot;&gt;&lt;/a&gt;1.2 一些常用数据结构的使用建议&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;动态数组：游戏编程中大量使用固定大小数组以避免动态分配的开销，而且因连续而对缓存友好。可以在开发期选用动态数组，当确定适当的内存预算时，将其改为固定大小的数组（可以自行建立一个兼容&lt;code&gt;std::vector&lt;/code&gt;接口的模板&lt;/li&gt;
&lt;li&gt;链表&lt;ul&gt;
&lt;li&gt;外露式表：节点保存&lt;strong&gt;指向实际元素&lt;/strong&gt;的指针。优点是一个元素能同时置于多个链表，缺点是必须动态分配节点。使用池分配器是最佳选择。&lt;/li&gt;
&lt;li&gt;侵入式表：元素的数据结构被嵌入节点。优点是无须动态分配，缺点是没有外露式表那么有弹性。&lt;/li&gt;
&lt;li&gt;若不惜一切代价都要避免动态内存分配，则选用侵入式表；若能负担得起池分配的开销，或链表中的实例来自第三方库，则选用外露式表&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;字典和散列表：注意散列（把任意类型的键转换为整数）函数的选择是关键。若键为32位整数，把其位模式诠释为32位整数；若键为字符串，则把字符串中所有字符的ASCII或UTF码合并为单个32位整数，常见的字符串散列函数有LOOKUP3、CRC32、MD5等等&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;2-字符串&quot;&gt;&lt;a href=&quot;#2-字符串&quot; class=&quot;headerlink&quot; title=&quot;2. 字符串&quot;&gt;&lt;/a&gt;2. 字符串&lt;/h1&gt;&lt;h2 id=&quot;2-1-字符串类&quot;&gt;&lt;a href=&quot;#2-1-字符串类&quot; class=&quot;headerlink&quot; title=&quot;2.1 字符串类&quot;&gt;&lt;/a&gt;2.1 字符串类&lt;/h2&gt;&lt;p&gt;字符串类虽然方便，但有隐性成本：传递字符串对象时，函数声明或使用不当引起多个拷贝构造函数的开销；复制字符串涉及动态内存分配。若一定要使用字符串类，应该查明其运行性能特性在可接受的范围，并让所有使用它的程序员知悉其开销。&lt;/p&gt;
&lt;p&gt;在储存和管理文件系统路径时，使用特化的字符串类（如Path类）来处理多平台的字符串差异，在游戏引擎中是很有价值的。&lt;/p&gt;
&lt;h2 id=&quot;2-2-唯一标识符&quot;&gt;&lt;a href=&quot;#2-2-唯一标识符&quot; class=&quot;headerlink&quot; title=&quot;2.2 唯一标识符&quot;&gt;&lt;/a&gt;2.2 唯一标识符&lt;/h2&gt;&lt;p&gt;唯一标识符（64位或128位的GUID字符串）用于识别游戏对象或资产，由于数量非常多，大量的比较在游戏中可能极有影响。最好找到一种方法，既保留字符串的表达能力和弹性，又要有整数操作的速度。可以把字符串散列并存于表中（该过程称为字符串扣留），并通过散列码（也称为字符串标识符，string id或SID）取回原来的字符串，但要选取恰当的散列函数保证不碰撞。&lt;/p&gt;
&lt;p&gt;因为字符串扣留（散列，分配字符串内存，复制至查找表）非常缓慢，所以通常&lt;strong&gt;在运行时就进行，而且仅进行一次，把结果储存备用&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;2-3-本地化&quot;&gt;&lt;a href=&quot;#2-3-本地化&quot; class=&quot;headerlink&quot; title=&quot;2.3 本地化&quot;&gt;&lt;/a&gt;2.3 本地化&lt;/h2&gt;&lt;p&gt;对每个向用户显示的字符串，都要事先翻译为需要支持的语言（程序内部使用的，永不显示于用户的字符串无须本地化）。除了通过使用合适的字体，为所有支持语言准备字符字形，游戏还需要处理不同的文本方向（针对一些阅读顺序很特殊的语言）。&lt;/p&gt;
&lt;p&gt;推荐先阅读这篇文章：&lt;a href=&quot;http://local.joelonsoftware.com/wiki/The_Joel_on_Software_Translation_Project:%E8%90%AC%E5%9C%8B%E7%A2%BC&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《每个软件开发者都绝对必知的Unicode及字元集必备知识(没有借口！)》&lt;/a&gt;。游戏引擎中最常采用的是UTF-8和UTF-16。&lt;/p&gt;
&lt;h3 id=&quot;2-3-1-Windows下的Unicode&quot;&gt;&lt;a href=&quot;#2-3-1-Windows下的Unicode&quot; class=&quot;headerlink&quot; title=&quot;2.3.1 Windows下的Unicode&quot;&gt;&lt;/a&gt;2.3.1 Windows下的Unicode&lt;/h3&gt;&lt;p&gt;在Windows下，&lt;code&gt;wchar_t&lt;/code&gt;用来表示单个“宽”UTF-16字符（WCS），&lt;code&gt;char&lt;/code&gt;则用作ANSI字符及多字节UTF-16字符串（MBCS）。Windows容许程序员编写&lt;strong&gt;字符集无关&lt;/strong&gt;的代码，即提供&lt;code&gt;TCHAR&lt;/code&gt;数据类型，它会根据实际所用的字符集自动typedef为特定的类型。&lt;/p&gt;
&lt;p&gt;注意Windows中各种API和标准函数库，无前缀表示普通ANSI字符，前缀为“w”“wcs”表示宽字符，缀为“mbs”表示多字节UTF-16，如&lt;code&gt;strcmp()&lt;/code&gt;、&lt;code&gt;wcscmp()&lt;/code&gt;和&lt;code&gt;_mbscmp()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;对于游戏机上的Unicode，Xbox 360开发套件几乎完全采用WCS字符串。不同的引擎采用哪种编码并不重要，重要的是在项目中尽早决定，并始终贯彻使用。&lt;/p&gt;
&lt;h3 id=&quot;2-3-2-其他本地化要考虑的事&quot;&gt;&lt;a href=&quot;#2-3-2-其他本地化要考虑的事&quot; class=&quot;headerlink&quot; title=&quot;2.3.2 其他本地化要考虑的事&quot;&gt;&lt;/a&gt;2.3.2 其他本地化要考虑的事&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;本地化不仅包括字符，还包括录制语音、带文字的纹理，还要注意一些符号在不同文化中意义的差别，注意不同市场的评级界限&lt;/li&gt;
&lt;li&gt;本地化系统需要建立字符串数据库，通过SID以及全局的“当前语言”设定来查找对应的语言字符串。其函数声明可能为：&lt;code&gt;const wchar_t* getLocalizedString(const char* sid)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;数据库的实现细节不是很重要，可以用CSV，也可以用专门的DBMS&lt;/li&gt;
&lt;li&gt;程序员切记&lt;strong&gt;不要硬编码原始字符串&lt;/strong&gt;，而是采用上述查找函数取得所需字符串。注意字符串可能需要处理像&lt;code&gt;&amp;quot;Player {0} Score: {1}&amp;quot;&lt;/code&gt;这样的格式化串&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;3-引擎配置&quot;&gt;&lt;a href=&quot;#3-引擎配置&quot; class=&quot;headerlink&quot; title=&quot;3. 引擎配置&quot;&gt;&lt;/a&gt;3. 引擎配置&lt;/h1&gt;&lt;h2 id=&quot;3-1-读写选项&quot;&gt;&lt;a href=&quot;#3-1-读写选项&quot; class=&quot;headerlink&quot; title=&quot;3.1 读写选项&quot;&gt;&lt;/a&gt;3.1 读写选项&lt;/h2&gt;&lt;p&gt;可配置选项可简单实现为全局变量或单例中的成员变量，这些选项必须可供用户配置，储存到硬盘、记忆卡或其他媒体，游戏能随时读取。下面是一些读写选项的方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文本配置文件：如INI、XML、JSON等等&lt;/li&gt;
&lt;li&gt;经压缩的二进制文件：主要用于老式游戏主机上储存空间极其有限的记忆卡&lt;/li&gt;
&lt;li&gt;Windows注册表：以树形式存储，内部节点为注册表项（类似文件夹），叶节点以键值对储存选项。任何应用程序都可预留一个注册表项存储任意内容&lt;/li&gt;
&lt;li&gt;命令行选项：通过扫描命令行取得选项设置&lt;/li&gt;
&lt;li&gt;环境变量&lt;/li&gt;
&lt;li&gt;线上用户设定档：存储在中央服务器，必须通过联网存取，一般用于存储用户成就、已购买或解锁的游戏内容、游戏选项及其他信息&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;3-2-个别用户选项&quot;&gt;&lt;a href=&quot;#3-2-个别用户选项&quot; class=&quot;headerlink&quot; title=&quot;3.2 个别用户选项&quot;&gt;&lt;/a&gt;3.2 个别用户选项&lt;/h2&gt;&lt;p&gt;个别用户选项保留了每个玩家自己配置其喜欢的选项，与全局选项区分开来。需要小心控制每个玩家只能“看见”自己的选项，而不会遇见其他玩家在同一设备的选项。&lt;/p&gt;
&lt;p&gt;在Windows上，应用程序通常在&lt;code&gt;C:\Documents and Settings&lt;/code&gt;的隐藏文件夹&lt;code&gt;Application Data&lt;/code&gt;文件夹中建立自己的文件夹，存放个别用户数据。或者通过读写注册表&lt;code&gt;HKEY_CURRENT_USER&lt;/code&gt;下的注册表项，来存取管理当前用户的配置选项。&lt;/p&gt;
&lt;h2 id=&quot;3-3-真实引擎中的配置管理&quot;&gt;&lt;a href=&quot;#3-3-真实引擎中的配置管理&quot; class=&quot;headerlink&quot; title=&quot;3.3 真实引擎中的配置管理&quot;&gt;&lt;/a&gt;3.3 真实引擎中的配置管理&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;雷神之锤的主控台变量（Console Variables，CVAR）：一个储存浮点数或字符串的全局变量，可在主控台下查看及修改，部分值可储存到硬盘上的&lt;code&gt;config.cfg&lt;/code&gt;文件&lt;/li&gt;
&lt;li&gt;OGRE引擎：使用INI，像&lt;code&gt;plugins.cfg&lt;/code&gt;记录要启用的插件及路径，&lt;code&gt;resources.cfg&lt;/code&gt;包含游戏资产的路径。通过&lt;code&gt;Ogre::ConfigFile&lt;/code&gt;类可轻易读写全新的配置文件&lt;/li&gt;
&lt;li&gt;顽皮狗的神秘海域引擎：使用以下多种配置机制&lt;ul&gt;
&lt;li&gt;游戏内置菜单选项：每个可配置选项都实现为全局变量，为选项创建菜单项目时，会提供全局变量的地址，之后菜单项目就能直接控制该全局变量的值&lt;/li&gt;
&lt;li&gt;命令行参数：可指定要载入的关卡名称，以及其他常用参数&lt;/li&gt;
&lt;li&gt;Scheme（一种Lisp方言）数据定义：通过脚本定义数据结构，并用自建的数据编译器转换为二进制文件，同时自动生成C/C++的头文件以解释二进制文件的数据。可以在运行期间重编译和重加载二进制文件，以便随时修改数据结构并立即看到效果。这种系统给予程序员巨大的弹性，可以定义复杂的数据结构，如细致的动画树、物理参数、游戏机制等。下面的代码示例，用于为动画定义属性，并导出2个动画&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;;; Scheme代码，定义一个新的数据类型，名为simple-animation
(deftype simple-animation () (
    (name string)
    (speed float: default 1.0)
    (fade-in-seconds float: default 0.25)
    (fade-out-seconds float: default 0.25)
))

;; 定义此数据结构2个实例
(define-export anim-walk
    (new simple-animation
        :name &amp;quot;walk&amp;quot;
        :speed 1.0
    )
)
(define-export anim-jump
    (new simple-animation
        :name &amp;quot;jump&amp;quot;
        :fade-in-seconds 0.1
        :fade-out-seconds 0.1
    )
)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此Scheme代码会产生以下C/C++头文件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// simple-animation.h
// 警告：本文件是Scheme自动生成的，不要手工修改
struct SimpleAnimation {
    const char* m_name;
    float m_speed;
    float m_fadeInSeconds;
    float m_fadeOutSeconds;
};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在游戏编程中，可调用&lt;code&gt;LookupSymbol()&lt;/code&gt;函数读取数据，该函数&lt;strong&gt;以返回类型为模板参数&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;quot;simple-animation.h&amp;quot;

void someFunction() {
    SimpleAnimation* pWalkAnim = LookupSymbol&amp;lt;SimpleAnimation*&amp;gt;(&amp;quot;anim-walk&amp;quot;);
    SimpleAnimation* pJumpAnim = LookupSymbol&amp;lt;SimpleAnimation*&amp;gt;(&amp;quot;anim-jump&amp;quot;);
    // 在此使用这些动画......
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;参考文献：电子工业出版社《游戏引擎架构》第5.3-5.5节&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;游戏编程中需要使用各种各样的集合型数据结构，称为容器或集合。字符串看似是个简单基本的数据类型，但在游戏引擎中会涉及许多设计问题和限制。此外，游戏引擎总是伴随大量可调校的选项，有的通过游戏中的选项菜单给玩家调校，有的则只为游戏开发团队设置，在正式发行时被隐掉或去除。&lt;/p&gt;
&lt;p&gt;本文将接着&lt;a href=&quot;/tech/game/engine/engine-support-system-1/&quot;&gt;上一篇&lt;/a&gt;，从游戏引擎的角度描述容器、字符串和引擎配置等游戏引擎支持系统。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="游戏开发" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
      <category term="游戏引擎" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    
      <category term="游戏引擎" scheme="http://raytaylorlin.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
      <category term="架构" scheme="http://raytaylorlin.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>游戏引擎支持系统（上）</title>
    <link href="http://raytaylorlin.com/tech/game/engine/engine-support-system-1/"/>
    <id>http://raytaylorlin.com/tech/game/engine/engine-support-system-1/</id>
    <published>2016-06-10T14:02:07.000Z</published>
    <updated>2016-06-10T14:12:57.595Z</updated>
    
    <content type="html">&lt;p&gt;每个游戏都需要一些底层支持系统，以管理一些例行却关键的任务，例如启动及终止引擎、存取文件系统、存取各种不同资产类型（网格、纹理、动画、音频等），以及为游戏团队提供调试工具。&lt;/p&gt;
&lt;p&gt;本文（分上下篇）重点讨论多数游戏引擎中都会出现的底层支持系统，为后续探索大型的核心系统做准备。其中上篇将讨论子系统的启动和终止的顺序管理，以及各种动态内存分配器和碎片整理等内存管理问题。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-子系统的启动和终止&quot;&gt;&lt;a href=&quot;#1-子系统的启动和终止&quot; class=&quot;headerlink&quot; title=&quot;1. 子系统的启动和终止&quot;&gt;&lt;/a&gt;1. 子系统的启动和终止&lt;/h1&gt;&lt;p&gt;游戏引擎是复杂软件，由多个互相合作的子系统结合而成。各子系统间的相互依赖关系，隐含地定义了每个子系统所需的启动次序，例如子系统B依赖子系统A，那么先启动A，再启动B，而各子系统的终止顺序则相反。&lt;/p&gt;
&lt;p&gt;多数游戏引擎都是采用C++为编程语言，所以应该考虑C++原生的语法如何供启动及终止子系统所用。通常，每个子系统会被设计为单例（或称为管理器manager）。最有效的简单方法是，每个单例管理器的构造和析构函数不做任何事，而是自定义各自的&lt;code&gt;startUp()&lt;/code&gt;和&lt;code&gt;shutDown()&lt;/code&gt;方法，然后在main函数中调用控制各系统启动和终止的顺序。&lt;/p&gt;
&lt;p&gt;还有更优雅的实现方式，例如让各管理器把自己登记在一个全局的优先队列，之后再按恰当次序逐一启动；或者让每个管理器列举其依赖的管理器，定义一个管理器间的依赖图，再计算最优的启动次序。总之，蛮力法虽然粗暴，但是简单容易实现，非常容易调试和维护，是首选的方法。&lt;/p&gt;
&lt;h1 id=&quot;2-内存管理&quot;&gt;&lt;a href=&quot;#2-内存管理&quot; class=&quot;headerlink&quot; title=&quot;2. 内存管理&quot;&gt;&lt;/a&gt;2. 内存管理&lt;/h1&gt;&lt;p&gt;任何软件的性能，不仅受算法的选择和算法编码的效率所支配，程序如何运用内存也是重要因素。内存对性能的影响有动态内存分配、内存碎片和缓存等方面。&lt;/p&gt;
&lt;h2 id=&quot;2-1-优化动态内存分配&quot;&gt;&lt;a href=&quot;#2-1-优化动态内存分配&quot; class=&quot;headerlink&quot; title=&quot;2.1 优化动态内存分配&quot;&gt;&lt;/a&gt;2.1 优化动态内存分配&lt;/h2&gt;&lt;p&gt;通过malloc()/free()或C++的new/delete运算符动态分配内存通常是非常慢的，原因有两个：堆分配器是通用设施，可以处理任何大小的分配请求，需要大量的管理开销；多数操作系统上分配内存会在用户模式和内核模式来回切换，这些上下文切换可能会耗费很多时间。因此，游戏开发中一个常见的经验法则是：&lt;strong&gt;维持最低限度的堆分配，并且永不在紧凑循环中使用堆分配。&lt;/strong&gt; 当然，任何游戏引擎都无法完全避免动态内存分配，所以会实现若干个定制分配器。定制分配器比原生分配器更高效的原因有两个：从预分配的内存中完成分配请求（顶分配内存来自new），完全避免了上下文切换；对内存的使用模式做出多种假设，会比通用的堆分配器高效得多。&lt;/p&gt;
&lt;h3 id=&quot;2-1-1-基于堆栈的分配器&quot;&gt;&lt;a href=&quot;#2-1-1-基于堆栈的分配器&quot; class=&quot;headerlink&quot; title=&quot;2.1.1 基于堆栈的分配器&quot;&gt;&lt;/a&gt;2.1.1 基于堆栈的分配器&lt;/h3&gt;&lt;p&gt;许多关卡类的游戏，载入关卡时就会为关卡分配内存，关卡载入后，就会很少甚至不会动态分配内存。在玩家完成关卡之际，关卡的数据会被卸下，所有关卡占用的内存也可被释放。这类内存分配非常适合采用堆栈分配器。这种分配器要分配一大块连续内存，通过移动一个指向堆栈顶端的指针来“模拟”内存的分配和释放。释放时按分配的相反次序，不容许释放个别的内存块，而是释放从回滚点（标记）至目前堆栈顶端之间的所有内存。&lt;/p&gt;
&lt;p&gt;双端堆栈分配器（即一个分配器从内存块底端往上分配，另一个从内存块顶端往下分配）可以更有效地运用内存。一种非常优秀的从不会产生内存碎片问题的分配方案：所有内存分配自单个巨大内存块，以双端堆栈分配器管理，底堆栈用来载入及卸下游戏关卡，顶堆栈则用来分配临时内存块，这些临时内存会在每帧中分配及释放。堆栈分配器的实现模型见下图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://raytaylorlin-blog.qiniudn.com/image%2Fengine%2F%E5%A0%86%E6%A0%88%E5%88%86%E9%85%8D%E5%99%A8%E7%9A%84%E5%88%86%E9%85%8D%E6%A8%A1%E5%BC%8F.png&quot; alt=&quot;堆栈分配器的分配模式&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-1-2-池分配器&quot;&gt;&lt;a href=&quot;#2-1-2-池分配器&quot; class=&quot;headerlink&quot; title=&quot;2.1.2 池分配器&quot;&gt;&lt;/a&gt;2.1.2 池分配器&lt;/h3&gt;&lt;p&gt;矩阵、迭代器、链表中的节点、可渲染的网格实例等会分配大量同等尺寸的小块内存。池分配器是此类分配模式的完美选择。其工作方式为：首先预分配一大块内存，大小刚好是分配元素的倍数（例如每元素4字节的4×4矩阵池的大小设为64字节的倍数），池内每个元素会加到一个存放自由元素的链表。池分配器收到分配请求时，就会把自由链表的下一个元素取出，并传回该元素；释放元素之时，只需简单地把元素插回自由链表中。这些分配和释放都是O(1)的操作。&lt;/p&gt;
&lt;h3 id=&quot;2-1-3-含对齐功能的分配器&quot;&gt;&lt;a href=&quot;#2-1-3-含对齐功能的分配器&quot; class=&quot;headerlink&quot; title=&quot;2.1.3 含对齐功能的分配器&quot;&gt;&lt;/a&gt;2.1.3 含对齐功能的分配器&lt;/h3&gt;&lt;p&gt;为了提高内存的吞吐量和效率，所有内存分配器都必须能传回&lt;strong&gt;字节对齐&lt;/strong&gt;的内存块。只要在分配内存时，分配比请求所需多一点的内存，再向上调整地址至适当的对齐，最后传回调整后的地址。大多数情况下，额外分配的字节等于对齐字节。例如，若请求为16字节对齐的内存块，就可以额外分配多16字节，最坏的情况下要把地址往上移动15字节。多出的1字节可以用来存储偏移量，以便于正确释放分配的内存。&lt;/p&gt;
&lt;h3 id=&quot;2-1-4-单帧和双缓冲分配器&quot;&gt;&lt;a href=&quot;#2-1-4-单帧和双缓冲分配器&quot; class=&quot;headerlink&quot; title=&quot;2.1.4 单帧和双缓冲分配器&quot;&gt;&lt;/a&gt;2.1.4 单帧和双缓冲分配器&lt;/h3&gt;&lt;p&gt;几乎所有游戏都会在游戏循环中分配一些临时用数据，这些数据要么可在循环迭代结束时丢弃，要么可在下一迭代结束时丢弃。这种模式适用于以下两种分配模式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;单帧分配器：先预留一块内存，并以简单堆栈分配器管理。在每帧开始时，都把堆栈的顶端指针重置到内存块的底端地址。在该帧中，分配要求会使堆栈向上成长。优点是极其高效，分配了的内存永远不需要手动释放，因为每帧开始时分配器会自动清除所有内存。最大缺点在于，程序员必须有不错的自制能力，并意识到内存块只在目前的帧里有效，&lt;strong&gt;绝不能把指向单帧内存块的指针跨帧使用&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;双缓冲分配器：第i帧分配的内存块用于第(i+1)帧。实现方法就是建立两个相同尺寸的单帧堆栈分配器，并在每帧交替使用（见下方代码）。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;class DoubleBufferedAllocater {
    U32 m_curStack;
    StackAllocator m_stack[2];
public:
    void swapBuffers() {
        m_curStack = (U32)!m_curStack;
    }

    void clearCurrentBuffer() {
        m_stack[m_curStack].clear();
    }

    void *alloc(U32 mBytes) {
        return m_stack[m_curStack].alloc(nBytes)
    }
}

DoubleBufferedAllocator g_doubleBufAllocator;
// 主游戏循环
while (true) {
    // 每帧清除单帧分配器的缓冲区
    g_singleFrameAllocator.clear();
    // 对双缓冲分配器交换现行和无效的缓冲区
    g_doubleBufAllocator.swapBuffers();
    // 清空新的现行缓冲区，保留前帧的缓冲不变
    g_doubleBufAllocator.clearCurrentBuffer();

    // ...

    // 从双缓冲分配器分配内存，不影响前帧的数据，要确保这些内存仅在本帧或次帧中使用
    void* p = g_doubleFrameAllocator.alloc(nBytes);

    // ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;2-2-内存碎片&quot;&gt;&lt;a href=&quot;#2-2-内存碎片&quot; class=&quot;headerlink&quot; title=&quot;2.2 内存碎片&quot;&gt;&lt;/a&gt;2.2 内存碎片&lt;/h2&gt;&lt;p&gt;当经过非常多次随机次序的分配及释放不同尺寸的内存块，堆中就会出现许多内存“孔洞”，这就是内存碎片状态。由于分配的内存必须是连续的，所以内存碎片会导致分配请求经常失败。在支持虚拟内存的操作系统上，内存碎片并非大问题。对当代的游戏机而言，虽然技术上能支持虚拟内存，但由于其导致的开销，多数游戏引擎不会使用虚拟内存。&lt;/p&gt;
&lt;h3 id=&quot;2-2-1-用堆钱和池分配器避免内存碎片&quot;&gt;&lt;a href=&quot;#2-2-1-用堆钱和池分配器避免内存碎片&quot; class=&quot;headerlink&quot; title=&quot;2.2.1 用堆钱和池分配器避免内存碎片&quot;&gt;&lt;/a&gt;2.2.1 用堆钱和池分配器避免内存碎片&lt;/h3&gt;&lt;p&gt;使用堆栈分配器分配到的内存块总是连续的，可以完全避免内存碎片。池分配器虽然会产生碎片，但因为每个内存块都一样大，所以不会因缺乏足够大的连续内存块而造成分配失败&lt;/p&gt;
&lt;h3 id=&quot;2-2-2-碎片整理及重定位&quot;&gt;&lt;a href=&quot;#2-2-2-碎片整理及重定位&quot; class=&quot;headerlink&quot; title=&quot;2.2.2 碎片整理及重定位&quot;&gt;&lt;/a&gt;2.2.2 碎片整理及重定位&lt;/h3&gt;&lt;p&gt;若要以随机次序分配及释放不同大小的对象，以上两种也不适用。这时可以对堆定期进行碎片整理，即把每个“洞”搬移至高位，最后所有己分配内存块都会连续地凑在堆内存空间的底端。移动内存是简单的事，但背后的副作用是&lt;strong&gt;移动了己分配的内存块，若有指针指向这些内存块，这些指针便会失效。&lt;/strong&gt;其中一个解决方案就是把指向这些内存块的指针逐一更新，使移动内存块后这些指针能指到新的地址，这个过程称为指针重定位。&lt;/p&gt;
&lt;p&gt;由于C/C++不支持搜寻所有指向某地址范围的指针，若要在游戏引擎中支持碎片整理功能，程序员必须小心手动维护所有指针，另一个选择是采用智能指针或句柄（使用索引指向句柄表内的元素，每个元素储存指针，句柄的值不变，移动内存块时要修改指针）来替代。重定位的另一难题是，使用一些第三方库，该库本身不使用智能指针或句柄，那么指向库内数据结构的指针就不能被重定位。最好的办法是，让这些库在另一个特别缓冲区里分配内存，此缓冲区位于可重定位内存范围以外。或者干脆容许一些内存块不能被重定位，若这种内存块数量少且体积小，重定位系统仍可运行得相当好。&lt;/p&gt;
&lt;h3 id=&quot;2-2-3-分摊碎片整理整本&quot;&gt;&lt;a href=&quot;#2-2-3-分摊碎片整理整本&quot; class=&quot;headerlink&quot; title=&quot;2.2.3 分摊碎片整理整本&quot;&gt;&lt;/a&gt;2.2.3 分摊碎片整理整本&lt;/h3&gt;&lt;p&gt;碎片整理要复制内存块，其过程可能很慢。然而可以把碎片整理分摊至多个帧，例如容许容许每帧进行多达N次内存块移动（N是小数目，如8或16），只要分配及释放的次数低于碎片整理的移动次数，那么堆就会经常保持接近完全整理的状态。此方法只对细小的内存块有效，使移动内存块的时间短于每帧配给的重定位时间。若要重定位非常大的内存块，有时候可以把它分拆为两个或更多的小块，而每个小块可以独立被重定位。&lt;/p&gt;
&lt;h2 id=&quot;2-3-缓存一致性&quot;&gt;&lt;a href=&quot;#2-3-缓存一致性&quot; class=&quot;headerlink&quot; title=&quot;2.3 缓存一致性&quot;&gt;&lt;/a&gt;2.3 缓存一致性&lt;/h2&gt;&lt;p&gt;为了降低读写主内存的平均时间，现代处理器会采用高速缓存。每当出现缓存命中失败，程序便要被逼暂停，等待缓存线自主内存更新后才能继续运行。因为数据始终要在缓存和主内存之间移动，所以无法完全避免缓存命中失败。高效计算的诀窍在于，以最优的方式安排内存中的数据及为算法编码，尽量减少缓存命中失败的次数。&lt;/p&gt;
&lt;h3 id=&quot;2-3-1-硬件层面上的缓存&quot;&gt;&lt;a href=&quot;#2-3-1-硬件层面上的缓存&quot; class=&quot;headerlink&quot; title=&quot;2.3.1 硬件层面上的缓存&quot;&gt;&lt;/a&gt;2.3.1 硬件层面上的缓存&lt;/h3&gt;&lt;p&gt;现代的CPU架构上出现了一级L1和二级L2高速缓存，其存取方向为“CPU←→L1缓存←→L2缓存←→主内存”，存取速度依次减慢，L2缓存命中失败通常比L1的成本高。有一种特别差的缓存命中失败称为load-hit-store，此问题在PowerPC架构上（如Xbox360和PS3）极为普遍。其出现过程是，CPU往某内存地址写入数据，随即又读取该地址，而此时要等待L1缓存写回数据至主内存，造成CPU的流水线停顿。具体可以参见&lt;a href=&quot;http://assemblyrequired.crashworks.org/load-hit-stores-and-the-__restrict-keyword/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这篇文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;此外还需要意识到大多数处理器会在物理上独立分开指令缓存和数据缓存，前者会预载即将执行的机器码，后者则用来加速内存读写数据。因此程序变慢，要考虑是指令还是数据缓存命中失败。&lt;/p&gt;
&lt;h3 id=&quot;2-3-2-软件层面上避免缓冲命中失败&quot;&gt;&lt;a href=&quot;#2-3-2-软件层面上避免缓冲命中失败&quot; class=&quot;headerlink&quot; title=&quot;2.3.2 软件层面上避免缓冲命中失败&quot;&gt;&lt;/a&gt;2.3.2 软件层面上避免缓冲命中失败&lt;/h3&gt;&lt;p&gt;避免&lt;strong&gt;数据&lt;/strong&gt;缓存命中失败的最佳办法就是，&lt;strong&gt;把数据编排进连续的内存块中，尺寸越小越好，并且要顺序访问这些数据&lt;/strong&gt;。当数据是连续的（即不会经常在内存中“跳来跳去”），那么单次命中失败便会把尽可能最多的相关数据载入单个缓存线。&lt;/p&gt;
&lt;p&gt;要避免&lt;strong&gt;指令&lt;/strong&gt;缓存命中失败，需要了解C/C++链接器的一些简单规则，例如编译器和链接器按函数在cpp文件中的出现次序排列内存布局；单个函数的机器码几乎总是置于连续的内存；位于一个翻译单元内的函数总是置于连续内存中。据此可以使用以下经验法则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;高效能代码的体积越小越好，体积以机器码指令数目为单位&lt;/li&gt;
&lt;li&gt;在性能关键的代码段中，&lt;strong&gt;避免调用函数&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;若要调用某函数，就把该函数置于&lt;strong&gt;最接近&lt;/strong&gt;调用函数的地方，最好是紧接调用函数的前后，而不要把该函数置于另一翻译单元（cpp文件）&lt;/li&gt;
&lt;li&gt;谨慎使用内联函数。内联小型函数能增进效能，然而过多的内联会增大代码体积，使性能关键代码再不能完全装进缓存。若循环内的代码不能完全装进缓存，应重新考虑算法及其代码实现&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考文献：电子工业出版社《游戏引擎架构》第5.1、5.2节&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;每个游戏都需要一些底层支持系统，以管理一些例行却关键的任务，例如启动及终止引擎、存取文件系统、存取各种不同资产类型（网格、纹理、动画、音频等），以及为游戏团队提供调试工具。&lt;/p&gt;
&lt;p&gt;本文（分上下篇）重点讨论多数游戏引擎中都会出现的底层支持系统，为后续探索大型的核心系统做准备。其中上篇将讨论子系统的启动和终止的顺序管理，以及各种动态内存分配器和碎片整理等内存管理问题。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="游戏开发" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
      <category term="游戏引擎" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    
      <category term="游戏引擎" scheme="http://raytaylorlin.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
      <category term="架构" scheme="http://raytaylorlin.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>游戏引擎架构总览</title>
    <link href="http://raytaylorlin.com/tech/game/engine/game-engine-architecture-preview/"/>
    <id>http://raytaylorlin.com/tech/game/engine/game-engine-architecture-preview/</id>
    <published>2016-05-27T09:07:53.000Z</published>
    <updated>2016-05-27T09:20:51.758Z</updated>
    
    <content type="html">&lt;p&gt;游戏引擎通常由运行时组件和工具套件两部分构成。本文先探讨运行时部分的架构，给出了一个不包含工具的极其庞大的总览图（如果时间有限仅看此图即可），并对图中每一组件进行描述，最后再阐述工具方面的内容。如同所有软件系统，游戏引擎也是以软件层构建的，而且通常上层依赖下层，下层不依赖上层。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-运行时引擎架构&quot;&gt;&lt;a href=&quot;#1-运行时引擎架构&quot; class=&quot;headerlink&quot; title=&quot;1. 运行时引擎架构&quot;&gt;&lt;/a&gt;1. 运行时引擎架构&lt;/h1&gt;&lt;p&gt;下图为游戏运行时引擎架构的总览图，本图相对原书标上了序号，以方便下面各节阐述时对应其位置，并省略了一些细节的组成部分。&lt;strong&gt;图片较大，建议在新标签页中打开图片查看。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://raytaylorlin-blog.qiniudn.com/image%2Fengine%2F%E6%B8%B8%E6%88%8F%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84.png&quot; alt=&quot;游戏运行时引擎架构&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-1-硬件与操作系统&quot;&gt;&lt;a href=&quot;#1-1-硬件与操作系统&quot; class=&quot;headerlink&quot; title=&quot;1.1 硬件与操作系统&quot;&gt;&lt;/a&gt;1.1 硬件与操作系统&lt;/h2&gt;&lt;p&gt;图中的A1为目标硬件层，代表用来执行游戏的计算机系统或游戏主机。典型平台包括基于微软Windows或Linux的PC、苹果的iPhone及Machintosh、微软的Xbox360、索尼的PS4/PSP、任天堂的NDS/Wii等等。&lt;/p&gt;
&lt;p&gt;图中的A2是设备驱动程序，是由操作系统或硬件厂商提供的最低阶软件组件。驱动程序负责管理硬件资源，也隔离了操作系统及上层引擎，使上层的软件无须理解不同硬件版本的通信细节差异。&lt;/p&gt;
&lt;p&gt;图中的A3是操作系统。在PC上操作系统是一直运行的，PC游戏不能假设拥有硬件的所有控制权；而在游戏主机上，操作系统通常只是个轻量级的库，链接到游戏的执行档里。不过像Xbox 360和PS3这些新主机中，操作系统也会中断游戏的执行，接管某些系统资源以显示在线信息。&lt;/p&gt;
&lt;h2 id=&quot;1-2-第三方软件开发包和中间件&quot;&gt;&lt;a href=&quot;#1-2-第三方软件开发包和中间件&quot; class=&quot;headerlink&quot; title=&quot;1.2 第三方软件开发包和中间件&quot;&gt;&lt;/a&gt;1.2 第三方软件开发包和中间件&lt;/h2&gt;&lt;p&gt;图中的B表明大多数游戏引擎会借用第三方SDK及中间件（middleware），SDK提供基于函数或基于类的API。下面是一些常见的例子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据结构及算法：如STL、STLport、Boost、Loki。因为PC上有虚拟内存系统，所以可以无碍使用STL，而游戏主机上，只有有限的（甚至没有）虚拟内存功能，而且缓存命中失败的代价极高，所以最好编写自定义的数据结构&lt;/li&gt;
&lt;li&gt;图形：如DirextX、OpenGL、libgcm、Edge等&lt;/li&gt;
&lt;li&gt;碰撞和物理：如Havok、PhysX、ODE（Open Dynamics Engine）等&lt;/li&gt;
&lt;li&gt;角色动画：如Granny、Havok Animation、Edge等&lt;/li&gt;
&lt;li&gt;人工智能：如Kynapse，提供低阶的AI构件，例如路径搜寻、静态和动态物体回避、空间内的脆弱点辨认，以及相当好的AI和动画间接口&lt;/li&gt;
&lt;li&gt;生物力学角色模型：如Endorphin、Euphoria等，利用了真实人类运动的高阶生物力学模型，去产生角色动作&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-3-平台独立层&quot;&gt;&lt;a href=&quot;#1-3-平台独立层&quot; class=&quot;headerlink&quot; title=&quot;1.3 平台独立层&quot;&gt;&lt;/a&gt;1.3 平台独立层&lt;/h2&gt;&lt;p&gt;图中的C为平台独立层。大部分游戏引擎需要运行于不同的平台上，该层包装了常用的标准C语言库、操作系统调用及其他基础API，确保包装了的接口在所有硬件平台上均为一致。&lt;/p&gt;
&lt;h2 id=&quot;1-4-核心系统&quot;&gt;&lt;a href=&quot;#1-4-核心系统&quot; class=&quot;headerlink&quot; title=&quot;1.4 核心系统&quot;&gt;&lt;/a&gt;1.4 核心系统&lt;/h2&gt;&lt;p&gt;游戏引擎以及其他大规模复杂C++应用软件，都需要一些有用的实用软件（utility)，统称为“核心系统”，即图中的D。以下是一些核心系统层的常见功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内存管理：几乎每个游戏引擎都有若干个自定义内存分配系统，以保证高速的内存分配及释放，并控制内存碎片所造成的负面影响&lt;/li&gt;
&lt;li&gt;数学库：游戏本质上就是高度数学密集的，所以每个游戏引擎都有若干个数学库，提供矢量、矩阵、四元数旋转、三角学、数值积分、解方程组，以及其他游戏程序员需要的功能&lt;/li&gt;
&lt;li&gt;自定义数据结构及算法：除非引擎设计者想完全依靠第三方软件包，否则引擎通常要提供一组工具去管理基础数据结构和算法，以减少或完全消去动态内存分配，并保证在目标平台上的运行效率为最优&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-5-资源管理&quot;&gt;&lt;a href=&quot;#1-5-资源管理&quot; class=&quot;headerlink&quot; title=&quot;1.5 资源管理&quot;&gt;&lt;/a&gt;1.5 资源管理&lt;/h2&gt;&lt;p&gt;图中的E为资源管理器，提供一组统一的接口去访问任何类型的游戏资产及其他引擎输入数据。有些引擎使用高度集中及一致的方式（例如虚幻的包package、OGRE的ResourceManager类）。其他引擎使用专案（ad hoc）方法，比如让程序员直接读取磁盘的或压缩的文件（如雷神之锤引擎使用的PAK文件）。&lt;/p&gt;
&lt;h2 id=&quot;1-6-渲染引擎&quot;&gt;&lt;a href=&quot;#1-6-渲染引擎&quot; class=&quot;headerlink&quot; title=&quot;1.6 渲染引擎&quot;&gt;&lt;/a&gt;1.6 渲染引擎&lt;/h2&gt;&lt;p&gt;任何游戏引擎中，渲染引擎是最大及最复杂的组件之一。渲染器有很多不同的架构方式，通常采用分层架构。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;低阶渲染器（图中F1）：包含引擎中全部原始的渲染功能，着重于高速渲染丰富的几何图元集合&lt;ul&gt;
&lt;li&gt;图形设备接口：使用图形SDK（如DirectX及OpenGL），都需要编写不少代码去枚举图形设备，初始化设备，建立渲染表面等，这些工作通常由图形设备接口组件负责&lt;/li&gt;
&lt;li&gt;其他渲染器组件：目的是要收集须提交的几何图元，包括网格、线表、点表、例子、地形块、字符串等等。低阶渲染器还提供视区（viewport）抽象、材质系统及动态光照系统&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;场景图/剔除优化（图中F2）：该层基于某些可视性判别算法去限制低阶渲染器提交的图元数量。非常小的游戏世界可能只需要简单的平截头体剔除算法，比较大的游戏世界则可能需要较高阶的空间细分数据结构，令渲染更有效率&lt;/li&gt;
&lt;li&gt;视觉效果（图中F3）：支持广泛的视觉效果，例如粒子系统（烟、火、水花等）、贴花系统（弹孔、脚印等），还有一些全屏幕后期处理，例如高动态范围光照（HDR）、敷霜效果、全屏抗锯齿（FSAA）、颜色校正等等&lt;/li&gt;
&lt;li&gt;前端（图中F4）：该层主要用于显示2D图形，如平视显示器（HUD）、GUI界面等等，通常会用附有纹理的四边形结合正射投影来渲染，或者用完全三维的四边形公告板（billboard）渲染&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-7-剖析与调试工具&quot;&gt;&lt;a href=&quot;#1-7-剖析与调试工具&quot; class=&quot;headerlink&quot; title=&quot;1.7 剖析与调试工具&quot;&gt;&lt;/a&gt;1.7 剖析与调试工具&lt;/h2&gt;&lt;p&gt;图中的G用于剖析调优性能，分析内存。还包含了游戏内置调试功能，包括调试用绘图、内置菜单、主控台、录制回放游戏过程等。市场上有很多优良的通用软件剖析工具，如VTune、Quantify、Purify等等，但是多数游戏也会加入自制的剖析与调试工具以应对特殊需求。&lt;/p&gt;
&lt;h2 id=&quot;1-8-碰撞和物理&quot;&gt;&lt;a href=&quot;#1-8-碰撞和物理&quot; class=&quot;headerlink&quot; title=&quot;1.8 碰撞和物理&quot;&gt;&lt;/a&gt;1.8 碰撞和物理&lt;/h2&gt;&lt;p&gt;图中的H为碰撞与物理组件。游戏中如果没有碰撞检测，物体会互相穿透，并且无法在虚拟世界里合理地互动。碰撞和物理系统一般是紧密联系的，因为当碰撞发生时，碰撞几乎总是由物理积分及约束满足逻辑来解决。一些游戏还包含真实或半真实的刚体动力学模拟。时至今日，游戏引擎通常使用第三方的物理SDK，如Havok、PhysX和ODE。&lt;/p&gt;
&lt;h2 id=&quot;1-9-动画&quot;&gt;&lt;a href=&quot;#1-9-动画&quot; class=&quot;headerlink&quot; title=&quot;1.9 动画&quot;&gt;&lt;/a&gt;1.9 动画&lt;/h2&gt;&lt;p&gt;图中的I为动画系统，游戏常会用到精灵/纹理动画、刚体层次结构动画、骨骼动画、每顶点动画、变形目标动画5种基本动画。现今游戏&lt;br&gt;中，骨骼动画是最盛行的动画方式。此外，骨骼网格渲染组件是连接渲染器和动画系统的桥梁，这些组件合作渲染的过程称为蒙皮（skinning）。&lt;/p&gt;
&lt;p&gt;当使用布娃娃系统时，动画和物理系统便产生紧密耦合，这是因为布娃娃是无力的（经常是死了的）角色，其运动完全由物理系统模拟。物理系统把布娃娃当作受约束的刚体系统，用模拟来决定身体每部分的位置及方向。&lt;/p&gt;
&lt;h2 id=&quot;1-10-人体学接口设备&quot;&gt;&lt;a href=&quot;#1-10-人体学接口设备&quot; class=&quot;headerlink&quot; title=&quot;1.10 人体学接口设备&quot;&gt;&lt;/a&gt;1.10 人体学接口设备&lt;/h2&gt;&lt;p&gt;图中的J用于处理玩家输入，包括键盘鼠标、游戏手柄及其他专用游戏控制器（如方向盘、跳舞毯、Wii遥控器等）。除了输入功能，一些设备也提供输出，如游戏手柄的震动、Wii遥控器的音频输出等。&lt;/p&gt;
&lt;p&gt;在架构HID引擎时，通常让硬件的低阶细节与高阶游戏操作脱钩。HID引擎从硬件取得原始数据，为控制器的每个摇杆设置环绕中心点的死&lt;br&gt;区，去除按钮抖动，检测按下和释放按钮事件，演绎加速计的输入并使该输入平滑。HID引擎也可能包含一个系统，负责检测弦（chord）（即数个按钮一起按下）、序列（即接钮在时限内顺序按下）、手势（即按钮、摇杆、加速计等输入的序列）。&lt;/p&gt;
&lt;h2 id=&quot;1-11-音频&quot;&gt;&lt;a href=&quot;#1-11-音频&quot; class=&quot;headerlink&quot; title=&quot;1.11 音频&quot;&gt;&lt;/a&gt;1.11 音频&lt;/h2&gt;&lt;p&gt;图中的K为音频引擎。一些游戏团队会为这些引擎加入自定义功能，或用内部方案替换，例如微软为DirectX平台提供一个名为XACT的优秀的音频工具包，艺电也开发了内部的音频引擎SoundR!OT。然而，即使游戏团队用既有的音频引擎，开发每个游戏时仍然需要大量的定制软件开发、整合工作及注意细节，才可以制作出有高质量音频的最终产品。&lt;/p&gt;
&lt;h2 id=&quot;1-12-在线多人-网络&quot;&gt;&lt;a href=&quot;#1-12-在线多人-网络&quot; class=&quot;headerlink&quot; title=&quot;1.12 在线多人/网络&quot;&gt;&lt;/a&gt;1.12 在线多人/网络&lt;/h2&gt;&lt;p&gt;图中的L为在线多人/网络组件。多人游戏有单屏多人、切割平多人、网络多人、大型多人在线等多种基本形式。支持多人游戏，会深切影响到游戏世界对象模型、人体学接口设备系统、玩家控制系统、动画系统等多个组件的设计。把一个现有的担任引擎改装成多人引擎的难度是非常大的，但如果反过来则比较简单——许多游戏引擎把单人游戏模式当做是一个玩家参与的多人游戏。&lt;/p&gt;
&lt;h2 id=&quot;1-13-游戏性基础系统&quot;&gt;&lt;a href=&quot;#1-13-游戏性基础系统&quot; class=&quot;headerlink&quot; title=&quot;1.13 游戏性基础系统&quot;&gt;&lt;/a&gt;1.13 游戏性基础系统&lt;/h2&gt;&lt;p&gt;游戏性（gameplay）是指：游戏内进行的活动、支配游戏虚拟世界的规则、玩家角色的能力（也称为玩家机制）、其他角色和对象的能力、玩家的长短期目标。游戏性编程除了用引擎的原生语言，通常还会使用高阶的脚本语言，为了连接低阶的引擎子系统和游戏性代码，多数游戏引擎会引入一个软件层，即图中的M。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;游戏世界和游戏对象模型：游戏世界含动态与静态的元素，而典型的游戏对象有静态背景几何物体（如建筑、地形）、动态刚体（如石头、椅子）、玩家角色、NPC、武器、抛射物、载具、光源、摄像机&lt;/li&gt;
&lt;li&gt;事件系统：事件驱动架构常用于游戏对象间的通信&lt;/li&gt;
&lt;li&gt;脚本系统：使用脚本语言来编写游戏独有的游戏性规则和内容，可以快速开发，避免重新编译链接&lt;/li&gt;
&lt;li&gt;人工智能基础：像Kynapse这种商用AI引擎，抽象了大多数AI系统共有的模式，在这个基础层上可以很容易地开发个别游戏的逻辑。其功能包括用路径节点和漫游体积组成网络定义AI角色可行走的地区和路径，在漫游地区边界周围的简化碰撞信息，A*路径搜寻，联系碰撞系统及世界模型进行视线追踪及其他感知，AI决策层架构等等&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-14-个别游戏专用子系统&quot;&gt;&lt;a href=&quot;#1-14-个别游戏专用子系统&quot; class=&quot;headerlink&quot; title=&quot;1.14 个别游戏专用子系统&quot;&gt;&lt;/a&gt;1.14 个别游戏专用子系统&lt;/h2&gt;&lt;p&gt;如图中的N，每个游戏都有若干自身特有的游戏性系统。如果可以清楚地分开引擎和游戏，这条分界线会位于特定游戏专用子系统和游戏性基础软件层之间。实际上，这条分界线永远不会是完美的。一些游戏的特定知识，总是会向下渗透到游戏基础软件层中，更有甚者会延伸至引擎核心。&lt;/p&gt;
&lt;h1 id=&quot;2-工具套件&quot;&gt;&lt;a href=&quot;#2-工具套件&quot; class=&quot;headerlink&quot; title=&quot;2. 工具套件&quot;&gt;&lt;/a&gt;2. 工具套件&lt;/h1&gt;&lt;h2 id=&quot;2-1-数字内容创作工具&quot;&gt;&lt;a href=&quot;#2-1-数字内容创作工具&quot; class=&quot;headerlink&quot; title=&quot;2.1 数字内容创作工具&quot;&gt;&lt;/a&gt;2.1 数字内容创作工具&lt;/h2&gt;&lt;p&gt;游戏本质上是多媒体应用。游戏引擎的输入数据形式广泛，例如三维网格数据、纹理位图、动画数据、音频文件等。所有源数据皆由美术或音效师等专业人员使用数字内容创作（Digital Content Creation，DCC）应用软件制作，如Maya、3ds Max、Photoshop、SoundForge等等。有些游戏引擎提供专门的设计游戏世界的编辑器，而有的团队会在现有软件像3ds Max的基础上开发插件去设计场景，甚至用简单的位图编辑器去制作地形高度图。总之，游戏团队想要及时开发高完成度的产品，工具必须&lt;strong&gt;相对易用&lt;/strong&gt;，并且&lt;strong&gt;绝对可靠&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;2-2-资产（asset）调节管道&quot;&gt;&lt;a href=&quot;#2-2-资产（asset）调节管道&quot; class=&quot;headerlink&quot; title=&quot;2.2 资产（asset）调节管道&quot;&gt;&lt;/a&gt;2.2 资产（asset）调节管道&lt;/h2&gt;&lt;p&gt;DCC所生成的数据格式，很少有直接用于游戏中的，原因有两点：生成的数据格式通常比游戏所需的复杂得多，游戏引擎只需其中一小部分信息；直接读取速度过慢，而且有些格式是不公开的专有格式。因此，DCC软件制作的数据，通常要导出为容易读取的标准格式或自定义格式，有时还需要针对不同平台进行再处理，以便在游戏中使用。从DCC到游戏引擎的管道，就是所谓的资产调节管道。&lt;/p&gt;
&lt;h2 id=&quot;2-3-常见的游戏资产数据&quot;&gt;&lt;a href=&quot;#2-3-常见的游戏资产数据&quot; class=&quot;headerlink&quot; title=&quot;2.3 常见的游戏资产数据&quot;&gt;&lt;/a&gt;2.3 常见的游戏资产数据&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;几何图形数据&lt;ul&gt;
&lt;li&gt;笔刷集合图形：由凸包集合定义，每个凸包则由多个平面定义。其优点是制作迅速简单，便于设计师建立粗略的原型，也可用作碰撞体积；缺点是分辨率低难以制作复杂图形，不能支持有关节的物体或运动角色&lt;/li&gt;
&lt;li&gt;三维模型/网格：由三角形和顶点组成，每个网格使用若干个材质。网格通常在三维建模软件里制作，并且需要专用的导出器来导出游戏引擎可读的格式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;骨骼动画数据：骨骼网格是一种为关节动画而绑定到骨骼层次结构之上的特殊网格，游戏引擎需要网格本身、骨骼层次结构和若干动画片段3种数据来渲染骨骼网络&lt;/li&gt;
&lt;li&gt;音频数据：由专业的音频制作工具导出，有不同格式和采样率。音频文件通常组织成音频库，以方便管理，载入及串流。&lt;/li&gt;
&lt;li&gt;粒子系统数据：由视觉特效设计师使用第三方工具（如Houdini）或引擎自带的粒子效果编辑工具制作&lt;/li&gt;
&lt;li&gt;游戏世界数据：不少商用游戏引擎会提供优良的世界编辑器，用于编辑游戏世界&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考文献：电子工业出版社《游戏引擎架构》第1.6、1.7节&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;游戏引擎通常由运行时组件和工具套件两部分构成。本文先探讨运行时部分的架构，给出了一个不包含工具的极其庞大的总览图（如果时间有限仅看此图即可），并对图中每一组件进行描述，最后再阐述工具方面的内容。如同所有软件系统，游戏引擎也是以软件层构建的，而且通常上层依赖下层，下层不依赖上层。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="游戏开发" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
      <category term="游戏引擎" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    
      <category term="游戏引擎" scheme="http://raytaylorlin.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
      <category term="架构" scheme="http://raytaylorlin.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>软件构建（十五）——尾声</title>
    <link href="http://raytaylorlin.com/tech/complex/software/software-construction-15/"/>
    <id>http://raytaylorlin.com/tech/complex/software/software-construction-15/</id>
    <published>2016-05-14T14:21:15.000Z</published>
    <updated>2016-05-19T02:30:35.465Z</updated>
    
    <content type="html">&lt;p&gt;本文是《代码大全》学习笔记系列的最后一篇。书中最后几章是一些杂项主题，本文将简要记录这几个主题的内容，包括个人性格对编程的影响，软件开发艺术的有关问题，以及关于软件工程的推荐书单。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-个人性格&quot;&gt;&lt;a href=&quot;#1-个人性格&quot; class=&quot;headerlink&quot; title=&quot;1. 个人性格&quot;&gt;&lt;/a&gt;1. 个人性格&lt;/h1&gt;&lt;p&gt;编程过程非常耗用脑力，这种特性使得个人性格显得很重要。而编程工作本质上是项无法监督的工作，因为没人真正清楚你正在做什么。老板也无法强迫你成为好的程序员，很多时候他甚至无法判断你是否合格，一切都只能靠自己。你无法提升自己的聪明程度，但性格在一定程度上能够改进。事实证明，个人性格对于造就出程序员高手更具有决定性意义。&lt;/p&gt;
&lt;h2 id=&quot;1-1-个人性格对编程的影响&quot;&gt;&lt;a href=&quot;#1-1-个人性格对编程的影响&quot; class=&quot;headerlink&quot; title=&quot;1.1 个人性格对编程的影响&quot;&gt;&lt;/a&gt;1.1 个人性格对编程的影响&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;聪明和谦虚：高智商与优秀程序员之间并无太密切的联系。实际上许多好的编程做法都是为了减轻脑力负担，例如将系统分解是为了使之易于理解，进行审查、评审和测试是为了减少人为失误，通过各种各样的规范是为了将思路从相对繁琐的编程事务中解放出来。精通编程的人是那些了解自己头脑有多大局限性的人，都很谦虚。&lt;/li&gt;
&lt;li&gt;求知欲：技术环境的特定特征每5到10年就变化一番，如果没有足够的求知欲来跟上这些变化，就会面临落伍的威胁，下面是一些培养求知欲的方法&lt;ul&gt;
&lt;li&gt;在开发过程中建立自我意识&lt;/li&gt;
&lt;li&gt;不断用小程序来试验技术点&lt;/li&gt;
&lt;li&gt;阅读解决问题的有关方法&lt;/li&gt;
&lt;li&gt;在行动之前做分析和计划&lt;/li&gt;
&lt;li&gt;学习成功项目的开发经验，阅读高手的代码&lt;/li&gt;
&lt;li&gt;认真阅读文档和其他书本期刊&lt;/li&gt;
&lt;li&gt;同专业人士交往&lt;/li&gt;
&lt;li&gt;向专业开发看齐：专业开发可分为这样四个等级：入门级（会使用某语言的基本功能和特性），中级（已度过入门期，能使用多种 语言，并得心应手使用至少一种语言），熟练级（对语言或环境有着专业技能，通常是公司的核心开发，很多程序员不能超越该层次），技术带头人级（具有熟练级的专业技能，也明白写代码是给人看而非给机器看）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;诚实：通常表现为：不是高手时不假装是高手；乐于承认错误；力图理解编译器的警告，而非弃之不理；透彻理解自己的程序，而不要只是编译看看能否运行；提供实际的状况报告；提供现实的进度方案，在上司面前坚持自己的意见&lt;/li&gt;
&lt;li&gt;交流与合作：真正优秀的程序员知道怎样同别人融洽地工作和娱乐，并且会把提高代码可读性和修改你代码的人放在心上&lt;/li&gt;
&lt;li&gt;创造力和纪律：不要把各种标准和规范的纪律看成是对创造力的约束，相反，许多有很强创造力的人都极其遵守纪律和规范&lt;/li&gt;
&lt;li&gt;偷懒：通常表现为拖延不喜欢的任务（没有任何益处），迅速做完不喜欢的任务以摆脱之（尽管是偷懒，但毕竟用最少时间完成了任务），&lt;strong&gt;编写某个工具来完成不喜欢的任务以便再也不用做这样的事情&lt;/strong&gt;（一劳永逸的懒，无疑是最具产值的偷懒形式）&lt;/li&gt;
&lt;li&gt;习惯：优秀的程序员早就养成了编程各方面的良好习惯，而不是最近才培养的。初涉某事时，就应端正态度来学，干了一段时间后，“习惯的力量”就开始起作用。如果没养成最有效的习惯，或者想改掉坏习惯，应该用良好的新习惯去取代，而不是强行杜绝掉坏习惯&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-2-不如你想象中那样起作用的性格因素&quot;&gt;&lt;a href=&quot;#1-2-不如你想象中那样起作用的性格因素&quot; class=&quot;headerlink&quot; title=&quot;1.2 不如你想象中那样起作用的性格因素&quot;&gt;&lt;/a&gt;1.2 不如你想象中那样起作用的性格因素&lt;/h2&gt;&lt;p&gt;注意以下列举的性格都是&lt;strong&gt;反面因素&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;坚持：多数时候软件开发中的坚持其实就是没有好处的“固执”，当在某段新代码上卡壳时，不妨另辟蹊径，尝试重新设计类，或者绕过去，以后回头再试。花好几个小时干掉某一错误确实会有满足感，但实际上早点放弃固有的思路，换个角度可能可以节省更多时间。&lt;/li&gt;
&lt;li&gt;经验：由于软件技术更新换代太快，所谓的“经验”很快就会落伍，程序员要持续学些，保持与时俱进。&lt;/li&gt;
&lt;li&gt;编程狂人：彻夜编程让你感觉像是世上最好的程序员，却要花几个星期去纠正你在短暂辉煌时埋下的失误。可以热爱编程，但热情不能代替熟练的能力，请想明白什么更重要。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;2-软件开发艺术的有关问题&quot;&gt;&lt;a href=&quot;#2-软件开发艺术的有关问题&quot; class=&quot;headerlink&quot; title=&quot;2. 软件开发艺术的有关问题&quot;&gt;&lt;/a&gt;2. 软件开发艺术的有关问题&lt;/h1&gt;&lt;p&gt;这一章相当于对全书介绍的各种细节背后所折射出的哲学思想做出一个总结。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;克服复杂性：《代码大全》绝大部分的篇幅都用于阐述如何划分系统模块，抽象类和接口，遵循什么样的编程规范等等，归根结底是为了降低软件的复杂性。&lt;/li&gt;
&lt;li&gt;精选开发过程：对于小的项目，程序员的个人才能对软件质量影响最大，对于多人项目，组织性的重要程度超过了个人技能。关于开发过程的重要性，一个明显的例子是看看在需求还未确定就开始设计和编码的后果。其他有用的开发过程，如增量开发，先设计后编码，先粗调后优化，伪代码编码并不断添加注释等等，均在之前的文章提到过，不再赘述。&lt;/li&gt;
&lt;li&gt;首先为人写程序，其次才是为机器：可读的代码写起来并不比含糊的代码多花时间，得到的好处是巨大的。自己维护，后期重构，复审代码，别人修改程序，统统都要读到代码，因此一次性编写可读性强的代码，是非常经济划算的。即便是自写自用的私有代码，也应该认真对待，因为这是一种优秀的习惯（习惯在上述个人性格中提到过）。&lt;/li&gt;
&lt;li&gt;深入一门语言去编程，不浮于表面：要先考虑要干什么，然后采用手头的工具去实现目标。如果你所用的语言不支持某种你想要的特性，可以尝试用一些变通的方法以最大限度地遵循编程规范，因为规范能帮助你理清环境中的危险特性。&lt;/li&gt;
&lt;li&gt;借助规范集中注意力：规范能够节省程序员回答同样问题的麻烦，能精确地传达重要信息，免除各种编码的危险做法，还能弥补语言的某些不足之处&lt;/li&gt;
&lt;li&gt;基于问题域编程：顶层的代码要说明想解决的问题，而不要充斥各种与文件、数据结构、数据类型有关的操作细节。设计程序时，应考虑下图这样的抽象层次&lt;ul&gt;
&lt;li&gt;&lt;img src=&quot;http://raytaylorlin-blog.qiniudn.com/image%2Fsoftware%2F%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%8A%BD%E8%B1%A1%E5%B1%82%E6%AC%A1.png&quot; alt=&quot;程序的抽象层次&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;留心警告信号：当你或其他人说“这段代码暗藏玄机”时，或者类中含有比平均数目更多的错误，或者发现子程序中有许多判断点、嵌套，或者发现代码有重复，或者发现代码不容易写注释和命名变量，或者编译时出现警告等等，这些都是警告信号。任何警告信号都应让你质疑程序的质量，并促使你去寻求更满意的解决之道。&lt;/li&gt;
&lt;li&gt;一次又一次迭代：需求、设计、开发、测试，软件开发从头到尾每一步都充斥着迭代并逐步精化的过程。所以不要追求所谓的“一步登天”。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不要&lt;/strong&gt;存在软件信仰（即坚持某种做法）&lt;ul&gt;
&lt;li&gt;折中主义：要对编程问题找出最有效的解决方案时，盲目迷信某种方法只会缩小你的选择余地。折中主义是一种有益的态度，对于每个特定问题，应该将多种方法视为工具箱中的工具。多数时候工具的选择关系不大，但有些场合需要自己判断权衡，挑选最好的工具&lt;/li&gt;
&lt;li&gt;试验：要想有效地试验，应能基于试验结果改变思路。许多顽固的方法源于对错误的畏惧心理，“试图没有错误”是最大的错误。软件开发的各方面，你都应保待开放的心态&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;3-书单&quot;&gt;&lt;a href=&quot;#3-书单&quot; class=&quot;headerlink&quot; title=&quot;3. 书单&quot;&gt;&lt;/a&gt;3. 书单&lt;/h1&gt;&lt;p&gt;书中最后一章作者给出了一些建议阅读的经典著作，下面挑选了一部分有中译版本的书（有一些书再版了多次，链接给出的都是最新的版本）组成一个参考书单，供以后学习。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;软件构建类&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://book.douban.com/subject/5387402/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《程序员修炼之道》&lt;/a&gt;（《The Pragmatic Programmer》，Andrew Hunt / David Thomas）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://book.douban.com/subject/3227098/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《编程珠玑》&lt;/a&gt;（《Programming Pearls》，Jon Bentley）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://book.douban.com/subject/6524000/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《程序设计实践&lt;strong&gt;（评注版）&lt;/strong&gt;》&lt;/a&gt;（《The Practice of Programming》，Brian W. Kernighan / Rob Pike），注意这本书市面上没有很好的中译本，只有最新的这本评注版&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;软件工程综述类&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://book.douban.com/subject/26419766/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《软件开发心理学》&lt;/a&gt;（《The Psychology of Computer Programming》，Gerald M. Weinberg）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://book.douban.com/subject/2230248/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《人月神话》&lt;/a&gt;（《The Mythical Man-Month》，Frederick P.Brooks）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://book.douban.com/subject/6047742/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《软件工程：实践者的研究方法》&lt;/a&gt;（《The Mythical Man-Month》，Roger S.Pressman）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考文献：电子工业出版社《代码大全（第2版）》第33、34、35章&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;本文是《代码大全》学习笔记系列的最后一篇。书中最后几章是一些杂项主题，本文将简要记录这几个主题的内容，包括个人性格对编程的影响，软件开发艺术的有关问题，以及关于软件工程的推荐书单。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="综合" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/"/>
    
      <category term="软件工程" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="软件构建" scheme="http://raytaylorlin.com/tags/%E8%BD%AF%E4%BB%B6%E6%9E%84%E5%BB%BA/"/>
    
      <category term="软件工程" scheme="http://raytaylorlin.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="代码大全" scheme="http://raytaylorlin.com/tags/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>软件构建（十四）——代码布局与自说明代码</title>
    <link href="http://raytaylorlin.com/tech/complex/software/software-construction-14/"/>
    <id>http://raytaylorlin.com/tech/complex/software/software-construction-14/</id>
    <published>2016-05-12T13:17:18.000Z</published>
    <updated>2016-05-12T13:16:22.704Z</updated>
    
    <content type="html">&lt;p&gt;本文关注的是计算机编程的美学话题——程序源代码的布局和自说明性。尽管这些技巧并不影响执行速度、内存使用量等方面的程序性能，但它却会让你日后理解、检查以及修改代码变得更容易，也使其他人在你缺位的时候更容易阅读、理解和修改你的代码。&lt;/p&gt;
&lt;p&gt;需要注意的是，形成良好的代码布局，并让代码具备自说明性，需要始终贯穿项目的生命期，晚了就很难做好了。要想完全实现这些细节规定，在最初建构时就要着手去做。如果你干的是合作项目，更是要在开始编码之前统一大家的风格。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-代码布局&quot;&gt;&lt;a href=&quot;#1-代码布局&quot; class=&quot;headerlink&quot; title=&quot;1. 代码布局&quot;&gt;&lt;/a&gt;1. 代码布局&lt;/h1&gt;&lt;h2 id=&quot;1-1-良好布局的目标&quot;&gt;&lt;a href=&quot;#1-1-良好布局的目标&quot; class=&quot;headerlink&quot; title=&quot;1.1 良好布局的目标&quot;&gt;&lt;/a&gt;1.1 良好布局的目标&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;准确表现代码的逻辑结构：例如利用缩进、空行等空白来表达逻辑关系&lt;/li&gt;
&lt;li&gt;始终如一地表现代码的逻辑结构&lt;/li&gt;
&lt;li&gt;改善可读性：如果有一种缩进策略合乎逻辑，但却令程序更难看懂，那么它就毫无用处&lt;/li&gt;
&lt;li&gt;经得起修改：好的布局应该在修改某行时不必连带修改其他行的代码&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-2-常用布局技术与风格&quot;&gt;&lt;a href=&quot;#1-2-常用布局技术与风格&quot; class=&quot;headerlink&quot; title=&quot;1.2 常用布局技术与风格&quot;&gt;&lt;/a&gt;1.2 常用布局技术与风格&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;空白：包括空格、制表符、换行、空行等等。程序中的空白就像书籍中划分章节、段落、句子一样向读者展示组织主题的思路&lt;ul&gt;
&lt;li&gt;分组：确保相关的语句成组放在一起，用空行分隔，就像文章中的一段话一样&lt;/li&gt;
&lt;li&gt;空行：将不相关的语句分隔开，就像文章中段与段的分隔一样&lt;/li&gt;
&lt;li&gt;缩进：显示程序的逻辑结构&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;括号：对包含两个以上的项的表达式，应该用括号去澄清&lt;/li&gt;
&lt;li&gt;控制结构布局&lt;ul&gt;
&lt;li&gt;别让begin和end对两次缩进&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;单条语句&lt;/strong&gt;的代码块的格式要前后统一&lt;/li&gt;
&lt;li&gt;对于复杂的表达式，将条件分隔放在几行上&lt;/li&gt;
&lt;li&gt;case语句不要有行尾布局的例外&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;单条语句布局&lt;ul&gt;
&lt;li&gt;各种标点符号两侧使用空格会让逻辑表达式更易读&lt;/li&gt;
&lt;li&gt;使用空格让数组引用，子程序参数更易读&lt;/li&gt;
&lt;li&gt;单条语句过长时，应分行，并让续行显得更明显，通常在行尾以&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;、&lt;code&gt;||&lt;/code&gt;、&lt;code&gt;+-*/&lt;/code&gt;等符号为结尾&lt;/li&gt;
&lt;li&gt;续行要以标准的空格数缩进&lt;/li&gt;
&lt;li&gt;不要将赋值语句按等号对齐&lt;/li&gt;
&lt;li&gt;每行仅写一条语句（C++中不要让一行里有多个副作用操作（如&lt;code&gt;++a&lt;/code&gt;））&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据声明布局&lt;ul&gt;
&lt;li&gt;每行只声明一个变量&lt;/li&gt;
&lt;li&gt;合理组织声明顺序：建议按类型分类&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;注释布局&lt;ul&gt;
&lt;li&gt;注释的缩进要与相应代码一致&lt;/li&gt;
&lt;li&gt;每行注释用至少一个空行分开&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;子程序布局&lt;ul&gt;
&lt;li&gt;用空行分隔子程序的各部分&lt;/li&gt;
&lt;li&gt;将子程序参数按标准缩进，如果参数过多，可以考虑一行放一个参数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;类布局&lt;ul&gt;
&lt;li&gt;类的内容按以下顺序排布：说明类及其完整用法的头部注释、类数据、构造函数与析构函数、public子程序、protected子程序、private子程序&lt;/li&gt;
&lt;li&gt;一个文件应只有一个类，文件的命名应与类名有关&lt;/li&gt;
&lt;li&gt;在文件中清晰地分隔各子程序&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关于块结构和花括号指定的块边界，不同语言有不一样的规范。书中所提规范放在某些语言也不适用，实际使用应遵循相应的规范，此处不赘述书中所提的布局与风格。&lt;/p&gt;
&lt;h1 id=&quot;2-自说明代码&quot;&gt;&lt;a href=&quot;#2-自说明代码&quot; class=&quot;headerlink&quot; title=&quot;2. 自说明代码&quot;&gt;&lt;/a&gt;2. 自说明代码&lt;/h1&gt;&lt;h2 id=&quot;2-1-编程风格的重要性&quot;&gt;&lt;a href=&quot;#2-1-编程风格的重要性&quot; class=&quot;headerlink&quot; title=&quot;2.1 编程风格的重要性&quot;&gt;&lt;/a&gt;2.1 编程风格的重要性&lt;/h2&gt;&lt;p&gt;自说明代码代表了易读性的最高水平，而且一般是&lt;strong&gt;由良好的编码风格决定&lt;/strong&gt;，很大程度&lt;strong&gt;与注释无关&lt;/strong&gt;。对于精心编写的代码而言， 注释不过是美丽衣裳上的小饰物而已。关于自说明代码所体现出的编码风格，请参见&lt;a href=&quot;http://www.kancloud.cn/raytaylorlin/code-complete-checklist/150866&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;核对表：自说明代码&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;2-2-高效注释&quot;&gt;&lt;a href=&quot;#2-2-高效注释&quot; class=&quot;headerlink&quot; title=&quot;2.2 高效注释&quot;&gt;&lt;/a&gt;2.2 高效注释&lt;/h2&gt;&lt;p&gt;注释的作用分为六种：重复代码（用文字把代码的工作又描述一次，&lt;strong&gt;这种注释是废话，应杜绝&lt;/strong&gt;）、解释代码（通常是因为代码含糊不清，此时应&lt;strong&gt;改进代码&lt;/strong&gt;而不是添加注释）、代码标记（提示工作未做完，待修复等等）、概述代码（用一两句话把若干行代码的意思说出来）、代码意图说明（指出一段代码要解决的问题，而非解决问题的方法）、传达代码无法表述的信息（如版权声明、保密要求、doc注释符号等等）。&lt;strong&gt;对于完工的代码，只允许有的三种注释类型：概述代码、代码说明意图和代码无法表达的信息。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;注释占用太多时间通常归因于两点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;注释的风格可能耗时或枯燥乏味。如果这样，请另谋新的风格。需要庞大工作量的注释风格维护起来也会令人头痛。如果注释不便修改，人们就不愿意修改。于是注释就会变得不准确，起到误导作用，反而还不如没有注释&lt;/li&gt;
&lt;li&gt;说明程序干什么的话不好想出来。这通常是你没有真正理解程序的信号。“写注释”所占用的时间其实都用在了更好地理解程序上面，而不管你写不写注释，这些时间注定是得花的&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面是高效注释的几条指导原则。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;采用不会打断或抑制修改的注释凤格：不要为了美观而使用大量的&lt;code&gt;.-*&lt;/code&gt;符号排版的注释，例如用星号围成一个矩形的注释，每加入一行都得小心维护右边的星号。如果花大量时间增删符号只是为了对齐，你就不是在编程，而是浪费时光&lt;/li&gt;
&lt;li&gt;用伪代码编程法减少注释时间&lt;/li&gt;
&lt;li&gt;将注释集成到你的开发过程中：不要项目快结束时才开始写注释，也不要把注释当做专门的任务，而应该边写代码边注释。&lt;/li&gt;
&lt;li&gt;性能不是逃避注释的好借口：像Javascript的注释会增大网络传输的流量，但这不是理由，解决方案应该是构建不包含注释的发布版代码，区别于开发版代码&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-3-注释技术&quot;&gt;&lt;a href=&quot;#2-3-注释技术&quot; class=&quot;headerlink&quot; title=&quot;2.3 注释技术&quot;&gt;&lt;/a&gt;2.3 注释技术&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;注释单行&lt;ul&gt;
&lt;li&gt;不要随意添加无关的注释&lt;/li&gt;
&lt;li&gt;尽量不要使用行尾注释，因为写行尾难以格式化和维护，也经常是重复说明本行代码的废话。这几种例外情况可以使用行尾注释：用于数据声明，或标记代码块尾部（如end while，end if）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;注释代码段&lt;ul&gt;
&lt;li&gt;注释应表达代码段的意图，指出代码本身说不清的本意。TIPS：在给代码段写意图注释时，想象这段代码转换成一个子程序，应该命名什么名字，这个名字很有可能就是意图&lt;/li&gt;
&lt;li&gt;注释应注重“为何做（why）”而不是“怎么做（how）”&lt;/li&gt;
&lt;li&gt;用注释为后面的内容做铺垫：好的注释会让读者只要浏览注释就能了解代码在做什么，去哪找特定的操作&lt;/li&gt;
&lt;li&gt;说明非常规做法（trick）&lt;/li&gt;
&lt;li&gt;代码错误或语言环境独特点都要加注释&lt;/li&gt;
&lt;li&gt;给出不得不故意违背良好编程风格的理由&lt;/li&gt;
&lt;li&gt;不要为投机取巧的代码加注释说明，应重写之&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;注释数据声明&lt;ul&gt;
&lt;li&gt;注释数据的单位（包括单位所处的背景环境）和取值范围（包括输入数据的限制）&lt;/li&gt;
&lt;li&gt;注释枚举类型各个值的含义，注释bit位标识的含义&lt;/li&gt;
&lt;li&gt;注释全局数据：指出该数据的目的，为何必须是全局数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;注释控制结构&lt;ul&gt;
&lt;li&gt;应在每个if、case、循环前加上注释，阐明控制结构的意图&lt;/li&gt;
&lt;li&gt;在长控制结构或嵌套控制结构结尾处加上注释&lt;/li&gt;
&lt;li&gt;如果用到了上一条规则，那么应将控制结构结束处的注释看成是代码太复杂的征兆：最好办法就是重写代码，使之不再复杂到需要费劲注释的程度&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;注释子程序&lt;ul&gt;
&lt;li&gt;在子程序上部用一两句话说明其意图，如果参数很复杂要在声明参数处注释这些参数（如果参数涉及输出，还要特别说明）&lt;/li&gt;
&lt;li&gt;利用诸如Javadoc之类的代码说明工具，则可以替代上一条&lt;/li&gt;
&lt;li&gt;注释接口假设：例如假设传入的数组是有序的，传入的对象是初始化过的等等，都应该描述清楚&lt;/li&gt;
&lt;li&gt;对子程序的局限性作注释：例如指出结果的精确度，子程序碰到麻烦时的默认行为，对程序做什么修改会损坏此子程序等等&lt;/li&gt;
&lt;li&gt;说明子程序对全局数据的操作，如果有的话&lt;/li&gt;
&lt;li&gt;记录所用算法的来源&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;注释类和文件&lt;ul&gt;
&lt;li&gt;说明类的设计方法，局限性、用法假设，不要在类接口处说明实现细节&lt;/li&gt;
&lt;li&gt;在文件开头处用注释块说明文件的意图和内容&lt;/li&gt;
&lt;li&gt;在文件注释块中包含作者姓名、电子邮件、电话号码、版本控制标记、法律通告等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考文献：电子工业出版社《代码大全（第2版）》第31、32章&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;本文关注的是计算机编程的美学话题——程序源代码的布局和自说明性。尽管这些技巧并不影响执行速度、内存使用量等方面的程序性能，但它却会让你日后理解、检查以及修改代码变得更容易，也使其他人在你缺位的时候更容易阅读、理解和修改你的代码。&lt;/p&gt;
&lt;p&gt;需要注意的是，形成良好的代码布局，并让代码具备自说明性，需要始终贯穿项目的生命期，晚了就很难做好了。要想完全实现这些细节规定，在最初建构时就要着手去做。如果你干的是合作项目，更是要在开始编码之前统一大家的风格。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="综合" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/"/>
    
      <category term="软件工程" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="软件构建" scheme="http://raytaylorlin.com/tags/%E8%BD%AF%E4%BB%B6%E6%9E%84%E5%BB%BA/"/>
    
      <category term="软件工程" scheme="http://raytaylorlin.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="代码大全" scheme="http://raytaylorlin.com/tags/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>软件构建（十三）——代码集成</title>
    <link href="http://raytaylorlin.com/tech/complex/software/software-construction-13/"/>
    <id>http://raytaylorlin.com/tech/complex/software/software-construction-13/</id>
    <published>2016-05-09T07:35:29.000Z</published>
    <updated>2016-05-12T13:13:50.400Z</updated>
    
    <content type="html">&lt;p&gt;集成是指将一些独立的软件组件组合为一个完整系统。对大项目，集成也许要花数周或数月时间，把一组程序编织为一个整体。本文将首先介绍不太常用的阶段式集成，然后再介绍更为常用的增量集成，其中集成的策略是讨论的重点。最后每日构建与冒烟测试的使用原则。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;集成是在开发人员完成开发者测试之后才进行的，而且集成过程是与系统测试一道进行的，所以集成有时也被认为是一种测试行为。然而，集成本身就足够复杂了，因此应该被看做一项独立的行动。程序集成有两种方式：阶段式集成和增量集成。&lt;/p&gt;
&lt;h1 id=&quot;1-阶段式集成&quot;&gt;&lt;a href=&quot;#1-阶段式集成&quot; class=&quot;headerlink&quot; title=&quot;1. 阶段式集成&quot;&gt;&lt;/a&gt;1. 阶段式集成&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;设计、编码、测试、调试各个类，这一步称为“单元开发”&lt;/li&gt;
&lt;li&gt;将这些类组合为一个庞大的系统，这一步成为“系统集成”&lt;/li&gt;
&lt;li&gt;测试并调试整个系统，这一步成为“系统瓦解（system dis-integration）”&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这种集成的问题是，当第一次把系统中的类放到一起时，新的问题会不可避免地大量浮现，所有的类都有嫌疑导致出问题的位置难以确定。所以对绝大多数情况，阶段式集成都不是很适用。&lt;/p&gt;
&lt;h1 id=&quot;2-增量集成&quot;&gt;&lt;a href=&quot;#2-增量集成&quot; class=&quot;headerlink&quot; title=&quot;2. 增量集成&quot;&gt;&lt;/a&gt;2. 增量集成&lt;/h1&gt;&lt;h2 id=&quot;2-1-方法&quot;&gt;&lt;a href=&quot;#2-1-方法&quot; class=&quot;headerlink&quot; title=&quot;2.1 方法&quot;&gt;&lt;/a&gt;2.1 方法&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;开发一个小的系统功能部件。它可能是最小的功能部件、最难的部件、关键部件、或者以上的某种组合，对它彻底地测试并调试。将它作为骨架，稍后附着肌肉、神经、皮肤等系统的其余部件&lt;/li&gt;
&lt;li&gt;设计、编码、测试、调试某个类&lt;/li&gt;
&lt;li&gt;将这个新的类集成到系统骨架上，测试并调试“骨架和新类的结合体”。在进一步添加任何新类之前，确保该结合体能工作。如果做完了剩余的所有工作，就回到步骤2开始重复这一过程&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;2-2-相对阶段式集成的优势&quot;&gt;&lt;a href=&quot;#2-2-相对阶段式集成的优势&quot; class=&quot;headerlink&quot; title=&quot;2.2 相对阶段式集成的优势&quot;&gt;&lt;/a&gt;2.2 相对阶段式集成的优势&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;易于定位错误：降低“多个问题之间相互影响”或“一个问题将另一个问题掩盖”的风险&lt;/li&gt;
&lt;li&gt;及旱在项目里取得系统级的成果&lt;/li&gt;
&lt;li&gt;改善对进度的监控：利于管理层判断进度和需求&lt;/li&gt;
&lt;li&gt;更加充分地测试系统中的各个单元&lt;/li&gt;
&lt;li&gt;能在更短的开发进度计划内建造出整个系统&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-3-策略&quot;&gt;&lt;a href=&quot;#2-3-策略&quot; class=&quot;headerlink&quot; title=&quot;2.3 策略&quot;&gt;&lt;/a&gt;2.3 策略&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;自顶向下集成&lt;ul&gt;
&lt;li&gt;一般从主入口（Main函数、主窗体等等）开始，测试顶层类时需要一些存根（stub）类辅助，最终逐渐替换为实际的类&lt;/li&gt;
&lt;li&gt;优点：能快速得到一个能部分工作的系统，并及早地暴露一些设计上的问题&lt;/li&gt;
&lt;li&gt;缺点：棘手的系统接口的演练必须留到最后才进行，有问题的底层可能会反过来影响顶层&lt;/li&gt;
&lt;li&gt;纯粹的自顶向下集成几乎是不可能的，大多时候使用混合方法集成，或用下图的在各个竖直划分的功能块中自顶向下集成&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://raytaylorlin-blog.qiniudn.com/image%2Fsoftware%2F%E5%9C%A8%E5%90%84%E4%B8%AA%E7%AB%96%E7%9B%B4%E5%88%92%E5%88%86%E7%9A%84%E5%8A%9F%E8%83%BD%E5%9D%97%E4%B8%AD%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E9%9B%86%E6%88%90.png&quot; alt=&quot;在各个竖直划分的功能块中自顶向下集成&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自底向上集成&lt;ul&gt;
&lt;li&gt;首先要完成整个系统的设计，然后一个一个添加底层类向上层集成，最初需要编写驱动测试类&lt;/li&gt;
&lt;li&gt;优点：容易定位错误，尽早演练“可能存在问题的系统接口”&lt;/li&gt;
&lt;li&gt;缺点：如果高层存在概念上的设计问题，那么要把所有细节工作都做完才能发现&lt;/li&gt;
&lt;li&gt;一般也很少用纯粹的自底向上集成&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;三明治集成&lt;ul&gt;
&lt;li&gt;首先集成继承体系顶部的高层业务对象类，然后集成底部的与设备接口的类和广泛使用的工具类，最后集成中间层的类&lt;/li&gt;
&lt;li&gt;结合了上述两种方式的优点，是现实的实用的方法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;风险导向的集成&lt;ul&gt;
&lt;li&gt;大顺序和三明治集成一致，但细节顺序，是优先考虑高风险的实现最有挑战的部件，如顶层接口、底层系统接口、未被透彻理解的算法的类等等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;功能导向的集成&lt;ul&gt;
&lt;li&gt;首先需要搭建好骨架，然后按照功能（模块）划分顺序来集成，如下图所示&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://raytaylorlin-blog.qiniudn.com/image%2Fsoftware%2F%E5%8A%9F%E8%83%BD%E5%AF%BC%E5%90%91%E7%9A%84%E9%9B%86%E6%88%90%E7%A4%BA%E6%84%8F%E5%9B%BE.png&quot; alt=&quot;功能导向的集成示意图&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;T型集成&lt;ul&gt;
&lt;li&gt;先选中某个特定的“竖直块”及早开发并集成，这个功能块应该能从头到尾演练系统，并找出系统设计的全部主要问题。纠正所有问题后，就可以开始开发系统其它核心部件，如下图所示。这种方法常与风险导向和功能导向集成集合使用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://raytaylorlin-blog.qiniudn.com/image%2Fsoftware%2FT%E5%9E%8B%E9%9B%86%E6%88%90%E7%A4%BA%E6%84%8F%E5%9B%BE.png&quot; alt=&quot;T型集成示意图&quot;&gt;&lt;/p&gt;
&lt;p&gt;集成顺序的策略有多种多样的形状和规模，没有哪一种对所有情况而言都是最佳的。&lt;strong&gt;最佳集成步骤随项目不同而变化，最佳解决方案总是为了满足特定项目的特定需求而制定的，不要像教条一样遵循前面提到的任何过程。&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;3-每日构建与冒烟测试&quot;&gt;&lt;a href=&quot;#3-每日构建与冒烟测试&quot; class=&quot;headerlink&quot; title=&quot;3. 每日构建与冒烟测试&quot;&gt;&lt;/a&gt;3. 每日构建与冒烟测试&lt;/h1&gt;&lt;p&gt;无论选用哪种集成策略，&lt;a href=&quot;http://baike.baidu.com/view/1704207.htm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;每日构建（daily build）&lt;/a&gt;和&lt;a href=&quot;http://baike.baidu.com/view/120001.htm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;冒烟测试&lt;/a&gt;都是软件集成的好方法。这些简单的过程可以降低出现低质量软件的风险，也便于诊断缺陷，并且每天的成果可以极大地鼓舞士气。以下是这两种方法的一些使用原则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关键是&lt;strong&gt;每一天&lt;/strong&gt;坚持build：某次build失败可以将错误锁定在一天之内&lt;/li&gt;
&lt;li&gt;检查失败的build：每个项目要建立一套评定“什么才算是破坏了build”的质量标准&lt;/li&gt;
&lt;li&gt;每天进行准确的冒烟测试：冒烟测试应彻底地从头到尾演练&lt;strong&gt;已完成的&lt;/strong&gt;系统的主要功能，不要认为是浪费时间的重复性工作&lt;/li&gt;
&lt;li&gt;自动化：&lt;strong&gt;脱离自动化谈每日构建与冒烟测试是不切实际的&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;成立build小组&lt;/li&gt;
&lt;li&gt;仅当有意义时，才将修订（revisions）加入build中……：因为通常开发者编写代码的速度不会快到使系统每天都有明显的进展&lt;/li&gt;
&lt;li&gt;……但是别等太久才将修订加入进来：警惕某个开发人员接连两三天都不check in他做的改动，他很可能陷入一组牵扯到大量文件的修订中&lt;/li&gt;
&lt;li&gt;要求开发人员在把他的代码添加到系统之前，进行本地冒烟测试&lt;/li&gt;
&lt;li&gt;为即将添加到build的代码准备一块暂存区，在暂存区产生新的build并认为其可接受时，才合并到主源码中&lt;/li&gt;
&lt;li&gt;惩罚破坏build的人：build失败是异常情况，应严肃对待&lt;/li&gt;
&lt;li&gt;在早上发布build：测试人员可以当天测试，发现问题也能尽早找到开发者解决&lt;/li&gt;
&lt;li&gt;即使有进度压力，也要保持daily build和冒烟测试&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考文献：电子工业出版社《代码大全（第2版）》第29章&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;集成是指将一些独立的软件组件组合为一个完整系统。对大项目，集成也许要花数周或数月时间，把一组程序编织为一个整体。本文将首先介绍不太常用的阶段式集成，然后再介绍更为常用的增量集成，其中集成的策略是讨论的重点。最后每日构建与冒烟测试的使用原则。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="综合" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/"/>
    
      <category term="软件工程" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="软件构建" scheme="http://raytaylorlin.com/tags/%E8%BD%AF%E4%BB%B6%E6%9E%84%E5%BB%BA/"/>
    
      <category term="软件工程" scheme="http://raytaylorlin.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="代码大全" scheme="http://raytaylorlin.com/tags/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>软件构建（十二）——软件的规模与管理</title>
    <link href="http://raytaylorlin.com/tech/complex/software/software-construction-12/"/>
    <id>http://raytaylorlin.com/tech/complex/software/software-construction-12/</id>
    <published>2016-05-06T09:00:40.000Z</published>
    <updated>2016-05-12T13:14:52.322Z</updated>
    
    <content type="html">&lt;p&gt;软件开发的规模扩大并不是像“拿一个小项目来，然后增大它的每一部分”那样简单。如果要开发大型软件，就必须了解软件规模对构建的影响。此外，本文将记录与构建直接相关的一些特定管理问题。如果你是一名开发人员，本文将帮助你了解管理者需要考虑的一些问题；如果你是一名管理者，本文将帮助你了解开发人员是如何看待管理者的，以及如何才能有效地管理构建。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-程序规模对构建的影响&quot;&gt;&lt;a href=&quot;#1-程序规模对构建的影响&quot; class=&quot;headerlink&quot; title=&quot;1. 程序规模对构建的影响&quot;&gt;&lt;/a&gt;1. 程序规模对构建的影响&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;成员交流与项目规模的关系：交流路径越多，花在交流上的时间就越多（见下图），因交流而出错的机会也就越大，改善交流效率的常用方法是采用正式的文挡&lt;ul&gt;
&lt;li&gt;&lt;img src=&quot;http://7d9rl0.com1.z0.glb.clouddn.com/image/software/%E6%88%90%E5%91%98%E4%BA%A4%E6%B5%81%E4%B8%8E%E9%A1%B9%E7%9B%AE%E8%A7%84%E6%A8%A1%E7%9A%84%E5%85%B3%E7%B3%BB.png&quot; alt=&quot;成员交流与项目规模的关系&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;项目规模对错误的影响：在小项目中，构建错误大约占所有被发现错误的75%，在更大的项目中，构建错误占错误总数的比例逐步下降到50%左右，而需求错误和架构错误则弥补了其中差额。缺陷密度（每1000行代码所包含的缺陷数量）会随项目规模增大而增加&lt;/li&gt;
&lt;li&gt;顶目规模对生产率的影响：小项目的生产率会比大项目高出2至3倍，并且最小的项目和最大的项目的生产率差距可能达到5到10倍之巨&lt;/li&gt;
&lt;li&gt;顶目规模对开发活动的影响：对小型项目，构建占差不多65%的开发实践，随着项目规模增大，构建的比重逐渐减小，架构、设计、集成和测试占更多时间&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;2-管理构建&quot;&gt;&lt;a href=&quot;#2-管理构建&quot; class=&quot;headerlink&quot; title=&quot;2. 管理构建&quot;&gt;&lt;/a&gt;2. 管理构建&lt;/h1&gt;&lt;h2 id=&quot;2-1-鼓励良好的编码实践&quot;&gt;&lt;a href=&quot;#2-1-鼓励良好的编码实践&quot; class=&quot;headerlink&quot; title=&quot;2.1 鼓励良好的编码实践&quot;&gt;&lt;/a&gt;2.1 鼓励良好的编码实践&lt;/h2&gt;&lt;p&gt;从管理的角度出发，强制采用一套严格的技术标准并不是个好主意。如果项目中有人要制定标准，那么应该由一位受人尊敬的架构师来做，而不应该由管理者来做。下面给出一些编码实践，这些实践比呆板的编码标准更容易实行：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;给项目的每一部分分派两个人：结对编程，导师带学生等等&lt;/li&gt;
&lt;li&gt;同行复查代码：包括程序员本人和至少两名评审员的复查，可以为改善代码质量提供压力&lt;/li&gt;
&lt;li&gt;要求代码签名：在认定代码完成之前，高级技术人员要在代码清单上签字&lt;/li&gt;
&lt;li&gt;安排一些好的代码示例供人参考&lt;/li&gt;
&lt;li&gt;强调代码是公有财产&lt;/li&gt;
&lt;li&gt;奖励好代码：给予程序员想要的奖励，只有非常出色的代码才应得到奖励&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-2-配置管理&quot;&gt;&lt;a href=&quot;#2-2-配置管理&quot; class=&quot;headerlink&quot; title=&quot;2.2 配置管理&quot;&gt;&lt;/a&gt;2.2 配置管理&lt;/h2&gt;&lt;p&gt;配置管理即“变更控制”。如果你不对需求变更加以控制，那么就会为系统中某些最终会被去除的部件编写代码，也会去写出一些可能与系统中新的部件不兼容的代码；可能会修改某个别人也正在修改的子程序，把两个人的改动合并导致出现问题。总之，配置管理就是使用评估提交的更改、追踪更改、保留系统在不同时间点的历史版本等等技术来对软件项目的变化进行控制。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需求变更和设计变更&lt;ul&gt;
&lt;li&gt;遵循某种系统化的变更控制手续&lt;/li&gt;
&lt;li&gt;成组地处理变更请求：先记下所有的想法和建议，直到有时间再去整体处理它们，以防总是在中途突然变卦&lt;/li&gt;
&lt;li&gt;评估每项变更的成本：重新设计和编码，修改用户文档，评估代码复查，重新测试等等各种时间成本&lt;/li&gt;
&lt;li&gt;提防大量的变更请求：有时这可能是一个表明需求、架构或上层设计做的不够好导致无法支持变更的警报&lt;/li&gt;
&lt;li&gt;成立变更控制委员会或者类似机构&lt;/li&gt;
&lt;li&gt;警惕官僚主义，但也不要因为害怕官僚主义而排斥有效的变更控制&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;软件代码变更：使用合适的版本控制软件&lt;/li&gt;
&lt;li&gt;工具版本：可能有些项目需要“重新构造出‘创建软件的各个特定版本’的原样环境”的能力，这时需要把编译器、链接器、代码库等也纳入版本控制中&lt;/li&gt;
&lt;li&gt;机器配置：使用标准化的开发机器配置和操作系统映像，可以省掉许多开发前配置的麻烦&lt;/li&gt;
&lt;li&gt;备份计划：项目过程中应定期备份代码、文档、图表以及保存介质；要测试备份过程，确保所需的全部数据能正确恢复；昨晚项目后及时归档&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-3-评估构建进度&quot;&gt;&lt;a href=&quot;#2-3-评估构建进度&quot; class=&quot;headerlink&quot; title=&quot;2.3 评估构建进度&quot;&gt;&lt;/a&gt;2.3 评估构建进度&lt;/h2&gt;&lt;p&gt;对于项目预估进度和实际进度，有调查表明，开发人员的估计值比实际值要乐观20%~30%。评估项目规模的方法有很多种，例如使用评估软件，使用算法方法，聘请外界的评估专家，评估项目的每一部分并加起来等等。下面是一套评估项目的参考原则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;建立目标：理清评估的目的、内容、准确度、乐观评估和悲观评估结果等&lt;/li&gt;
&lt;li&gt;为评估留出时间，并且做出计划&lt;/li&gt;
&lt;li&gt;清楚地说明软件需求&lt;/li&gt;
&lt;li&gt;在底层细节层面（划分为多个小块并分别）进行评估&lt;/li&gt;
&lt;li&gt;使用若干不同的评估方法，并且比较其结果&lt;/li&gt;
&lt;li&gt;在项目推进过程中定期做重新评估&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了按时完成软件项目而做的“计划”中，评估是很重要的组成部分。然而，最初评估的准确度的重要性远远比不上“随后为了完成进度而成功地&lt;strong&gt;控制资源&lt;/strong&gt;”的重要性。如果项目进度落后了，人们经常会产生一些错觉：“我们后面一定会加班加点把时间补回来”，调查显示越接近项目后期，延误和超支的现象就越严重；“扩充团队来加速开发”，新手需要先花时间熟悉项目，占用现有人员的培训时间，然后才能发挥出生产率，而且仅仅增加人员数量，会导致项目交流的复杂度和数量增加，除非项目的任务是可分割的才能通过增加人手完成。&lt;/p&gt;
&lt;p&gt;缩减项目范围是在进度落后时的有效手段。最初做产品计划的时候，要把产品的功能划分成“必须有”、“有了更好”和“可选择”三类。如果进度落后了，那么就调整“可选择”和“有了更好”的优先级，并扔掉那些最不重要的功能。&lt;/p&gt;
&lt;h2 id=&quot;2-4-把程序员当人看&quot;&gt;&lt;a href=&quot;#2-4-把程序员当人看&quot; class=&quot;headerlink&quot; title=&quot;2.4 把程序员当人看&quot;&gt;&lt;/a&gt;2.4 把程序员当人看&lt;/h2&gt;&lt;p&gt;首先要了解程序员的时间分配。研究表明一个程序员大约有30%的时间花费在“对项目没有直接好处”的非技术活动之上：步行、个人事务等，学习和编写代码占约30%。&lt;/p&gt;
&lt;p&gt;其次是了解程序员的信仰问题。这些信仰涉及编程语言、编码风格、编程工具、编程方法论等等。作为一个管理者，要清楚地知道信仰是一个敏感的问题，对这些领域要使用“建议”或者“指导原则”（避免僵硬的“规则”或“标准”），并让程序员们制定他们自己的标准。当然，如果有人因可读性差等影响整个项目的实践行为，为了提高代码质量，不要怕引发一些摩擦。&lt;/p&gt;
&lt;p&gt;最后，要了解物理环境对程序员生产率有着巨大的影响。这些环境包括桌子、椅子、电脑、书籍、键盘，以及办公氛围、不经常被打扰的环境等等。如果你的工作环境属于最差的那25%，那么你有机会给生产率带来100%的提升，办法是把环境改善为最佳的那25%。&lt;/p&gt;
&lt;h2 id=&quot;2-5-管理你的管理者&quot;&gt;&lt;a href=&quot;#2-5-管理你的管理者&quot; class=&quot;headerlink&quot; title=&quot;2.5 管理你的管理者&quot;&gt;&lt;/a&gt;2.5 管理你的管理者&lt;/h2&gt;&lt;p&gt;在软件开发中，如果你需要面对非技术出身的管理者，你可能要肩负起“管理你的管理者”的责任。其要点在于，你要表现得使你的管理者认为他仍然在管理你。有这么一些应对管理者的方法：把你希望做什么的念头先藏起来，等着你的管理者组织一场有关你希望什么的头脑风暴/集体讨论；把做事情的正确方法传授给你的管理者；关注你的管理者的兴趣，按照他的真正意图去做；拒绝按照你的管理者所说的去做，坚持用正确的方法做自己的事；换工作。&lt;/p&gt;
&lt;p&gt;参考文献：电子工业出版社《代码大全（第2版）》第27、28章&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;软件开发的规模扩大并不是像“拿一个小项目来，然后增大它的每一部分”那样简单。如果要开发大型软件，就必须了解软件规模对构建的影响。此外，本文将记录与构建直接相关的一些特定管理问题。如果你是一名开发人员，本文将帮助你了解管理者需要考虑的一些问题；如果你是一名管理者，本文将帮助你了解开发人员是如何看待管理者的，以及如何才能有效地管理构建。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="综合" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/"/>
    
      <category term="软件工程" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="软件构建" scheme="http://raytaylorlin.com/tags/%E8%BD%AF%E4%BB%B6%E6%9E%84%E5%BB%BA/"/>
    
      <category term="软件工程" scheme="http://raytaylorlin.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="代码大全" scheme="http://raytaylorlin.com/tags/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>软件构建（十一）——代码性能的调整</title>
    <link href="http://raytaylorlin.com/tech/complex/software/software-construction-11/"/>
    <id>http://raytaylorlin.com/tech/complex/software/software-construction-11/</id>
    <published>2016-05-03T02:16:11.000Z</published>
    <updated>2016-05-12T13:14:47.660Z</updated>
    
    <content type="html">&lt;p&gt;本文首先概述了程序运行性能应该考虑的一些问题，然后从策略上和技术上两个方面来探讨代码性能的调整问题。技术上的代码调整并没有什么万金油的方法，也不是灵丹妙药，唯一可以信赖的法则就是每次都应当在具体的环境下评估代码调整所带来的效果，而本文所列的调整方法则仅供参考。此外，追求性能的背后往往伴随着牺牲程序的可读性和可维护性，而&lt;strong&gt;在很多情况下，代码的可读性和可维护性都要比运行速度或资源占用更为重要。&lt;/strong&gt;因此在调整代码时一定要考虑这样的性能提升是否真的必要。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-性能概述&quot;&gt;&lt;a href=&quot;#1-性能概述&quot; class=&quot;headerlink&quot; title=&quot;1. 性能概述&quot;&gt;&lt;/a&gt;1. 性能概述&lt;/h1&gt;&lt;p&gt;现实中，相对于代码质量和纯粹的性能，用户更关心的是程序的外在特性和处理能力。性能同代码速度之间存在着很松散的联系。如果只是关注于代码的运行速度，你的工作不免顾此失彼。要特别当心放弃其他功能去让你的代码跑得更快。如果过分强调速度，程序的整体性能（表现）常常不升反降。&lt;/p&gt;
&lt;p&gt;如果要追求程序的效率，可以从以下几个方面来思考问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;性能需求：客户要求的系统响应时间有时决定了设计方案的复杂度和成本，在花费时间处理一个性能问题之前，要想清楚是否真的需要满足这样的需求&lt;/li&gt;
&lt;li&gt;程序架构：优先考虑整体性能，然后再为每个子系统和类设置要达到的性能目标&lt;/li&gt;
&lt;li&gt;类和子程序设计：在这一层次，数据结构和算法将对性能产生重要影响&lt;/li&gt;
&lt;li&gt;与操作系统的交互：考虑系统I/O，系统调用等性能&lt;/li&gt;
&lt;li&gt;代码编译：这一层次由编译器和转化后的机器码决定，通常程序员无法干预&lt;/li&gt;
&lt;li&gt;硬件：有时直接升级硬件是最直接了当的提升性能的办法&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;2-策略上的代码调整&quot;&gt;&lt;a href=&quot;#2-策略上的代码调整&quot; class=&quot;headerlink&quot; title=&quot;2. 策略上的代码调整&quot;&gt;&lt;/a&gt;2. 策略上的代码调整&lt;/h1&gt;&lt;h2 id=&quot;2-1-佩雷托法则&quot;&gt;&lt;a href=&quot;#2-1-佩雷托法则&quot; class=&quot;headerlink&quot; title=&quot;2.1 佩雷托法则&quot;&gt;&lt;/a&gt;2.1 佩雷托法则&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%B8%95%E9%9B%B7%E6%89%98%E6%B3%95%E5%88%99&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;帕雷托法则&lt;/a&gt;即是众所周知的80/20法则，其对程序性能优化也是有效的，即程序中20%的子程序耗费了80%的执行时间。因此程序员们应当衡量代码的各个部分（如使用性能分析器），找出最需要关注的地方，然后集中火力来对付占用了绝大部分资源的少量代码。&lt;/p&gt;
&lt;h2 id=&quot;2-2-代码调整的一些误区&quot;&gt;&lt;a href=&quot;#2-2-代码调整的一些误区&quot; class=&quot;headerlink&quot; title=&quot;2.2 代码调整的一些误区&quot;&gt;&lt;/a&gt;2.2 代码调整的一些误区&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;在高级语言中，减少代码的行数就可以提升所生成的机器代码的运行速度，或是减少其资源占用——&lt;strong&gt;错误！&lt;/strong&gt;：实际上高级语言代码行数和程序最终的资源占用和运行速度之间并没有必然联系&lt;/li&gt;
&lt;li&gt;特定运算可能比其他的快，代码规模也较小——&lt;strong&gt;错误！&lt;/strong&gt;：程序性能受语言、编译器种类、编译器版本、库种类、库版本、中央处理器、机器内存等等环境的影响&lt;/li&gt;
&lt;li&gt;应当随时随地进行优化——&lt;strong&gt;错误！&lt;/strong&gt;：应该在整个系统完成之后综合分析，才能最准确快速地找到瓶颈&lt;/li&gt;
&lt;li&gt;程序的运行速度同其正确性同等重要——&lt;strong&gt;错误！&lt;/strong&gt;：程序要先保证正确运行，再考虑运行速度&lt;/li&gt;
&lt;li&gt;编译器的优化功能可能比你想象的要强大得多：在编写代码时自作聪明，编译器在优化这些代码的时候会痛苦不堪，结果是你的程序倒霉，&lt;strong&gt;应该使用直白的代码&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-3-常见的性能瓶颈&quot;&gt;&lt;a href=&quot;#2-3-常见的性能瓶颈&quot; class=&quot;headerlink&quot; title=&quot;2.3 常见的性能瓶颈&quot;&gt;&lt;/a&gt;2.3 常见的性能瓶颈&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;输入/输出操作：包括文件、数据库、网络等等的读写&lt;/li&gt;
&lt;li&gt;操作系统内存分页时的缺页中断&lt;/li&gt;
&lt;li&gt;系统调用：考虑编写自己的服务程序来替代，或者减少不必要的系统调用等等&lt;/li&gt;
&lt;li&gt;解释型语言&lt;/li&gt;
&lt;li&gt;代码中的错误：如没有去掉调试代码，忘记释放内存，数据库表设计失误，轮询并不存在的设备，超时等等&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-4-性能测量&quot;&gt;&lt;a href=&quot;#2-4-性能测量&quot; class=&quot;headerlink&quot; title=&quot;2.4 性能测量&quot;&gt;&lt;/a&gt;2.4 性能测量&lt;/h2&gt;&lt;p&gt;在优化代码的过程中，一定要使用工具来进行性能测量，特别是对代码进行改进之后要实际测量一下看有没有改进。一个的典型的案例是C++对矩阵元素求和，通常的写法是二重循环遍历行列求和，但有的人可能会觉得数组访问和循环条件判断会花掉很多时间，对于一个100×100的矩阵会产生一万次乘法和加法，于是考虑改成一重循环用指针访问数组（但这样会牺牲代码可读性）。但实际测量结果时修改后性能&lt;strong&gt;没有任何变化&lt;/strong&gt;，原因是编译器早已将数组访问改为用指针实现。这个案例告诉我们，&lt;strong&gt;性能问题的很多方面都是违反直觉的，而且经验对性能优化也没有太大的帮助。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;找出性能瓶颈之后，应该结合多种优化方法反复对代码进行迭代和调整，尽管每种方法单独实施起来收效并不大，但把所有方法结合起来将可以优化出非常好的结果。&lt;/p&gt;
&lt;h1 id=&quot;3-技术上的代码调整&quot;&gt;&lt;a href=&quot;#3-技术上的代码调整&quot; class=&quot;headerlink&quot; title=&quot;3. 技术上的代码调整&quot;&gt;&lt;/a&gt;3. 技术上的代码调整&lt;/h1&gt;&lt;p&gt;再次重申，&lt;strong&gt;在很多情况下，代码的可读性和可维护性都要比运行速度或资源占用更为重要。&lt;/strong&gt;因此在调整代码时一定要考虑这样的性能提升是否真的必要。而且调整完之后一定要用工具测量一下性能的提升到底有没有起效。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;逻辑判断的调整&lt;ul&gt;
&lt;li&gt;在知道答案后停止判断：利用好“短路求值”的语言特性中断and的条件判断，或者在循环遍历查找时找到后break退出&lt;/li&gt;
&lt;li&gt;按照出现频率来调整if-elseif的顺序，让运行最快和判断结果最有可能为真的判断首先被执行&lt;/li&gt;
&lt;li&gt;用查询表替代复杂表达式&lt;/li&gt;
&lt;li&gt;使用惰性求值：仅到必须使用的时候才去处理数据，例如有一张大数据表，程序仅仅用到很小一部分，与其在程序启动时生成表的所有内容，不如放到需要的时候再计算&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;循环的调整&lt;ul&gt;
&lt;li&gt;将循环中的判断往外提，避免每次在循环中做重复的判断&lt;/li&gt;
&lt;li&gt;当两个循环的下标变化相同时，可以考虑合并成一个循环，但要确保代码先后顺序一致&lt;/li&gt;
&lt;li&gt;将循环展开（减少了循环条件判断）：会严重影响可读性，而且只对少量元素的循环适用&lt;/li&gt;
&lt;li&gt;尽可能减少在循环内部做的工作：例如将重复计算的常量移到循环外&lt;/li&gt;
&lt;li&gt;在线性查找循环中，使用“哨兵值”来替代多次条件判断&lt;/li&gt;
&lt;li&gt;把最忙的（即循环次数多的）循环放在最内层&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据变换的调整&lt;ul&gt;
&lt;li&gt;使用整数而不是浮点数&lt;/li&gt;
&lt;li&gt;尽可能减少数组维度：例如考虑用一维数组来表示二维的矩阵&lt;/li&gt;
&lt;li&gt;尽可能减少数组引用&lt;/li&gt;
&lt;li&gt;使用辅助索引：添加相关数据，使得对某种数据类型的访问更为高效。例如，如果数据类型中的条目很大或是存于磁盘上难于移动，可以创建一个存放关键码和指向详细信息的指针的辅助索引，在内存中对索引进行排序或查找，最后进行一次代价高昂的访问即可&lt;/li&gt;
&lt;li&gt;使用缓存机制：缓存常用的或者需要耗费大量时间计算的值。创建新元素的代价越大，请求相同信息的次数越多，那么缓存就越有价值，风险是增加程序的复杂性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;表达式的调整&lt;ul&gt;
&lt;li&gt;利用代数恒等式：例如&lt;code&gt;not (a or b)&lt;/code&gt;比&lt;code&gt;not a and not b&lt;/code&gt;省一次not操作，判断&lt;code&gt;x &amp;lt; y&lt;/code&gt;要比判断&lt;code&gt;sqrt(x) &amp;lt; sqrt(y)&lt;/code&gt;省上几十甚至上百倍的时间&lt;/li&gt;
&lt;li&gt;削弱运算强度：如用加法替代乘法，乘法代替乘幂，移位替代乘除，三角恒等式代换等价的三角函数，单精度数代替双精度数等等&lt;/li&gt;
&lt;li&gt;编译期初始化：把代价高昂的常量计算提前定义成常量&lt;/li&gt;
&lt;li&gt;如果系统函数提供的功能过于复杂，考虑自己写一个：例如计算以2为底且是整数的对数函数，与其使用官方的浮点log函数计算，不如自己写一个穷举整数范围的Log2函数&lt;/li&gt;
&lt;li&gt;删除重复使用的公共子表达式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;子程序的调整&lt;ul&gt;
&lt;li&gt;将子程序重写为内联（C++）&lt;/li&gt;
&lt;li&gt;用低级语言重写核心代码：应先用高级语言编写整个应用程序，经过完整测试验证正确性后，如果需要改进性能，再考虑用少量的低级语言去重写核心部分。例如某些语言可能不擅长处理位操作，此时将这部分直接翻译成汇编是不错的选择&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;4-总结&quot;&gt;&lt;a href=&quot;#4-总结&quot; class=&quot;headerlink&quot; title=&quot;4. 总结&quot;&gt;&lt;/a&gt;4. 总结&lt;/h1&gt;&lt;p&gt;研究表明，任何特定优化的效果实际上都不可预测：每一步代码调整所产生的影响都受制于编程语言、编译器、编译器的版本、代码&lt;br&gt;库、库版本以及编译器设置等各种因素。此外，代码调整无可避免地为性能改善的良好愿望而付出复杂性、可读性、简单性、可维护性方面的代价。由于每一次调整后需要对性能进行重新评估，代码调整还引入了巨额的管理维护开销。&lt;/p&gt;
&lt;p&gt;进行代码调整时，应该恪守“对每一次的改进进行量化”的准则。如果某项优化非常重要，值得为它付出剖析和对优化效果进行量化测量的代价，那么只要优化有效，我们还是可以去做的。&lt;/p&gt;
&lt;p&gt;参考文献：电子工业出版社《代码大全（第2版）》第25、26章&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;本文首先概述了程序运行性能应该考虑的一些问题，然后从策略上和技术上两个方面来探讨代码性能的调整问题。技术上的代码调整并没有什么万金油的方法，也不是灵丹妙药，唯一可以信赖的法则就是每次都应当在具体的环境下评估代码调整所带来的效果，而本文所列的调整方法则仅供参考。此外，追求性能的背后往往伴随着牺牲程序的可读性和可维护性，而&lt;strong&gt;在很多情况下，代码的可读性和可维护性都要比运行速度或资源占用更为重要。&lt;/strong&gt;因此在调整代码时一定要考虑这样的性能提升是否真的必要。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="综合" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/"/>
    
      <category term="软件工程" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="软件构建" scheme="http://raytaylorlin.com/tags/%E8%BD%AF%E4%BB%B6%E6%9E%84%E5%BB%BA/"/>
    
      <category term="软件工程" scheme="http://raytaylorlin.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="代码大全" scheme="http://raytaylorlin.com/tags/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>软件构建（十）——测试与重构</title>
    <link href="http://raytaylorlin.com/tech/complex/software/software-construction-10/"/>
    <id>http://raytaylorlin.com/tech/complex/software/software-construction-10/</id>
    <published>2016-04-29T08:19:39.000Z</published>
    <updated>2016-05-12T13:14:44.045Z</updated>
    
    <content type="html">&lt;p&gt;测试可以由开发人员或专门的测试人员进行。按层级分，测试可以分为单元测试、组件测试、继承测试、回归测试、系统测试；按是否了解对象内部工作机制分，测试可以分为黑盒测试和白盒测试。本文关注的是开发人员所进行的白盒测试。重构是“在不改变软件外部行为的前提下，对其内部结构进行改变，使之更容易理解并便于修改”的过程。本文将讲述软件演化以及重构的一些理念。&lt;/p&gt;
&lt;p&gt;测试和重构都是非常大的话题，大到足以各用一本经典著作来阐述，如&lt;a href=&quot;https://book.douban.com/subject/1801050/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《软件测试》&lt;/a&gt;和&lt;a href=&quot;https://book.douban.com/subject/4262627/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《重构：改善既有代码的设计》&lt;/a&gt;。因此本文也仅是记录一些要点，如果要深入了解，还是要阅读相关的书籍为好。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-开发者测试&quot;&gt;&lt;a href=&quot;#1-开发者测试&quot; class=&quot;headerlink&quot; title=&quot;1. 开发者测试&quot;&gt;&lt;/a&gt;1. 开发者测试&lt;/h1&gt;&lt;h2 id=&quot;1-1-开发者测试在软件质量中的角色&quot;&gt;&lt;a href=&quot;#1-1-开发者测试在软件质量中的角色&quot; class=&quot;headerlink&quot; title=&quot;1.1 开发者测试在软件质量中的角色&quot;&gt;&lt;/a&gt;1.1 开发者测试在软件质量中的角色&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;测试的目标是找出错误，与其他开发活动背道而驰&lt;/li&gt;
&lt;li&gt;测试永远不可能彻底证明程序中没有错误&lt;/li&gt;
&lt;li&gt;测试本身并不能改善软件的质量，只能用来指示&lt;/li&gt;
&lt;li&gt;测试时要求你假设会在代码里面找到错误&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根据项目大小和复杂程度的不同，开发者测试应该占整个项目时间的8%~25%。测试得出的结果，可以用来评估产品的可靠性，并指导对软件的修正。&lt;/p&gt;
&lt;h2 id=&quot;1-2-推荐方法&quot;&gt;&lt;a href=&quot;#1-2-推荐方法&quot; class=&quot;headerlink&quot; title=&quot;1.2 推荐方法&quot;&gt;&lt;/a&gt;1.2 推荐方法&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;对每一项相关的需求进行测试，以确保需求都已经被实现：最好在需求阶段就计划好这一部分的测试用例，并注意测试安全级别、数据存储、安装过程及系统可靠性等这些厂被忽略的测试点&lt;/li&gt;
&lt;li&gt;对每一项相关的设计关注点进行测试，以确保设计已经被实现&lt;/li&gt;
&lt;li&gt;使用一个检查表，其中记录着你在本项目迄今为止所犯的，以及在过去的项目中所犯的错误类型&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;推荐先写测试用例再写代码&lt;/strong&gt;：可以更早地把需求问题暴露出来，迫使你写代码前思考一下设计，并更早地发现代码中的缺陷&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1-2-1-结构化基础测试&quot;&gt;&lt;a href=&quot;#1-2-1-结构化基础测试&quot; class=&quot;headerlink&quot; title=&quot;1.2.1 结构化基础测试&quot;&gt;&lt;/a&gt;1.2.1 结构化基础测试&lt;/h3&gt;&lt;p&gt;一个子程序所需的测试用例的&lt;strong&gt;最少数量&lt;/strong&gt;可以用下面的简单方法计算：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对通过子程序的直路，开始的时候记1&lt;/li&gt;
&lt;li&gt;遇到if、while、repeat、for、and以及or关键字或者其等价物时，加1&lt;/li&gt;
&lt;li&gt;遇到每一个case语句就加1，如果case语句没有缺省情况，则再加1&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;假设一个子程序有5个if或for语句，那么至少需要6个测试用例，其中1个测试所有布尔条件都为真的正常情况，其余5个测试每一种假的情况。不过，结构化基础测试能够向你保证所有的代码都得到执行，但它并不能说明数据的变化情况。&lt;/p&gt;
&lt;h3 id=&quot;1-2-2-数据流测试&quot;&gt;&lt;a href=&quot;#1-2-2-数据流测试&quot; class=&quot;headerlink&quot; title=&quot;1.2.2 数据流测试&quot;&gt;&lt;/a&gt;1.2.2 数据流测试&lt;/h3&gt;&lt;p&gt;编写数据流测试用例的关键是要对所有可能的&lt;strong&gt;定义-使用&lt;/strong&gt;路径进行测试，即对每一个变量测试所有在某处定义而在另一处使用的组合。因此添加完整的“己定义-已使用”所需的用例可以覆盖到结构化基础测试所覆盖不到的情况。&lt;/p&gt;
&lt;h3 id=&quot;1-2-3-其他测试建议&quot;&gt;&lt;a href=&quot;#1-2-3-其他测试建议&quot; class=&quot;headerlink&quot; title=&quot;1.2.3 其他测试建议&quot;&gt;&lt;/a&gt;1.2.3 其他测试建议&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;猜测错误：猜测程序会在哪里出错的基础之上建立测试用例，通常基于直觉或者过去的经验&lt;/li&gt;
&lt;li&gt;边界值分析：除了分析边界点、允许的最大最小值之外，还应该注意多个变量互相关联时的边界&lt;/li&gt;
&lt;li&gt;测试几类坏数据：数据太少（没有数据），数据太多，无效数据，长度错误的数据，未初始化的数据&lt;/li&gt;
&lt;li&gt;测试几类好数据：正常的情形（所期望的值），最小和最大的正常情况，与旧数据的兼容性&lt;/li&gt;
&lt;li&gt;采用容易手工检查的测试用例&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-3-改善测试过程&quot;&gt;&lt;a href=&quot;#1-3-改善测试过程&quot; class=&quot;headerlink&quot; title=&quot;1.3 改善测试过程&quot;&gt;&lt;/a&gt;1.3 改善测试过程&lt;/h2&gt;&lt;h3 id=&quot;1-3-1-测试支持工具&quot;&gt;&lt;a href=&quot;#1-3-1-测试支持工具&quot; class=&quot;headerlink&quot; title=&quot;1.3.1 测试支持工具&quot;&gt;&lt;/a&gt;1.3.1 测试支持工具&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;为测试各个类构造脚手架：使用“模仿对象（mock object）”或“桩函数（stub routine）”来模拟测试&lt;/li&gt;
&lt;li&gt;Diff工具：将程序输出重定向到一个文件，并与预计输出文件作比较&lt;/li&gt;
&lt;li&gt;测试数据生成器：正确设计的随机数据生成器可以产生不寻常的测试数据组合，并且比手工构造数据更能彻底对程序进行测试&lt;/li&gt;
&lt;li&gt;覆盖率监视器：跟踪哪些代码己经测试过了，而哪些代码还没有&lt;/li&gt;
&lt;li&gt;数据记录器/日志记录器：监视程序，并在错误发生的时候为收集程序状态信息；另外可考虑编写自己的数据记录工具，并编译进开发版本中&lt;/li&gt;
&lt;li&gt;符号调试器：对代码进行单步调试，跟踪变量的值等等调试手段，可以作为测试和走查代码的辅助手段&lt;/li&gt;
&lt;li&gt;系统干扰器：这类工具有内存填充、内存抖动、选择性内存失败（模拟内存不足的情况）、内存访问边界检查（监视指针操作）等系统功能&lt;/li&gt;
&lt;li&gt;错误数据库：用于存放以往的错误，以便检查重复出现的错误&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1-3-2-改善测试过程&quot;&gt;&lt;a href=&quot;#1-3-2-改善测试过程&quot; class=&quot;headerlink&quot; title=&quot;1.3.2 改善测试过程&quot;&gt;&lt;/a&gt;1.3.2 改善测试过程&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;有计划的测试：就重要性而言，测试应该于设计和编码平起平坐，这就要求项目重视测试并保障这一过程的质量&lt;/li&gt;
&lt;li&gt;回归测试：要保证每次回归测试都&lt;strong&gt;使用相同的测试用例&lt;/strong&gt;，随着产品的不断发展，会添加新的测试用例，但仍应保留旧的用例&lt;/li&gt;
&lt;li&gt;自动化测试：管理回归测试唯一可行的方法，就是将其变成一个自动化的过程&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1-3-3-保留测试记录&quot;&gt;&lt;a href=&quot;#1-3-3-保留测试记录&quot; class=&quot;headerlink&quot; title=&quot;1.3.3 保留测试记录&quot;&gt;&lt;/a&gt;1.3.3 保留测试记录&lt;/h3&gt;&lt;p&gt;为了确定所做的修改对整个项目的影响，通常可以收集这些数据以供参考：缺陷的管理方面描述（报告日期、人员、描述、修正错误日期等等），问题的完整描述，复现错误所需要的步骤，绕过该问题的建议，相关的缺陷，问题的严重程度，缺陷根源（需求、设计、编码还是测试），对编码缺陷的分类，修正错误所改变的类和子程序，缺陷所影响的代码行数，查找该错误所花的小时数，修正错误所花费的小时数等等。&lt;/p&gt;
&lt;h1 id=&quot;2-重构&quot;&gt;&lt;a href=&quot;#2-重构&quot; class=&quot;headerlink&quot; title=&quot;2. 重构&quot;&gt;&lt;/a&gt;2. 重构&lt;/h1&gt;&lt;h2 id=&quot;2-1-软件的演化与重构&quot;&gt;&lt;a href=&quot;#2-1-软件的演化与重构&quot; class=&quot;headerlink&quot; title=&quot;2.1 软件的演化与重构&quot;&gt;&lt;/a&gt;2.1 软件的演化与重构&lt;/h2&gt;&lt;p&gt;软件演化就像生物进化一样，有些突变对物种是有益的，另外一些则是有害的。区分软件演化类型的关键，就是程序的质量在这一过程中是提高了还是降低了；第二个标准是演化是源于程序构建过程还是维护过程中的修改，毕竟构建时由最初开发人员完成，没有什么修正压力，而维护时的修改则需要面对已发布产品和用户的压力。&lt;/p&gt;
&lt;p&gt;软件演化是无法避免且具有重要意义的现象。&lt;strong&gt;当你有机会或迫不得已需要对代码进行改变时，就努力对代码进行改进（重构），这样未来在开发中调整就会更容易。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;重构的理由有许多，如代码重复，冗长的子程序，过长或嵌套过深的循环，内聚性太差的类等等。无论是哪种情况，代码都会有一些警告信号，这就是所谓的代码的“坏味道”。关于重构的更详尽的理由在专门讲重构的书都列得非常清楚，此处不再赘述。&lt;/p&gt;
&lt;h2 id=&quot;2-2-各层级的重构&quot;&gt;&lt;a href=&quot;#2-2-各层级的重构&quot; class=&quot;headerlink&quot; title=&quot;2.2 各层级的重构&quot;&gt;&lt;/a&gt;2.2 各层级的重构&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;数据级&lt;ul&gt;
&lt;li&gt;用具名常量替代神秘数值&lt;/li&gt;
&lt;li&gt;使变量的名字更为清晰且传递更多信息&lt;/li&gt;
&lt;li&gt;用函数来代替表达式&lt;/li&gt;
&lt;li&gt;用多个单一用途变量代替某个多用途变量&lt;/li&gt;
&lt;li&gt;将一组类型码转化为类或枚举类型&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;语句级&lt;ul&gt;
&lt;li&gt;将复杂布尔表达式转换成命名准确的布尔函数&lt;/li&gt;
&lt;li&gt;合并条件语句不同部分中的重复代码片段&lt;/li&gt;
&lt;li&gt;使用break或return而不是循环控制变量&lt;/li&gt;
&lt;li&gt;在嵌套的if-else语句中一旦知道答案就立即返回，而不是去赋一个返回值&lt;/li&gt;
&lt;li&gt;用多态来替代条件语句（尤其是重复的case语句）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;子程序级&lt;ul&gt;
&lt;li&gt;将冗长的子程序转换为类&lt;/li&gt;
&lt;li&gt;将查询操作从修改操作中独立出来&lt;/li&gt;
&lt;li&gt;合并相似的子程序，通过参数区分它们的功能&lt;/li&gt;
&lt;li&gt;简化或去除无用的参数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;类实现&lt;ul&gt;
&lt;li&gt;如果一组派生类的差别仅仅是虚函数返回的常量不同，应用数据初始化替代虚函数&lt;/li&gt;
&lt;li&gt;整理成员函数或成员数据的位置&lt;/li&gt;
&lt;li&gt;将特殊代码提取为派生类，将相似的代码结合起来放置到基类中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;类接口&lt;ul&gt;
&lt;li&gt;将包含多个不同功能的类进行拆分&lt;/li&gt;
&lt;li&gt;删除无所事事的类&lt;/li&gt;
&lt;li&gt;去除多余的中间者调用&lt;/li&gt;
&lt;li&gt;对暴露在外的成员变量进行封装&lt;/li&gt;
&lt;li&gt;对于不能修改的类成员，删除相关的Set()成员函数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;系统级&lt;ul&gt;
&lt;li&gt;为无法控制的数据创建明确的索引源：例如GUI控件中维护的数据无法方便或一致地访问，可以创建一个类来映射其中的数据，并将此类作为该数据的明确来源&lt;/li&gt;
&lt;li&gt;基于类型码创建对象时，用工厂模式而不是简单地实例化对象&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-3-安全重构的方法&quot;&gt;&lt;a href=&quot;#2-3-安全重构的方法&quot; class=&quot;headerlink&quot; title=&quot;2.3 安全重构的方法&quot;&gt;&lt;/a&gt;2.3 安全重构的方法&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;在开始重构之前，保存初始代码&lt;/li&gt;
&lt;li&gt;缩小重构的步伐，不要一次性大动干戈&lt;/li&gt;
&lt;li&gt;同一时间只做一项重构&lt;/li&gt;
&lt;li&gt;把要做的事情列出来，并记录下在重构过程中发现的需要进行的另外一项重构任务&lt;/li&gt;
&lt;li&gt;增加测试用例，重构完后重新测试&lt;/li&gt;
&lt;li&gt;根据重构风险级别来调整重构方法：如果是高风险的重构，务必做好测试工作，请其他人来检查重构工作甚至采用结对编程&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;重构是一剂良药，但也有被滥用的可能性，因此&lt;strong&gt;不要把重构当做先写后改的代名词&lt;/strong&gt;，也要&lt;strong&gt;避免用重构代替重写&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;关于重构的时机，如果拿捏不准，可以考虑这些建议：在增加子程序和类，在修补缺陷的时候进行重构；关注易于出错和高度复杂的模块；在维护环境下改善你手中正在处理的代码；定义清楚干净代码和拙劣代码之间的边界，然后尝试把代码一部分一部分移到理想的一边。&lt;/p&gt;
&lt;p&gt;参考文献：电子工业出版社《代码大全（第2版）》第22、24章&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;测试可以由开发人员或专门的测试人员进行。按层级分，测试可以分为单元测试、组件测试、继承测试、回归测试、系统测试；按是否了解对象内部工作机制分，测试可以分为黑盒测试和白盒测试。本文关注的是开发人员所进行的白盒测试。重构是“在不改变软件外部行为的前提下，对其内部结构进行改变，使之更容易理解并便于修改”的过程。本文将讲述软件演化以及重构的一些理念。&lt;/p&gt;
&lt;p&gt;测试和重构都是非常大的话题，大到足以各用一本经典著作来阐述，如&lt;a href=&quot;https://book.douban.com/subject/1801050/&quot;&gt;《软件测试》&lt;/a&gt;和&lt;a href=&quot;https://book.douban.com/subject/4262627/&quot;&gt;《重构：改善既有代码的设计》&lt;/a&gt;。因此本文也仅是记录一些要点，如果要深入了解，还是要阅读相关的书籍为好。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="综合" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/"/>
    
      <category term="软件工程" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="软件构建" scheme="http://raytaylorlin.com/tags/%E8%BD%AF%E4%BB%B6%E6%9E%84%E5%BB%BA/"/>
    
      <category term="软件工程" scheme="http://raytaylorlin.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="代码大全" scheme="http://raytaylorlin.com/tags/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>软件构建（九）——协同构建与调试</title>
    <link href="http://raytaylorlin.com/tech/complex/software/software-construction-9/"/>
    <id>http://raytaylorlin.com/tech/complex/software/software-construction-9/</id>
    <published>2016-04-26T04:59:05.000Z</published>
    <updated>2016-05-12T13:14:41.223Z</updated>
    
    <content type="html">&lt;p&gt;所有的协同构建技术都试图通过这样或那样的途径，将展示你工作的过程正式化，以便把错误暴露出来。软件构建不可避免地都会伴随着调试，在一些项目中，调试可能占到整个开发周期的50%。对很多程序员来说，调试是程序设计中最为困难的部分。本文的前半部分将介绍协同构建的一些实践方法，后半部分将介绍一些科学的调试手段以节省更多精力。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-协同构建&quot;&gt;&lt;a href=&quot;#1-协同构建&quot; class=&quot;headerlink&quot; title=&quot;1. 协同构建&quot;&gt;&lt;/a&gt;1. 协同构建&lt;/h1&gt;&lt;h2 id=&quot;1-1-协同开发实践概要&quot;&gt;&lt;a href=&quot;#1-1-协同开发实践概要&quot; class=&quot;headerlink&quot; title=&quot;1.1 协同开发实践概要&quot;&gt;&lt;/a&gt;1.1 协同开发实践概要&lt;/h2&gt;&lt;p&gt;“协同构建”包括结对编程、正式检查、非正式技术复查、文档阅读，以及其他让开发人员共同承担创建代码及其他工作产品责任的技术。各种协同构建技术之间尽管存在着一些差异，但它们都基于一个相同的思想，那就是在工作中开发人员总会对某些错误点视而不见，而其他人不会有相同的盲点，所以开发人员让其他人来检查自己的工作是很有好处的。&lt;/p&gt;
&lt;p&gt;大量研究和数据表明，协同开发在捕获错误方面比测试的效能更高，而且让人们意识到他们的工作会被复查，这样他们会小心谨慎地检查自己的工作。此外，协同构建有利于传授公司文化以及编程专业知识，复查是老人培养新人人以提高其代码质量的好方法。&lt;/p&gt;
&lt;h2 id=&quot;1-2-结对编程&quot;&gt;&lt;a href=&quot;#1-2-结对编程&quot; class=&quot;headerlink&quot; title=&quot;1.2 结对编程&quot;&gt;&lt;/a&gt;1.2 结对编程&lt;/h2&gt;&lt;p&gt;在进行结对编程的时候，一位程序员敲代码，另外一位注意有没有出现错误，并考虑某些策略性的问题，例如代码的编写是否正确，正在编写的代码是否所需等。全程采用结对编程的成本可能比单人开发要高大约10%~25%，但开发周期大概会缩短45%。结对编程与单独开发相比，能够使人们在压力之下保持更好的状态，能够改善代码质量，缩短进度时间表等等。要从结对编程中获益，需要遵守以下几条准则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用编码规范来支持结对编程：应提前制定标准，避免两个人把时间浪费在争论代码风格上&lt;/li&gt;
&lt;li&gt;不要让结对编程变成旁观：不掌握键盘的那个人应该主动参与到编程当中，例如分析代码，提前思考接下来的代码应该做些什么，对设计进行评估，并对如何测试代码做出计划&lt;/li&gt;
&lt;li&gt;不要强迫在简单的问题上使用结对编程&lt;/li&gt;
&lt;li&gt;有规律地对结对人员和分配的工作任务进行轮换&lt;/li&gt;
&lt;li&gt;鼓励双方跟上对方的步伐&lt;/li&gt;
&lt;li&gt;确认两个人都能够看清楚显示器中的代码&lt;/li&gt;
&lt;li&gt;不要强迫程序员与自己关系紧张的人结对&lt;/li&gt;
&lt;li&gt;避免新手组合&lt;/li&gt;
&lt;li&gt;指定一个协调工作分配的组长，其对结果和项目外其他人的联系负责&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-3-正式检查&quot;&gt;&lt;a href=&quot;#1-3-正式检查&quot; class=&quot;headerlink&quot; title=&quot;1.3 正式检查&quot;&gt;&lt;/a&gt;1.3 正式检查&lt;/h2&gt;&lt;p&gt;正式检查（详查）是一种特殊的复查，与普通复查的区别是：详查关注的是复查者过去所遇到的问题，专注于缺陷的检测而非修正；复查人员要为详查会议做好预先准备，并且带来一份他们所发现的己知问题的列表；详查的主持人不是被检查产品的作者，且应该已经接受过主持详查会议方面的培训；只有在参与者都做好充分准备之后才会召开详查会议，每个参与者都赋予了明确的角色（主持人、代码作者、详查评论员、记录员、只了解结果的经理）；每次详查所收集的数据都会被应用到以后的详查当中，以便对详查进行改进；高层管理人员不参加详查会议，除非你们正在详查一个项目的计划，或者其他管理方面的资料，但技术负责人可能参加。&lt;/p&gt;
&lt;p&gt;详查由以下几个阶段组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;计划：作者提交设计或代码，主持人决定参与的人员和时间地点&lt;/li&gt;
&lt;li&gt;概述：当评论员不熟悉他们所要详查的项目时，作者可以花大约一个小时来描述一下这些设计或代码的技术背景&lt;/li&gt;
&lt;li&gt;准备：每一个评论员独立地对设计或者代码进行详查，找出其中的错误。给评论员赋予特定视角或待详查场景，可以有效提高复查的效率&lt;/li&gt;
&lt;li&gt;详查会议：评论员阐述设计或阅读代码，记录员记录发现的错误。不要在开会的过程当中讨论解决方案，小组应该把注意力保持在识别缺陷上。详查速度，可以参考系统级代码每小时90行，应用级代码每小时500行&lt;/li&gt;
&lt;li&gt;详查报告：主持人总结报告，列出每个缺陷及其类型和严重级别&lt;/li&gt;
&lt;li&gt;返工：主持人将缺陷分配给作者修复&lt;/li&gt;
&lt;li&gt;跟进：主持人负责监督在详查过程中分配的返工任务&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于作者来说，详查的过程应该是正面的，所有参与者都是一个学习的过程。作者也应该预料到他会听到对某些缺陷的批评，不应该试图为正在被检查的工作辩护，在复查之后，作者可以独自对每一个问题进行思考，判断它是否真的是一个缺陷。&lt;/p&gt;
&lt;h2 id=&quot;1-4-走查&quot;&gt;&lt;a href=&quot;#1-4-走查&quot; class=&quot;headerlink&quot; title=&quot;1.4 走查&quot;&gt;&lt;/a&gt;1.4 走查&lt;/h2&gt;&lt;p&gt;走查是一种很流行的&lt;strong&gt;非正式&lt;/strong&gt;复查方式，同时也是一种宽松的定义。既然是一种较为“随意”的复查形式，其找出程序的错误概率也相对较低，而当项目的压力增加的时候，走查更是变得几乎不可能。与走查相比，详查在消除错误方面似乎更有效。但如果你有个很大的复查团队，或者由其他组织的评审员参与，或许走查会更适合。&lt;/p&gt;
&lt;h1 id=&quot;2-调试&quot;&gt;&lt;a href=&quot;#2-调试&quot; class=&quot;headerlink&quot; title=&quot;2. 调试&quot;&gt;&lt;/a&gt;2. 调试&lt;/h1&gt;&lt;p&gt;调试本身并不是改进代码质量的方法，而是诊断代码缺陷的一种方法。软件的质量必须从开始逐步建立：开发高质量软件产品的最佳途径是精确描述需求，完善设计，并使用高质量的代码编写规范。&lt;strong&gt;调试只是迫不得已时采用的手段。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;程序不可能没有缺陷，关键是掌握避免缺陷产生的方法，并从以往的缺陷中学习。程序员在调试过程中应该理解正在编写的程序，明确犯了哪种类型的错误，从代码阅读者的角度分析代码质量，审视自己解决问题和修正缺陷的方法。&lt;/p&gt;
&lt;h2 id=&quot;2-1-效率低下的调试万法&quot;&gt;&lt;a href=&quot;#2-1-效率低下的调试万法&quot; class=&quot;headerlink&quot; title=&quot;2.1 效率低下的调试万法&quot;&gt;&lt;/a&gt;2.1 效率低下的调试万法&lt;/h2&gt;&lt;p&gt;下面列举的是调试的魔鬼指南，注意这些是&lt;strong&gt;让程序员们受尽折磨的传统的调试方法，应该引以为戒&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;凭猜测找出缺陷：把print语句随机地散布在程序中，凭输出来确定缺陷到底在哪里。如果通过print语句还是不能找到缺陷，那就在程序中修改点什么，知道有些东西好像能干活了&lt;/li&gt;
&lt;li&gt;不要把时间浪费在理解问题上：要解决它们并不需要彻底弄懂程序，只要找出问题就行了&lt;/li&gt;
&lt;li&gt;用最唾手可得的方式修正错误&lt;/li&gt;
&lt;li&gt;迷信式调试：也许你会遇到这样一种程序员，他们经常碰到各种奇怪问题——不听话的机器，奇怪的编译器错误，月圆时才会出现的编程语言的隐藏缺陷，失效的数据……&lt;strong&gt;要知道，如果你写的程序出了问题，那就是你的原因，不是计算机的&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-2-科学的调试方法&quot;&gt;&lt;a href=&quot;#2-2-科学的调试方法&quot; class=&quot;headerlink&quot; title=&quot;2.2 科学的调试方法&quot;&gt;&lt;/a&gt;2.2 科学的调试方法&lt;/h2&gt;&lt;p&gt;下面给出一种寻找缺陷的有效方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将错误状态稳定下来&lt;/li&gt;
&lt;li&gt;确定错误的来源&lt;br&gt; a. 收集产生缺陷的相关数据&lt;br&gt; b. 分析所收集的数据，并构造对缺陷的假设&lt;br&gt; c. 确定怎样去证实或证伪这个假设，可以对程序进行测试或是通过检查代码&lt;br&gt; d. 按照2(c)确定的方法对假设做出最终结论&lt;/li&gt;
&lt;li&gt;修补缺陷&lt;/li&gt;
&lt;li&gt;对所修补的地方进行测试&lt;/li&gt;
&lt;li&gt;查找是否还有类似的错误&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果一个错误无法重现，这通常会是一个变量初始化错误，或者是一个同时间有关的问题，或者是悬空指针问题。要将一个错误的发生稳定下来，要构造一个尽可能简单的测试用例，并假定一些产生错误的因素，用测试用例一个一个排除掉无关的因素，不断缩小错误因素的范围。一些寻找错误的小建议：在构造假设时考虑所有的可用数据，提炼产生错误的测试用例，采用多种不同的方法重现错误，用更多的数据生成更多的假设，将代码分而治之缩小嫌疑代码的范围，对之前出现过缺陷的代码和最近修改过的代码保持警惕。&lt;/p&gt;
&lt;p&gt;在必要时，也可以采用蛮力调试。人们往往出于投机心理都宁愿去用一种有可能在五分钟内发现缺陷的高风险方法，也不愿意为某种保证能找出缺陷的方法花上半个小时。实际上当你被这种心理绕进去时，有可能几个小时甚至几天就这样浪费了。如果打算通过捷径摘取胜利果实，那么应该为尝试捷径的时间设置一个上限。&lt;strong&gt;如果耗时超过了上限，就应老老实实地承认问题比你最初想象的要更加难于分析，应该转到蛮力（彻查代码甚至重写）的路上重新开始。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于语法错误，虽然编译器现在做得越来越好，这个问题不应成为一个很大的障碍，但也应该注意一些编译器的坑，例如：不要过分信任编译器信息中的行号，有时问题可能出在那一行的前后；不要迷信编译器给出的错误信息；不要轻信编译器的第二条信息，如果无法迅速找出第二条或第三条错误信息的源头，先把第一条处理了再重新编译看看。&lt;/p&gt;
&lt;h2 id=&quot;2-3-修正缺陷&quot;&gt;&lt;a href=&quot;#2-3-修正缺陷&quot; class=&quot;headerlink&quot; title=&quot;2.3 修正缺陷&quot;&gt;&lt;/a&gt;2.3 修正缺陷&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;在动手之前先要真正理解问题&lt;/li&gt;
&lt;li&gt;理解程序本身，而不仅仅是问题&lt;/li&gt;
&lt;li&gt;花点时间编写测试用例，验证对错误的假设&lt;/li&gt;
&lt;li&gt;修改错误后不要急着提交，可以先放松一下，等到充分考虑了这样的修改完全无误后再提交&lt;/li&gt;
&lt;li&gt;保存最初的源代码，以方便对照&lt;/li&gt;
&lt;li&gt;治本，而不是治标，不要用特例去绕过程序的错误&lt;/li&gt;
&lt;li&gt;修改代码时一定要有恰当的理由&lt;/li&gt;
&lt;li&gt;一次只做一个改动&lt;/li&gt;
&lt;li&gt;检查自己的改动并增加能暴露问题的单元测试&lt;/li&gt;
&lt;li&gt;修正缺陷后，搜索类似的缺陷&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-4-调试工具简介&quot;&gt;&lt;a href=&quot;#2-4-调试工具简介&quot; class=&quot;headerlink&quot; title=&quot;2.4 调试工具简介&quot;&gt;&lt;/a&gt;2.4 调试工具简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;源代码比较工具：如&lt;a href=&quot;http://linux.die.net/man/1/diff&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;diff&lt;/a&gt;、&lt;a href=&quot;http://www.scootersoftware.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Beyond Compare&lt;/a&gt;等，常用于比较新旧代码的差异以唤醒记忆&lt;/li&gt;
&lt;li&gt;编译器&lt;ul&gt;
&lt;li&gt;将编译器的警告级别设置为最高级，尽可能不放过任何一个警告&lt;/li&gt;
&lt;li&gt;用对待错误的态度来处理警告：一些编译器允许将警告当做错误报告&lt;/li&gt;
&lt;li&gt;在项目组范围内使用统一的编译设置&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;增强的语法检查和逻辑检查：如各种语言的lint工具（一般许多高级的编辑器都有对应插件）&lt;/li&gt;
&lt;li&gt;性能分析器：有时花上几分钟来研究某个程序的性能分析结果，或许可以让你发现一些令人惊奇的隐藏错误&lt;/li&gt;
&lt;li&gt;测试框架/脚手架：各种语言都有对应的测试框架&lt;/li&gt;
&lt;li&gt;调试器：利用好编译器可能具有的以下功能：&lt;ul&gt;
&lt;li&gt;设置断点，某行代码执行n次或变量被赋予特定值时中断，监控变量，逐行运行代码，记录特定语句的执行&lt;/li&gt;
&lt;li&gt;检查结构化和动态分配的数据，智能地适应用户定义的数据类型，在运行过程中修改值并继续运行&lt;/li&gt;
&lt;li&gt;查看高级语言生成的汇编代码，查看调用链&lt;/li&gt;
&lt;li&gt;针对每个单独的程序保存调试参数（如断点、监视变量等）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考文献：电子工业出版社《代码大全（第2版）》第21、23章&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;所有的协同构建技术都试图通过这样或那样的途径，将展示你工作的过程正式化，以便把错误暴露出来。软件构建不可避免地都会伴随着调试，在一些项目中，调试可能占到整个开发周期的50%。对很多程序员来说，调试是程序设计中最为困难的部分。本文的前半部分将介绍协同构建的一些实践方法，后半部分将介绍一些科学的调试手段以节省更多精力。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="综合" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/"/>
    
      <category term="软件工程" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="软件构建" scheme="http://raytaylorlin.com/tags/%E8%BD%AF%E4%BB%B6%E6%9E%84%E5%BB%BA/"/>
    
      <category term="软件工程" scheme="http://raytaylorlin.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="代码大全" scheme="http://raytaylorlin.com/tags/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>软件构建（八）——表驱动法与一般控制问题</title>
    <link href="http://raytaylorlin.com/tech/complex/software/software-construction-8/"/>
    <id>http://raytaylorlin.com/tech/complex/software/software-construction-8/</id>
    <published>2016-04-24T14:24:03.000Z</published>
    <updated>2016-05-12T13:14:38.160Z</updated>
    
    <content type="html">&lt;p&gt;表驱动法是一种编程模式——从表里面查找信息而不使用逻辑语句（if和case）。事实上，凡是能通过逻辑语句来选择的事物，都可以通过查表来选择。本文将介绍直接访问表、索引访问表和阶梯访问表三种常见的表驱动法。最后，本文将记录一些控制问题（如布尔表达式的使用、空语句、深层嵌套问题等等）上的使用原则，这一部分内容比较简单而且与前面的章节有一些重叠，因此将快速带过。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-表驱动法&quot;&gt;&lt;a href=&quot;#1-表驱动法&quot; class=&quot;headerlink&quot; title=&quot;1. 表驱动法&quot;&gt;&lt;/a&gt;1. 表驱动法&lt;/h1&gt;&lt;p&gt;例如当使用复杂的if-elseif逻辑对字符分类时，可以用一个查询表（数组或字典）来代替查询，当然，查询表要事先创建好。&lt;/p&gt;
&lt;h2 id=&quot;1-1-直接访问表&quot;&gt;&lt;a href=&quot;#1-1-直接访问表&quot; class=&quot;headerlink&quot; title=&quot;1.1 直接访问表&quot;&gt;&lt;/a&gt;1.1 直接访问表&lt;/h2&gt;&lt;p&gt;使用直接访问法的例子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个月中的天数：建立含12个整数的数组，把月份当下标查询&lt;/li&gt;
&lt;li&gt;保险费率：费率随年龄、性别、婚姻状况等变化，可以以这几个维度建立多维数组，从外部读入数据&lt;/li&gt;
&lt;li&gt;灵活的消息格式：假定一份文件中有几百条消息，消息种类约20种，每种消息都有若干字段。可以把消息种类构造为查询表，并把每种字段对应的行为用多态实现，这样可以大幅简化对消息种类和字段进行判断&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用直接访问法查表时，关键是能直接得到查询的键值。有时像保险费率中的年龄，可能小于18岁，18-65岁，超过65岁是三种不一样的费率，这时可以使用以下这些方法将其转换为可查询的键值：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;复制信息：查询表填充18个18岁以下的费率，47个18-65岁的费率，以此类推，缺点是复制的冗余会浪费空间，而且表中存在错误的可能性也会增加&lt;/li&gt;
&lt;li&gt;转换键值：将一个区间通过某个函数转换为一个值，例如&lt;code&gt;max(min(66, age), 17)&lt;/code&gt;可以生成一个位于17到66之间的键值，这种方法要精心设计转换函数&lt;/li&gt;
&lt;li&gt;把键值转换提取成独立子程序：上面的转换键值方法其实不太适用于年龄转换这种复杂情况，编写一个&lt;code&gt;KeyFromAge()&lt;/code&gt;方法里面写几个if判断将年龄转换为键值更加清晰&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-2-索引访问表&quot;&gt;&lt;a href=&quot;#1-2-索引访问表&quot; class=&quot;headerlink&quot; title=&quot;1.2 索引访问表&quot;&gt;&lt;/a&gt;1.2 索引访问表&lt;/h2&gt;&lt;p&gt;使用索引的时候，先用一个基本类型的数据从一张索引表中查出一个键值，然后再用这一键值查出你感兴趣的主数据。下图解释了这种技术的具体原理：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7d9rl0.com1.z0.glb.clouddn.com/image/software/%E7%B4%A2%E5%BC%95%E8%AE%BF%E9%97%AE%E8%A1%A8%E7%9A%84%E5%8E%9F%E7%90%86.jpg&quot; alt=&quot;索引访问表的原理&quot;&gt;&lt;/p&gt;
&lt;p&gt;索引访问技术有几个主要优点：首先，如果主查询表中的每一条记录都很大，那么创建一个浪费了很多空间的&lt;strong&gt;索引数组&lt;/strong&gt;所用的空间，就要比创建一个浪费了很多空间的&lt;strong&gt;主查询表&lt;/strong&gt;所用的空间小得多；其次，即使用了索引以后没有节省内存空间，操作位于索引中的记录有时也要比操作位于主表中的记录更方便廉价；最后，索引访问技术在可维护性上所具有的普遍优点，编写到表里面的数据比嵌入代码中的数据更容易维护。&lt;/p&gt;
&lt;h2 id=&quot;1-3-阶梯访问表&quot;&gt;&lt;a href=&quot;#1-3-阶梯访问表&quot; class=&quot;headerlink&quot; title=&quot;1.3 阶梯访问表&quot;&gt;&lt;/a&gt;1.3 阶梯访问表&lt;/h2&gt;&lt;p&gt;阶梯结构的基本想法是，表中的记录对于不同的数据范围有效，而不是对不同的数据点有效。最常见的例子是按分数段（浮点数）评定ABCDF等级。由于是浮点数划分范围，用数据转换函数或索引都不适合。为了使用阶梯方法，要把每一区间的上限写入一张表里，然后写一个循环，按照各区间的上限来检查分数，当分数第一次超过某个区间的上限时，就知道相应的等级了。除此之外，还可以将这种方法应用在概率分布的统计（这在游戏中的抽奖相当常见），这种无规则分布的数据是不可能用一个函数把它们整齐地转换成表键值的。使用阶梯访问表需要注意一些细节：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;留心端点：充分考虑每一个阶梯区间的上界，不要把&amp;lt;误用为&amp;lt;=&lt;/li&gt;
&lt;li&gt;考虑用“准”二分查找取代顺序查找&lt;/li&gt;
&lt;li&gt;考虑用索引访问采取代阶梯技术：如果执行速度很重要，应考虑用空间换时间的索引表技术&lt;/li&gt;
&lt;li&gt;把阶梯表查询操作提取成单独的子程序&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;2-一般控制问题&quot;&gt;&lt;a href=&quot;#2-一般控制问题&quot; class=&quot;headerlink&quot; title=&quot;2. 一般控制问题&quot;&gt;&lt;/a&gt;2. 一般控制问题&lt;/h1&gt;&lt;h2 id=&quot;2-1-布尔表达式的使用&quot;&gt;&lt;a href=&quot;#2-1-布尔表达式的使用&quot; class=&quot;headerlink&quot; title=&quot;2.1 布尔表达式的使用&quot;&gt;&lt;/a&gt;2.1 布尔表达式的使用&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;用true和false做布尔判断，而不要用0和1等数值&lt;/li&gt;
&lt;li&gt;隐式地比较布尔值：即使用&lt;code&gt;while (!done)&lt;/code&gt;而不要写成&lt;code&gt;while (done == false)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;简化复杂的表达式：可以通过拆分复杂的判断并引入新的布尔变量，把复杂的表达式提取成布尔函数，用决策表代替复杂的条件等方法&lt;/li&gt;
&lt;li&gt;编写肯定形式的布尔表达式：在变量命名上尽量采用肯定形式，if语句的布尔表达式尽量&lt;strong&gt;不用not形式&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;用&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%BE%B7%E6%91%A9%E6%A0%B9%E5%AE%9A%E5%BE%8B&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;德摩根定理&lt;/a&gt;简化否定的布尔判断&lt;/li&gt;
&lt;li&gt;用括号便布尔表达式更清晰&lt;/li&gt;
&lt;li&gt;理解布尔表达式是如何求值的：主要是要充分理解所用编程语言中&lt;strong&gt;“短路求值”&lt;/strong&gt;的用法&lt;/li&gt;
&lt;li&gt;按照数轴的顺序编写数值比较表达式&lt;/li&gt;
&lt;li&gt;与0比较时应该：隐式地比较逻辑变量，显式地把数字和0相比较，显式地把指针与NULL相比较，在C语言中显示地比较字符和&lt;code&gt;\0&lt;/code&gt;终止符&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-2-空语句&quot;&gt;&lt;a href=&quot;#2-2-空语句&quot; class=&quot;headerlink&quot; title=&quot;2.2 空语句&quot;&gt;&lt;/a&gt;2.2 空语句&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;万非得以使用空语句时，要突出这种用法：空语句并不多见，应该让其独占一行，加以缩进，用成对的花括号括住空语句以表强调&lt;/li&gt;
&lt;li&gt;为主语句创建一个DoNothing()预处理宏或者内联函数&lt;/li&gt;
&lt;li&gt;考虑如果换用一个非空的循环体，是否会让代码更清晰&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-3-深层嵌套问题&quot;&gt;&lt;a href=&quot;#2-3-深层嵌套问题&quot; class=&quot;headerlink&quot; title=&quot;2.3 深层嵌套问题&quot;&gt;&lt;/a&gt;2.3 深层嵌套问题&lt;/h2&gt;&lt;p&gt;过分深层的缩进（嵌套）是产生混乱代码的罪魁祸首之一。有研究表明，应避免使用超过3到4层的嵌套。下面给出一些用于避免深层嵌套的方法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过重复检测条件中的某一部分来简化嵌套的if语句&lt;/li&gt;
&lt;li&gt;在循环中用break块来简化嵌套if&lt;/li&gt;
&lt;li&gt;把嵌套if转换成一组if-else-if语句或case语句&lt;/li&gt;
&lt;li&gt;把深层嵌套的代码抽取出来放进单独的子程序&lt;/li&gt;
&lt;li&gt;对于复杂的case语句，可以考虑面向对象的手段来简化&lt;/li&gt;
&lt;li&gt;重新设计深层嵌套的代码&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-4-控制结构与复杂度&quot;&gt;&lt;a href=&quot;#2-4-控制结构与复杂度&quot; class=&quot;headerlink&quot; title=&quot;2.4 控制结构与复杂度&quot;&gt;&lt;/a&gt;2.4 控制结构与复杂度&lt;/h2&gt;&lt;p&gt;降低软件复杂度首先要知道如何度量复杂度，其中最著名的方法是计算子程序中“决策点”的数量：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从1开始，一直往下筒骨哦程序&lt;/li&gt;
&lt;li&gt;一旦遇到&lt;code&gt;if&lt;/code&gt;、&lt;code&gt;while&lt;/code&gt;、&lt;code&gt;repeat&lt;/code&gt;、&lt;code&gt;for&lt;/code&gt;、&lt;code&gt;and&lt;/code&gt;、&lt;code&gt;or&lt;/code&gt;这些关键字或同类的词，就加1&lt;/li&gt;
&lt;li&gt;给case语句中每一种情况都加1&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过下面的评分来分析子程序的复杂度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0-5：子程序可能还不错&lt;/li&gt;
&lt;li&gt;6-10：得想办法简化子程序了&lt;/li&gt;
&lt;li&gt;10+：把子程序的某一部分拆分成另一个子程序并调用它&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;把子程序的一部分提取成另一个子程序，不会降低整个程序的复杂度，只是把决策点移到其他地方。但是这样做可以降低你在同一时间必须关注的复杂度水平。由于重点是要降低你需要在头脑中同时考虑的项目的数量，所以降低一个给定子程序的复杂度是有价值的。10个决策点的上限并不是绝对的。应该把决策点的数量当作一个警示，该警示说明某个子程序可能需要重新设计了，不要死守决策点上限这个规则。&lt;/p&gt;
&lt;p&gt;参考文献：电子工业出版社《代码大全（第2版）》第18、19章&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;表驱动法是一种编程模式——从表里面查找信息而不使用逻辑语句（if和case）。事实上，凡是能通过逻辑语句来选择的事物，都可以通过查表来选择。本文将介绍直接访问表、索引访问表和阶梯访问表三种常见的表驱动法。最后，本文将记录一些控制问题（如布尔表达式的使用、空语句、深层嵌套问题等等）上的使用原则，这一部分内容比较简单而且与前面的章节有一些重叠，因此将快速带过。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="综合" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/"/>
    
      <category term="软件工程" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="软件构建" scheme="http://raytaylorlin.com/tags/%E8%BD%AF%E4%BB%B6%E6%9E%84%E5%BB%BA/"/>
    
      <category term="软件工程" scheme="http://raytaylorlin.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="代码大全" scheme="http://raytaylorlin.com/tags/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>软件构建（七）——防御式编程</title>
    <link href="http://raytaylorlin.com/tech/complex/software/software-construction-7/"/>
    <id>http://raytaylorlin.com/tech/complex/software/software-construction-7/</id>
    <published>2016-04-20T09:28:57.000Z</published>
    <updated>2016-05-12T13:14:34.788Z</updated>
    
    <content type="html">&lt;p&gt;防御式编程这一概念来自防御式驾驶。在防御式驾驶中要建立这样一种思维，那就是你永远也不能确定另一位司机将要做什么。这样才能确保在其他人做出危险动作时你也不会受到伤害。你要承担起保护自己的责任，哪怕是其他司机犯的错误。本文将讲述如何面对严酷的非法数据的世界、在遇到“绝不会发生”的事件以及其他程序员犯下的错误时保护你自己。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-防御式编程&quot;&gt;&lt;a href=&quot;#1-防御式编程&quot; class=&quot;headerlink&quot; title=&quot;1. 防御式编程&quot;&gt;&lt;/a&gt;1. 防御式编程&lt;/h1&gt;&lt;p&gt;防御式编程的主要思想是：子程序应该不因传入错误数据而被破坏，哪怕是由其他子程序产生的错误数据。更一般地说，其核心想法是要承认程序都会有问题，都需要被修改。防御式编码的最佳方式就是在一开始不要在代码中引入错误。使用途代式设计、编码前先写伪代码、写代码前先写测试用例、低层设计检查等活动，都有助于防止引入错误。因此，要在防御式编程之前优先运用这些技术。&lt;/p&gt;
&lt;h2 id=&quot;1-1-保护程序免遭非法输入数据的破坏&quot;&gt;&lt;a href=&quot;#1-1-保护程序免遭非法输入数据的破坏&quot; class=&quot;headerlink&quot; title=&quot;1.1 保护程序免遭非法输入数据的破坏&quot;&gt;&lt;/a&gt;1.1 保护程序免遭非法输入数据的破坏&lt;/h2&gt;&lt;p&gt;对已形成产品的软件而言，应该做到“垃圾进，什么都不出”、“进来垃圾，出去是出错提示”或“不许垃圾进来”。通常有三种方法来处理进来垃圾的情况。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;检查所有来源于外部的数据的值：检查从文件、用户、网络或其他外部接口中获取的数据&lt;/li&gt;
&lt;li&gt;检查子程序所有输入参数的值&lt;/li&gt;
&lt;li&gt;决定如何处理错误的输入数据&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-2-使用断言（assert）&quot;&gt;&lt;a href=&quot;#1-2-使用断言（assert）&quot; class=&quot;headerlink&quot; title=&quot;1.2 使用断言（assert）&quot;&gt;&lt;/a&gt;1.2 使用断言（assert）&lt;/h2&gt;&lt;p&gt;断言可以用于在代码中说明各种假定，澄清各种不希望的情形。但通常断言只是在开发阶段用于帮助查清相互矛盾的假定、预料之外的情况以及传给子程序的错误数据等。在生成产品代码时，不要把断言编译进目标代码，以免降低性能和让用户看到断言报错信息。下面是关于使用断言的一些指导性建议。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用错误处理代码来处理预期会发生的状况，用断言来处理绝不应该发生的状况&lt;/li&gt;
&lt;li&gt;避免把需要执行的代码放到断言中：断言只检查变量的值，而不要在断言中&lt;strong&gt;运行&lt;/strong&gt;函数&lt;/li&gt;
&lt;li&gt;用断言来注解并验证前条件和后条件：所谓前条件是子程序或类的调用方代码在调用子程序或实例化对象之前要确保为真的属性，后条件是子程序或类在执行结束后要确保为真的属性&lt;/li&gt;
&lt;li&gt;对于高健壮性的代码，应该先使用断言再处理错误&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-3-错误处理技术&quot;&gt;&lt;a href=&quot;#1-3-错误处理技术&quot; class=&quot;headerlink&quot; title=&quot;1.3 错误处理技术&quot;&gt;&lt;/a&gt;1.3 错误处理技术&lt;/h2&gt;&lt;p&gt;有很多种解决方案用于处理那些预料中可能要发生的错误，下面列举一些可用的方案，实际中还经常把这些技术集合起来使用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;返回中立值：遇到错误时继续执行操作并简单地返回一个没有危害的数值。但对于关键领域（如医疗、航天），关闭程序也比显示错误的数据要好&lt;/li&gt;
&lt;li&gt;换用下一个正确的数据：如读数据库时发现一条损坏的记录，则继续读下去直到找到一条正确记录为止&lt;/li&gt;
&lt;li&gt;返回与前次相同的数据：在前后变化不会太大的场景使用，如游戏重绘使用上一帧的图像&lt;/li&gt;
&lt;li&gt;换用最接近的合法值：如小于0的值用0代替&lt;/li&gt;
&lt;li&gt;把警告信息记录到日志文件中&lt;/li&gt;
&lt;li&gt;返回一个错误码：简单地报告有错误发生，并信任调用链上游的某个子程序会处理该错误&lt;/li&gt;
&lt;li&gt;调用全局的错误处理子程序或对象&lt;/li&gt;
&lt;li&gt;当错误发生时显示出错消息以提高用户体验：采用这种做法时要考虑模块划分，多语言化，还要小心不要告诉系统的潜在攻击者太多东西&lt;/li&gt;
&lt;li&gt;用最妥当的方式在局部处理错误&lt;/li&gt;
&lt;li&gt;关闭程序：适用于人身安全攸关的应用程序&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-4-异常&quot;&gt;&lt;a href=&quot;#1-4-异常&quot; class=&quot;headerlink&quot; title=&quot;1.4 异常&quot;&gt;&lt;/a&gt;1.4 异常&lt;/h2&gt;&lt;p&gt;异常是把代码中的错误或异常事件传递给调用方代码的一种特殊手段。如果在一个子程序中遇到了预料之外的情况，但不知道该如何处理的话，它就可以抛出一个异常，就好比是举起双手说“我不知道该怎么处理它一一我真希望有谁知道该怎么办！” 一样。对出错的前因后果不甚了解的代码，可以把对控制权转交给系统中其他能更好地解释错误并采取措施的部分。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用异常通知程序的其他部分，发生了不可忽略的错误&lt;/li&gt;
&lt;li&gt;只在真正例外的情况下才抛出异常：仅在其他编码实践方法无法解决的情况下才使用异常&lt;/li&gt;
&lt;li&gt;不能用异常来推卸责任：如果某种的错误情况可以在局部处理，那就应该在局部处理掉它&lt;/li&gt;
&lt;li&gt;避免在构造函数和析构函数中抛出异常，除非你在同一地方把它们捕获&lt;/li&gt;
&lt;li&gt;在恰当的抽象层次抛出异常&lt;/li&gt;
&lt;li&gt;在异常消息中加入关于导致异常发生的全部信息&lt;/li&gt;
&lt;li&gt;避免使用空的catch语句：不要试图敷衍一个不知该如何处理的异常&lt;/li&gt;
&lt;li&gt;了解所所用函数库可能抛出的异常&lt;/li&gt;
&lt;li&gt;考虑创建一个集中的异常报告机制&lt;/li&gt;
&lt;li&gt;把项目中对异常的使用标准化&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-5-在架构上设置隔栏来隔离错误&quot;&gt;&lt;a href=&quot;#1-5-在架构上设置隔栏来隔离错误&quot; class=&quot;headerlink&quot; title=&quot;1.5 在架构上设置隔栏来隔离错误&quot;&gt;&lt;/a&gt;1.5 在架构上设置隔栏来隔离错误&lt;/h2&gt;&lt;p&gt;隔栏是一种容损策略，这与与船体外壳上装备隔离舱或者建筑物中的防火墙是类似的。以防御式编程为目的而进行隔离的一种方法，是把某些接口选定为“安全”区域的边界。对穿越安全区域边界的数据进行合法性校验，并当数据非法时做出敏锐的反映。可以把这种方法看做是手术室里使用的一种技术——任何东西在允许进入手术室之前都要经过消毒处理。因此手术室内的任何东西都可以认为是安全的。这其中最核心的设计决策是规定什么可以进入手术室，什么不可以进入，还有把手术室的门设在哪里。&lt;/p&gt;
&lt;h2 id=&quot;1-6-编写辅助调试的代码&quot;&gt;&lt;a href=&quot;#1-6-编写辅助调试的代码&quot; class=&quot;headerlink&quot; title=&quot;1.6 编写辅助调试的代码&quot;&gt;&lt;/a&gt;1.6 编写辅助调试的代码&lt;/h2&gt;&lt;p&gt;防御式编程的另一重要方面是使用辅助调试的代码，可以用于帮助快速地检测错误。一般人除非被某个错误反复纠缠，否则是懒得花精力去写这些辅助调试代码的，但如果越早引入辅助调试的代码，它能够提供的帮助也越大。还有一种“进攻时编程”的方式来处理异常情况：在开发阶段让错误显现出来，而在产品代码运行时能够自我修复——在开发时惨痛地失败，能让你在发布产品后不会败得太惨。&lt;/p&gt;
&lt;p&gt;如果使用了辅助调试的代码，那要做好清理的计划。例如使用类似ant或make这样的编译控制工具，或者使用内置的预处理器（如C/C++的&lt;code&gt;#define&lt;/code&gt;的，如果语言不支持预编译器就考虑用变通方法写自己的预处理器），在发布的产品代码中剔除掉调试代码。&lt;/p&gt;
&lt;p&gt;说了这么多防御式编程的手段，但是过度地防御也会引起问题，例如引入的额外代码增加了软件的复杂度，引入的代码也可能引入其他bug。因此，要考虑好什么地方你需要进行防御，然后因地制宜地调整你进行防御式编程的优先级。&lt;/p&gt;
&lt;p&gt;参考文献：电子工业出版社《代码大全（第2版）》第8章&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;防御式编程这一概念来自防御式驾驶。在防御式驾驶中要建立这样一种思维，那就是你永远也不能确定另一位司机将要做什么。这样才能确保在其他人做出危险动作时你也不会受到伤害。你要承担起保护自己的责任，哪怕是其他司机犯的错误。本文将讲述如何面对严酷的非法数据的世界、在遇到“绝不会发生”的事件以及其他程序员犯下的错误时保护你自己。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="综合" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/"/>
    
      <category term="软件工程" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="软件构建" scheme="http://raytaylorlin.com/tags/%E8%BD%AF%E4%BB%B6%E6%9E%84%E5%BB%BA/"/>
    
      <category term="软件工程" scheme="http://raytaylorlin.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="代码大全" scheme="http://raytaylorlin.com/tags/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>软件构建（六）——语句</title>
    <link href="http://raytaylorlin.com/tech/complex/software/software-construction-6/"/>
    <id>http://raytaylorlin.com/tech/complex/software/software-construction-6/</id>
    <published>2016-04-16T13:54:28.000Z</published>
    <updated>2016-05-12T13:14:31.519Z</updated>
    
    <content type="html">&lt;p&gt;本文开始从以数据为中心的编程观点转到以语句为中心的观点上。常用的编程语句有顺序、控制和循环三种基本结构，本文将依次介绍这三种基本结构的使用原则。最后，还总结了一些不太常见的控制结构，如子程序多处返回、递归、关于goto语句的讨论。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-顺序语句&quot;&gt;&lt;a href=&quot;#1-顺序语句&quot; class=&quot;headerlink&quot; title=&quot;1. 顺序语句&quot;&gt;&lt;/a&gt;1. 顺序语句&lt;/h1&gt;&lt;p&gt;下面分别举了一个有前后明确的运行顺序的没有明显顺序的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 有前后依赖关系的语句
data = ReadData();
results = CalculateResultsFromData(data);
PrintResults(results);

// 不太明显的前后依赖关系的语句
revenue.ComputeMonthly();
revenue.ComputeQuarterly();
revenue.ComputeAnnual();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果语句之间存在依赖关系，并且这些关系要求你把语句按照一定的顺序加以排列，那么应设法使得这些依赖关系变得明显。下面是一些用于组织语句的简单原则。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设法组织代码，使依赖关系变得非常明显&lt;/li&gt;
&lt;li&gt;使子程序名能突显依赖关系&lt;/li&gt;
&lt;li&gt;利用子程序参数明确显示依赖关系&lt;/li&gt;
&lt;li&gt;用注释对不清晰的依赖关系进行说明：首先要尽力写没有顺序依赖关系的代码&lt;/li&gt;
&lt;li&gt;用断言或者错误处理代码来检查依赖关系&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果语句没有明显依赖关系，那也应该按一定原则来排列语句，使得其可读性更好，其中的指导原则就是就近原则：把相关的操作放在一起。&lt;strong&gt;要让程序易于自上而下阅读，而不是让读者的目光跳来跳去。&lt;/strong&gt; 此外，还要把相关的语句组织在一起，一种检验的方法是，打印出要检验的程序代码（可以输出图片），然后把相关的语句画上框，如果方框彼此&lt;strong&gt;不交叠&lt;/strong&gt;则相关语句组织得好。&lt;/p&gt;
&lt;h1 id=&quot;2-条件语句&quot;&gt;&lt;a href=&quot;#2-条件语句&quot; class=&quot;headerlink&quot; title=&quot;2. 条件语句&quot;&gt;&lt;/a&gt;2. 条件语句&lt;/h1&gt;&lt;h2 id=&quot;2-1-if-else语句&quot;&gt;&lt;a href=&quot;#2-1-if-else语句&quot; class=&quot;headerlink&quot; title=&quot;2.1 if-else语句&quot;&gt;&lt;/a&gt;2.1 if-else语句&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;首先写正常代码路径，再处理不常见情况&lt;/li&gt;
&lt;li&gt;确保对于等量的分支是正确的：仔细考虑“&amp;gt;”“&amp;lt;”和“&amp;gt;=”“&amp;lt;=”的逻辑&lt;/li&gt;
&lt;li&gt;把正常情况的处理放在if后面而不要放在else后面&lt;/li&gt;
&lt;li&gt;不要在if分支执行空语句&lt;/li&gt;
&lt;li&gt;考虑else分支：考虑是否真的仅仅只需要一个if分支就可满足，除非原因显而易见，否则也应考虑用注释来解释空else分支是没有必要的&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-2-switch-case语句&quot;&gt;&lt;a href=&quot;#2-2-switch-case语句&quot; class=&quot;headerlink&quot; title=&quot;2.2 switch-case语句&quot;&gt;&lt;/a&gt;2.2 switch-case语句&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;为case选择最有效的排列方式：按字母数字顺序，或者把正常的情况撞在前面，或者按执行频率高低&lt;/li&gt;
&lt;li&gt;简化每种情况对应的操作：不要在case中堆一堆操作&lt;/li&gt;
&lt;li&gt;不要为了使用case语句而刻意制造一个变量&lt;/li&gt;
&lt;li&gt;把default子句用于检查真正的默认情况或检查错误&lt;/li&gt;
&lt;li&gt;在case末尾明确无误地标明需要穿越执行的程序流程&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;3-循环语句&quot;&gt;&lt;a href=&quot;#3-循环语句&quot; class=&quot;headerlink&quot; title=&quot;3. 循环语句&quot;&gt;&lt;/a&gt;3. 循环语句&lt;/h1&gt;&lt;h2 id=&quot;3-1-循环的种类&quot;&gt;&lt;a href=&quot;#3-1-循环的种类&quot; class=&quot;headerlink&quot; title=&quot;3.1 循环的种类&quot;&gt;&lt;/a&gt;3.1 循环的种类&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;计数循环：执行次数一定，如for循环。&lt;strong&gt;不要在for循环中去修改下标值或中途退出。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;连续求值的循环：预先不知道循环次数，如while循环&lt;/li&gt;
&lt;li&gt;无限循环：一旦启动就一直执行，除非在循环中间退出，如while循环带break中断&lt;/li&gt;
&lt;li&gt;迭代器循环：容器类的常见操作，如foreach循环&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;3-2-循环的原则&quot;&gt;&lt;a href=&quot;#3-2-循环的原则&quot; class=&quot;headerlink&quot; title=&quot;3.2 循环的原则&quot;&gt;&lt;/a&gt;3.2 循环的原则&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;进入循环&lt;ul&gt;
&lt;li&gt;只从一个位置进入循环&lt;/li&gt;
&lt;li&gt;把初始化代码紧放在循环前面&lt;/li&gt;
&lt;li&gt;用&lt;code&gt;while(true)&lt;/code&gt;表示无限循环&lt;/li&gt;
&lt;li&gt;在适当的情况下多使用for循环；但如果while循环更适用的话，不要使用for循环：因为while循环需要在循环之前初始化条件，循环最后变更条件，容易出错和可读性较差&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;处理循环体&lt;ul&gt;
&lt;li&gt;避免空循环&lt;/li&gt;
&lt;li&gt;循环内务操作（循环变量的变更）要么放在循环的开始，要么放在循环的末尾&lt;/li&gt;
&lt;li&gt;一个循环只做一件事：应该把循环体当做黑盒或子程序看待，读者只需要关心其循环条件是什么，而不需关心其内容&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;退出循环&lt;ul&gt;
&lt;li&gt;设法确认循环能够终止：要考虑正常的情况、端点，及每一种异常情况&lt;/li&gt;
&lt;li&gt;使循环终止条件看起来很明显&lt;/li&gt;
&lt;li&gt;不要为了终止循环而胡乱改动for循环的下标&lt;/li&gt;
&lt;li&gt;避免出现依赖于循环下标&lt;strong&gt;最终取值&lt;/strong&gt;的代码：更具自我描述性的做法是，在循环体内某个适当的地方把这一最终取值赋给某个变量&lt;/li&gt;
&lt;li&gt;考虑使用安全计数器：安全计数器是一个特殊变量，在每次循环之后都递增它，以便判断该循环的执行次数是不是过多&lt;/li&gt;
&lt;li&gt;考虑在while循环中使用break语句而不用布尔标记&lt;/li&gt;
&lt;li&gt;小心那些有很多break散布在循环各处&lt;/li&gt;
&lt;li&gt;在循环开始处用continue进行判断：可以避免用一个让整个循环体的缩进的if块&lt;/li&gt;
&lt;li&gt;除非你已经考虑过各种替换方案，否则不要使用break：使用break消除了把循环看做黑盒子的可能性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;检查端点：既要在脑海中模拟，也要手工检查一遍&lt;/li&gt;
&lt;li&gt;循环变量&lt;ul&gt;
&lt;li&gt;用整数或者枚举类型表示数组和循环的边界&lt;/li&gt;
&lt;li&gt;在嵌套循环中使用有意义的变量名来提高其可读性：避免i、j、k及下标串话误用&lt;/li&gt;
&lt;li&gt;把循环下标变量的作用域限制在本循环内&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;循环的长度&lt;ul&gt;
&lt;li&gt;循环要尽可能地短，以便能够一目了然：建议限制在一屏之内&lt;/li&gt;
&lt;li&gt;把嵌套限制在3层以内&lt;/li&gt;
&lt;li&gt;把长循环的内容移到子程序里&lt;/li&gt;
&lt;li&gt;要让长循环格外清晰&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;4-不太常见的控制结构&quot;&gt;&lt;a href=&quot;#4-不太常见的控制结构&quot; class=&quot;headerlink&quot; title=&quot;4. 不太常见的控制结构&quot;&gt;&lt;/a&gt;4. 不太常见的控制结构&lt;/h1&gt;&lt;h2 id=&quot;4-1-子程序多处返回&quot;&gt;&lt;a href=&quot;#4-1-子程序多处返回&quot; class=&quot;headerlink&quot; title=&quot;4.1 子程序多处返回&quot;&gt;&lt;/a&gt;4.1 子程序多处返回&lt;/h2&gt;&lt;p&gt;子程序的多处返回是指一个子程序中有多处地方出现return。通常来说，应该用防卫子句（早返回或早退出）来简化复杂的错误处理，不要使用过多的缩进嵌套，并且减少每个子程序中return的数量。下面的例子很好地体现了这些原则。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (!file.validName()) {
    errorStatus = FileError.InvalidFileName;
    return;
}
if (!file.Open()) {
    errorStatus = FileError.CantOpenFile;
    return;
}
if (!encryptionKey.valid()) {
    errorStatus = FileError.InvalidEncryptionKey;
    return;
}
// 此处为处理正常情况的代码
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;4-2-递归&quot;&gt;&lt;a href=&quot;#4-2-递归&quot; class=&quot;headerlink&quot; title=&quot;4.2 递归&quot;&gt;&lt;/a&gt;4.2 递归&lt;/h2&gt;&lt;p&gt;递归并不常用，但如果使用得谨慎，一些小范围内的问题还是可以得到非常优雅的解。对于大多数问题，它所带来的解将会是极其复杂的——在那些情况下，使用简单的迭代通常会比较容易理解。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;确认递归能够停止&lt;/li&gt;
&lt;li&gt;使用安全计数器防止出现无穷递归：安全计数器必须是一个不随每次子程序调用而重新创建的变量&lt;/li&gt;
&lt;li&gt;把递归限制在一个子程序内：循环边归（A调用B, B调用C, C调用A）非常危险&lt;/li&gt;
&lt;li&gt;留心栈空间：给安全计数器设置上限时考虑给递归子程序分配多少栈空间，并观察递归函数中局部变量的分配情况&lt;/li&gt;
&lt;li&gt;不要用递归去计算阶乘或者斐波纳契数列：最重要的，在用递归之前你应该考虑它的替换方案&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;4-3-关于goto语句&quot;&gt;&lt;a href=&quot;#4-3-关于goto语句&quot; class=&quot;headerlink&quot; title=&quot;4.3 关于goto语句&quot;&gt;&lt;/a&gt;4.3 关于goto语句&lt;/h2&gt;&lt;p&gt;入们反对使用goto的普遍理由是：含有goto的代码很难安排好格式；使用goto也会破坏编译器的优化特性。关于goto的讨论非常多，而且其现代版本仍在以各种各样的形式出现。用不用goto是一个&lt;strong&gt;信仰问题&lt;/strong&gt;。《代码大全》作者的信条是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在现代语言里，你可以很容易地把九成的goto替换成与之等价的顺序结构。对于这些简单的情况，你应该把goto替换掉并把这当成习惯。对于复杂的情况，你仍有九成不用goto的可能：你可以把代码拆分成小的子程序，使用try-finally，使用嵌套if，检测并重新检测某个状态变量，或者重新设置条件结构。对于这些情况，想消除goto相对来说比较难，但这是一种很好的智力训练……&lt;br&gt;对于剩下的那1%的情况，即当使用goto是解决问题的合理办法的时候，请在使用的同时予以详细的说明。如果你穿着雨鞋，那么就没有必要绕开泥潭走路了。不过也要虚心参考别的程序员提出的不用goto的方法。也许他们发现了一些被你忽视的东西。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;在那些不直接支持结构化控制语句的语言里，用goto去模拟那些控制结构。在做这些的时候，应该准确地模拟，不要滥用goto所带来的灵活性&lt;/li&gt;
&lt;li&gt;如果语言内置了等价的控制结构，那么就不要用goto&lt;/li&gt;
&lt;li&gt;如果是为提高代码效率而使用goto，请衡量此举实际带来的性能提升&lt;/li&gt;
&lt;li&gt;除非你要模拟结构化语句，否则尽量在每个子程序内只使用一个goto标号&lt;/li&gt;
&lt;li&gt;除非你要模拟结构化语句，否则尽量让goto向前跳转而不要向后跳转&lt;/li&gt;
&lt;li&gt;确认所布的goto标号都被用到了。没用到的goto标号表明缺少了代码，即缺少了跳向该标号的代码。如果某些标号没有用，那么就删掉它们&lt;/li&gt;
&lt;li&gt;确认goto不会产生某些执行不到的代码&lt;/li&gt;
&lt;li&gt;如果你是一位经理，那么就应该持这样的观点：对某一个goto用法所展开的争论并不是事关全局的。如果程序员知道存在替换方案，并且也愿意为使用goto辩解，那么用goto也无妨&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考文献：电子工业出版社《代码大全（第2版）》第14-17章&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;本文开始从以数据为中心的编程观点转到以语句为中心的观点上。常用的编程语句有顺序、控制和循环三种基本结构，本文将依次介绍这三种基本结构的使用原则。最后，还总结了一些不太常见的控制结构，如子程序多处返回、递归、关于goto语句的讨论。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="综合" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/"/>
    
      <category term="软件工程" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="软件构建" scheme="http://raytaylorlin.com/tags/%E8%BD%AF%E4%BB%B6%E6%9E%84%E5%BB%BA/"/>
    
      <category term="软件工程" scheme="http://raytaylorlin.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="代码大全" scheme="http://raytaylorlin.com/tags/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>软件构建（五）——各种数据类型的使用原则</title>
    <link href="http://raytaylorlin.com/tech/complex/software/software-construction-5/"/>
    <id>http://raytaylorlin.com/tech/complex/software/software-construction-5/</id>
    <published>2016-04-11T06:58:29.000Z</published>
    <updated>2016-05-12T13:14:24.685Z</updated>
    
    <content type="html">&lt;p&gt;几乎所有的常见编程语言，都包含了整数、浮点数、字符串、布尔等等数据类型，而通过基本的数据类型又可以复合出各种数据结构。本文总结了常用的数据类型（整数、浮点数、字符、字符串、布尔、枚举、数组等等）以及一些不常见的数据类型（结构体、指针等等）的使用原则。最后总结了关于全局数据的一些风险和使用原则。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-常用的数据类型使用原则&quot;&gt;&lt;a href=&quot;#1-常用的数据类型使用原则&quot; class=&quot;headerlink&quot; title=&quot;1. 常用的数据类型使用原则&quot;&gt;&lt;/a&gt;1. 常用的数据类型使用原则&lt;/h1&gt;&lt;h2 id=&quot;1-1-使用数值的原则&quot;&gt;&lt;a href=&quot;#1-1-使用数值的原则&quot; class=&quot;headerlink&quot; title=&quot;1.1 使用数值的原则&quot;&gt;&lt;/a&gt;1.1 使用数值的原则&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;普遍原则&lt;ul&gt;
&lt;li&gt;避免使用“神秘数值”，即硬编码数字：这是为了使修改变得可靠容易，并更有可读性&lt;/li&gt;
&lt;li&gt;如果需要，可以使用硬编码的0和1：通常用于增减量或循环的第一个元素&lt;/li&gt;
&lt;li&gt;预防除零错误&lt;/li&gt;
&lt;li&gt;使类型转换变得明显：不要依赖隐式类型转换&lt;/li&gt;
&lt;li&gt;避免混合类型的比较：同样不要依赖隐式类型转换，确保比较的两个数是同种类型的&lt;/li&gt;
&lt;li&gt;注意编译器的警告&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;整数&lt;ul&gt;
&lt;li&gt;检查整数除法：小心&lt;strong&gt;整数除&lt;/strong&gt;和现实除法的差异&lt;/li&gt;
&lt;li&gt;检查整数溢出和中间结果溢出&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;浮点数&lt;ul&gt;
&lt;li&gt;避免数量级相差巨大的数之间的加减运算：由于精度问题，对于32位浮点数，小心1000000.00 + 0.1得到的结果和期望不同。如果要把一系列差异巨大的数相加，解决方法是先排序，再从最小值开始加起，这样可以把影响减少到最低限度&lt;/li&gt;
&lt;li&gt;避免直接进行等量比较：应自己编写equals函数判断两者之差是否小于某阈值&lt;/li&gt;
&lt;li&gt;处理舍入误差问题：考虑换用更高精度的类型，或者把浮点数放大n倍用整型类型做计算&lt;/li&gt;
&lt;li&gt;使用语言和函数库对特定数据类型的支持&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-2-字符和字符串&quot;&gt;&lt;a href=&quot;#1-2-字符和字符串&quot; class=&quot;headerlink&quot; title=&quot;1.2 字符和字符串&quot;&gt;&lt;/a&gt;1.2 字符和字符串&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;避免使用神秘字符和字符串：除了数值所提到的理由之外，还有这些理由：分离字符串到字符串资源文件更容易实现i18n，字符串字面量会占用较多的存储空间&lt;/li&gt;
&lt;li&gt;了解你的语言和开发环境是如何支持Unicode的&lt;/li&gt;
&lt;li&gt;在程序生命期中尽早决定国际化/本地化策略&lt;/li&gt;
&lt;li&gt;如果你知道只需要支持一种文字的语言，考虑使用ISO8859字符集，否则使用Unicode&lt;/li&gt;
&lt;li&gt;采用某种一致的字符串类型转换策略&lt;/li&gt;
&lt;li&gt;针对C语言字符串的建议：&lt;ul&gt;
&lt;li&gt;注意字符串指针和字符数组之间的差异：警惕任何包含字符串和等号的表达式；通过命名规则区分变量是字符数组还是字符串指针&lt;/li&gt;
&lt;li&gt;把C-style字符串的长度声明为&lt;code&gt;STRING_LENGTH + 1&lt;/code&gt;：统一约定这条规则，有助于减少脑力消耗以及编程失误&lt;/li&gt;
&lt;li&gt;用null初始化字符串以避免没有终端的字符串&lt;/li&gt;
&lt;li&gt;如果内存不是限制性的因素，就用字符数组取代C中的指针&lt;/li&gt;
&lt;li&gt;用strncpy()取代strcpy()以避免无终端的字符串&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-3-布尔变量&quot;&gt;&lt;a href=&quot;#1-3-布尔变量&quot; class=&quot;headerlink&quot; title=&quot;1.3 布尔变量&quot;&gt;&lt;/a&gt;1.3 布尔变量&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;用布尔变量对程序加以文档说明，并用来简化复杂的判断。&lt;/strong&gt;通过下面的例子来了解布尔变量的正确用法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 目的不明确的布尔判断，咋一看根本不知道要判断什么
if ( (elementindex &amp;lt; 0 ) || (MAX_ELEMENTS &amp;lt; elementIndex) || (elementIndex == lastElementIndex) ) { ... }

// 目的明确的布尔判断
bool finished = (elementindex &amp;lt; 0 ) || (MAX_ELEMENTS &amp;lt; elementIndex);
bool repeatedEntry = (elementIndex == lastElementIndex);
if (finished || repeatedEntry) { ... }
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;1-4-枚举类型&quot;&gt;&lt;a href=&quot;#1-4-枚举类型&quot; class=&quot;headerlink&quot; title=&quot;1.4 枚举类型&quot;&gt;&lt;/a&gt;1.4 枚举类型&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;用枚举类型来提高可读性和可靠性：如果仅使用具名常量，编译器无法知道是否使用了非法的数值&lt;/li&gt;
&lt;li&gt;将枚举类型作为布尔变量的替换方案：有时布尔变量无法充分表达它所需要表达的含义（比如出错信息），那么用枚举&lt;/li&gt;
&lt;li&gt;定义出枚举的第一项和最后一项，以使用于循环边界，把枚举类型的第一个元素留做非法值：如&lt;code&gt;enum Country {InvalidFirst = 0, First = 1, China = 1, England = 2, Usa = 3, Last = 4}&lt;/code&gt;，但是这样做也可能造成混乱，一定要&lt;strong&gt;明确定义项目代码编写标准，并在使用时保持一致，否则就不要用&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;警惕给枚举元素明确赋值而带来的失误：当定义0，1，2，4，8这样的枚举值时，不要去遍历&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-5-数组&quot;&gt;&lt;a href=&quot;#1-5-数组&quot; class=&quot;headerlink&quot; title=&quot;1.5 数组&quot;&gt;&lt;/a&gt;1.5 数组&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;确认所有的数组下标都没有超出数组的边界&lt;/li&gt;
&lt;li&gt;考虑用合适的容器（栈、队列、集合、列表等等）来取代数组&lt;/li&gt;
&lt;li&gt;检查数组的边界点&lt;/li&gt;
&lt;li&gt;如果数组是多维的，确认下标的&lt;strong&gt;使用顺序&lt;/strong&gt;是正确的：如很容易把&lt;code&gt;array[i][j]&lt;/code&gt;搞混成&lt;code&gt;array[j][i]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;提防下标串话：如把&lt;code&gt;array[i]&lt;/code&gt;写成&lt;code&gt;array[j]&lt;/code&gt;，和上一条一样，如果使用比i和j更有意义的下标名，这种错误就很难发生&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;2-不常见的数据类型&quot;&gt;&lt;a href=&quot;#2-不常见的数据类型&quot; class=&quot;headerlink&quot; title=&quot;2. 不常见的数据类型&quot;&gt;&lt;/a&gt;2. 不常见的数据类型&lt;/h1&gt;&lt;h2 id=&quot;2-1-结构体&quot;&gt;&lt;a href=&quot;#2-1-结构体&quot; class=&quot;headerlink&quot; title=&quot;2.1 结构体&quot;&gt;&lt;/a&gt;2.1 结构体&lt;/h2&gt;&lt;p&gt;在Java和C++里面，类有时表现得也像结构体一样（当类完全由公用的数据成员组成，而不包含公用子程序的时候）。通常情况下，你会希望创建类而非结构体，下面列出了一些使用结构体的理由：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用结构体来明确数据关系&lt;/li&gt;
&lt;li&gt;用结构体简化对数据块的操作&lt;/li&gt;
&lt;li&gt;用结构体来简化参数列表&lt;/li&gt;
&lt;li&gt;用结构体来减少维护&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-2-指针&quot;&gt;&lt;a href=&quot;#2-2-指针&quot; class=&quot;headerlink&quot; title=&quot;2.2 指针&quot;&gt;&lt;/a&gt;2.2 指针&lt;/h2&gt;&lt;p&gt;指针的使用是现代编程中最容易出错的领域之一，即便你的语言不要求你使用指针，很好地理解指针也会有助于你理解你的编程语言是如何工作的。从概念上看，每一个指针都包含两个部分：内存中的某处位置（实质是一个整数值，常用16进制表示），以及如何解释指针所指的内容（由指针的基类型决定）。&lt;/p&gt;
&lt;p&gt;通常，指针错误都产生于指针指向了它不应该指向的位置。因此，更正指针错误的大部分工作量便是找出它的位置。正确地使用指针要求程序员采用一种双向策略，首先要避免造成指针错误，其次在编写代码之后尽快地检测出指针错误来。下面说明如何实现这些目标。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;把指针操作限制在子程序或者类里面&lt;/li&gt;
&lt;li&gt;同时声明和定义指针&lt;/li&gt;
&lt;li&gt;在与指针分配相同的作用域中删除指针&lt;/li&gt;
&lt;li&gt;在使用指针之前确保指针所指向的内存位置是合理的&lt;/li&gt;
&lt;li&gt;先检查指针所引用的变量内容再使用它&lt;/li&gt;
&lt;li&gt;用标记字段来检测损毁的内存：分配内存时多分配4个字节，将前4个字节设为标记字段，返回这4个字节后的内存的指针，到了需要删除该指针的时候，检查这个标记，如果标记的值是正确的，就把它设为NULL，最后删除该指针&lt;/li&gt;
&lt;li&gt;增加明显的冗余：将某些特定字段重复两次，以此替代标记字段的方案，但是这样会带来很高的成本&lt;/li&gt;
&lt;li&gt;用额外的指针变量来提高代码清晰度：如不要写绕口的诸如&lt;code&gt;pointer-&amp;gt;next-&amp;gt;last-&amp;gt;next&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;画一个图理清指针之间的结构关系&lt;/li&gt;
&lt;li&gt;按照正确的顺序删除链表中的指针&lt;/li&gt;
&lt;li&gt;分配一片保留的内存后备区域：如果使用动态内存，最好预先分配一片内存后备，防止程序忽然用尽内存&lt;/li&gt;
&lt;li&gt;在删除或者释放指针之后把它们设为空值&lt;/li&gt;
&lt;li&gt;在删除变量之前检查非法指针&lt;/li&gt;
&lt;li&gt;跟踪指针分配情况：维护一份你已经分配的指针的列表&lt;/li&gt;
&lt;li&gt;编写覆盖子程序，集中实现避免指针问题的策略：如编写&lt;code&gt;SAFE_NEW&lt;/code&gt;和&lt;code&gt;SAFE_DELETE&lt;/code&gt;宏来统一包装指针的操作&lt;/li&gt;
&lt;li&gt;采用非指针的技术&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;还有一些特定的针对C++和C语言的指针使用技巧，此处不赘述。&lt;/p&gt;
&lt;h1 id=&quot;3-全局数据&quot;&gt;&lt;a href=&quot;#3-全局数据&quot; class=&quot;headerlink&quot; title=&quot;3. 全局数据&quot;&gt;&lt;/a&gt;3. 全局数据&lt;/h1&gt;&lt;p&gt;全局数据可以在程序中任意一个位置访问，这一概念有时被延伸到作用域比局部变量更广的变量，例如可以在一个包或一个命名空间内任意位置访问。一般来说，使用全局数据的风险比使用局部数据大，只有在万不得已时才使用，如果要用也应该遵循一些使用原则来降低风险。&lt;/p&gt;
&lt;h2 id=&quot;3-1-使用全局数据的风险&quot;&gt;&lt;a href=&quot;#3-1-使用全局数据的风险&quot; class=&quot;headerlink&quot; title=&quot;3.1 使用全局数据的风险&quot;&gt;&lt;/a&gt;3.1 使用全局数据的风险&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;无意间修改了全局数据&lt;/li&gt;
&lt;li&gt;与全局数据有关的别名问题：当一个全局变量被传递给一个子程序，然后该子程序将它既用作全局变量又用作参数使用的情况下会出现这种问题&lt;/li&gt;
&lt;li&gt;多线程下风险很大&lt;/li&gt;
&lt;li&gt;全局数据阻碍代码重用&lt;/li&gt;
&lt;li&gt;与全局数据有关的非确定的初始化顺序事直&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;全局数据破坏了模块化和智力上的可管理性&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;3-2-全局数据的使用原则&quot;&gt;&lt;a href=&quot;#3-2-全局数据的使用原则&quot; class=&quot;headerlink&quot; title=&quot;3.2 全局数据的使用原则&quot;&gt;&lt;/a&gt;3.2 全局数据的使用原则&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;创建一种命名规则来突出全局变量：例如使用g_前缀&lt;/li&gt;
&lt;li&gt;为全部的全局变量创建一份注释良好的清单&lt;/li&gt;
&lt;li&gt;不要用全局变量来存放中间结果&lt;/li&gt;
&lt;li&gt;不要把所有的数据都放在一个大对象中并到处传递，以说明你没有使用全局变量：这纯粹是一种负担，如果要用全局数据，就大胆公开地用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考文献：电子工业出版社《代码大全（第2版）》第12、13章&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;几乎所有的常见编程语言，都包含了整数、浮点数、字符串、布尔等等数据类型，而通过基本的数据类型又可以复合出各种数据结构。本文总结了常用的数据类型（整数、浮点数、字符、字符串、布尔、枚举、数组等等）以及一些不常见的数据类型（结构体、指针等等）的使用原则。最后总结了关于全局数据的一些风险和使用原则。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="综合" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/"/>
    
      <category term="软件工程" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="软件构建" scheme="http://raytaylorlin.com/tags/%E8%BD%AF%E4%BB%B6%E6%9E%84%E5%BB%BA/"/>
    
      <category term="软件工程" scheme="http://raytaylorlin.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="代码大全" scheme="http://raytaylorlin.com/tags/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>软件构建（四）——变量的使用原则</title>
    <link href="http://raytaylorlin.com/tech/complex/software/software-construction-4/"/>
    <id>http://raytaylorlin.com/tech/complex/software/software-construction-4/</id>
    <published>2016-04-08T06:11:59.000Z</published>
    <updated>2016-05-12T13:14:28.423Z</updated>
    
    <content type="html">&lt;p&gt;变量的好与坏就在很大程度上取决于它的命名的好坏，在给变量命名的时候需要小心谨慎。本文首先详细讲述构建活动中的基本组成成分，即变量的使用原则，接着再讲述适用于为变量——对象和基本数据——命名的原则。这些原则也适用于类、包、文件及其他的编程实体。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-使用变量的原则&quot;&gt;&lt;a href=&quot;#1-使用变量的原则&quot; class=&quot;headerlink&quot; title=&quot;1. 使用变量的原则&quot;&gt;&lt;/a&gt;1. 使用变量的原则&lt;/h1&gt;&lt;h2 id=&quot;1-1-变量初始化原则&quot;&gt;&lt;a href=&quot;#1-1-变量初始化原则&quot; class=&quot;headerlink&quot; title=&quot;1.1 变量初始化原则&quot;&gt;&lt;/a&gt;1.1 变量初始化原则&lt;/h2&gt;&lt;p&gt;不恰当的变量初始化所导致的一系列问题都源于变量的默认初始值与你的预期不同，下面给出一些避免产生初始化错误的建议。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在声明变量的时候初始化&lt;/li&gt;
&lt;li&gt;在靠近变量第一次使用的位置初始化它&lt;/li&gt;
&lt;li&gt;理想情况下， 在靠近第一次使用变量的位置声明和定义该变量&lt;/li&gt;
&lt;li&gt;在可能的情况下使用final或者const关键字&lt;/li&gt;
&lt;li&gt;注意计数器和累加器，在下次使用前要重置&lt;/li&gt;
&lt;li&gt;在类的构造函数里初始化该类的数据成员&lt;/li&gt;
&lt;li&gt;利用编译器的警告信息检查是否使用了未经初始化的变量&lt;/li&gt;
&lt;li&gt;在程序开始时初始化工作内&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-2-变量的作用域&quot;&gt;&lt;a href=&quot;#1-2-变量的作用域&quot; class=&quot;headerlink&quot; title=&quot;1.2 变量的作用域&quot;&gt;&lt;/a&gt;1.2 变量的作用域&lt;/h2&gt;&lt;p&gt;关于变量引用局部化的指标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;跨度：衡量一个变量的不同引用点的靠近程度，具体数字为对变量前后引用之间的代码行数&lt;/li&gt;
&lt;li&gt;存活时间：一个变量存在期间（被引用的第一条语句至结束引用它的最后一条语句）所跨越的语句总数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;尽可能缩短变量的跨度和存活时间，可以减少初始化错误的可能，让自己对的代码有更准确的认识，使代码更具可读性。像全局变量的跨度和存活时间都很长，应尽量避免使用。下面是一些减小作用域的一般原则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在循环开始之前再去初始化该循环里使用的变量，而不是在该循环所属的子程序的开始处初始化这些变量&lt;/li&gt;
&lt;li&gt;直到变量即将被使用时再为其赋值&lt;/li&gt;
&lt;li&gt;把相关语句放到一起&lt;/li&gt;
&lt;li&gt;把相关语句组提取成单独的子程序&lt;/li&gt;
&lt;li&gt;开始时采用最严格的可见性，然后根据需要扩展变量的作用&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-3-变量的使用原则&quot;&gt;&lt;a href=&quot;#1-3-变量的使用原则&quot; class=&quot;headerlink&quot; title=&quot;1.3 变量的使用原则&quot;&gt;&lt;/a&gt;1.3 变量的使用原则&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;每个变量只用于单一用途：不要将临时变量如temp用于两种用途&lt;/li&gt;
&lt;li&gt;避免让变量具有隐含含义，以下做法都是&lt;strong&gt;不可取&lt;/strong&gt;的&lt;ul&gt;
&lt;li&gt;pageCount表示已打印纸张的数量，如果是-1表示有错误发生&lt;/li&gt;
&lt;li&gt;bytesWritten表示写入输出文件的字节数，如果取值为负，表示用于输出的磁盘驱动器的号码&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;确保使用了所有己声明的变量&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关于变量的绑定时间，通常来说越晚绑定会有更多的灵活性，但复杂度也会越低。看看下面演示的例子，应酌情选择变量绑定时间：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 编写代码时绑定：硬编码（使用“神秘数字”）很糟糕，一旦要修改颜色则代码其他地方很难保持一致
titleBar.color = 0xFF;

// 编译时绑定：用具名常量可以增加可读性，还能只修改一处就对所有位置生效
private static final int COLOR_BLUE = 0xFF;
private static final int TITLE_BAR_COLOR = COLOR_BLUE;
titleBar.color = TITLE_BAR_COLOR;

// 运行时绑定：程序运行期间读取，可能从配置文件读取，也可能从注册表读取，这是相对最灵活的方式
titleBar.color = ReadTitleBarColor();

// 此外还有对象实例化时绑定（如每次窗体创建时读取数据），甚至即时绑定（如每次窗体重绘时读取数据）
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;2-变量的命名规范&quot;&gt;&lt;a href=&quot;#2-变量的命名规范&quot; class=&quot;headerlink&quot; title=&quot;2. 变量的命名规范&quot;&gt;&lt;/a&gt;2. 变量的命名规范&lt;/h1&gt;&lt;h2 id=&quot;2-1-选择好变量名的注意事项&quot;&gt;&lt;a href=&quot;#2-1-选择好变量名的注意事项&quot; class=&quot;headerlink&quot; title=&quot;2.1 选择好变量名的注意事项&quot;&gt;&lt;/a&gt;2.1 选择好变量名的注意事项&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;名字要完全、准确地描述出该变量所代表的事物，&lt;strong&gt;这是最重要的命名注意事项&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;以问题为导向：好记的名字反映的通常都是问题，而不是解决方案，例如表示打印机准备状态，printerReady就比bitFlag要更准确描述问题&lt;/li&gt;
&lt;li&gt;最适当的名字长度：建议平均8-20个字符，举个例子numberOfPeopleOnTheUsOlympicTeam太长，ntm太短，numTeamMembers正好&lt;/li&gt;
&lt;li&gt;较长的名字适用于很少用到的变量，较短的名字适用于局部变量或循环变量&lt;/li&gt;
&lt;li&gt;对位于全局命名空间中的名字加以限定词：用namespace、1g_前缀等等&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;把限定词放到最后，为变量赋予主要含义的部分应位于最前面&lt;/strong&gt;：例如revenueTotal要优于totalRevenue。这条规则非常适用于项目内约束以提高一致性&lt;ul&gt;
&lt;li&gt;常用的限定词：Total、Sum、Average、Max、Min、Record、Pointer等等&lt;/li&gt;
&lt;li&gt;Num限定词是个例外，通常customerNum表示下表，而numCustomers表示员工总数。但最好的办法是避免用Num，而改用Count或Total来表示总数，用Index表示下标&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下表给出一些名字好坏的对比：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;变量用途&lt;/th&gt;
&lt;th&gt;描述清晰的好名字&lt;/th&gt;
&lt;th&gt;描述不到位的坏名字&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;支票累计额&lt;/td&gt;
&lt;td&gt;runningTotal, checkTotal&lt;/td&gt;
&lt;td&gt;written, ct, checks, CHKTTL&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;列车的运行速度&lt;/td&gt;
&lt;td&gt;trainVelocity, velocityInMph&lt;/td&gt;
&lt;td&gt;velt, v tv, train&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;当前日期&lt;/td&gt;
&lt;td&gt;currentDate, todaysDate&lt;/td&gt;
&lt;td&gt;cd, current, c, date&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;每页的行数&lt;/td&gt;
&lt;td&gt;linesPerPage&lt;/td&gt;
&lt;td&gt;lpp, lines, l, x, x1, x2&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&quot;2-2-为特定类型的数据命名&quot;&gt;&lt;a href=&quot;#2-2-为特定类型的数据命名&quot; class=&quot;headerlink&quot; title=&quot;2.2 为特定类型的数据命名&quot;&gt;&lt;/a&gt;2.2 为特定类型的数据命名&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;循环下标：i、j、k作为下标是约定俗称的。若循环较长会有多层嵌套，最好用xxxIndex的描述性名字做下标&lt;/li&gt;
&lt;li&gt;状态变量：取一个比xxxFlag更好的名字，例如reportType要比statusFlag要更清晰。也建议状态变量采用具名常量或枚举类型来表达&lt;/li&gt;
&lt;li&gt;临时变量：取一个比temp更具描述性的名字&lt;/li&gt;
&lt;li&gt;布尔变量：done表示某件事是否完成，error表示是否发生错误，found表示是否找到，success表示是否成功。布尔变量的名字要明确反映true或false。此外，要使用&lt;strong&gt;肯定&lt;/strong&gt;的名字，不要取notFound、notSuccessful之类的&lt;/li&gt;
&lt;li&gt;常量：根据常量所表示的含义取名，而不是为其数值取名&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-3-应该避免的名字&quot;&gt;&lt;a href=&quot;#2-3-应该避免的名字&quot; class=&quot;headerlink&quot; title=&quot;2.3 应该避免的名字&quot;&gt;&lt;/a&gt;2.3 应该避免的名字&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;避免使用令人误解的名字或缩写&lt;/li&gt;
&lt;li&gt;避免使用具有相似含义的名字：如input和inputValue，recordNum和numRecords等等&lt;/li&gt;
&lt;li&gt;避免使用具有不同含义却又相似名字的变量：如clientRecs和clientReps&lt;/li&gt;
&lt;li&gt;避免使用发音相近的名字：如wrap和rap&lt;/li&gt;
&lt;li&gt;避免在名字中使用数字&lt;/li&gt;
&lt;li&gt;避免在名字中拼错单词&lt;/li&gt;
&lt;li&gt;避免使用英语中常常拼错的单词&lt;/li&gt;
&lt;li&gt;不要仅靠大小写来区分变量&lt;/li&gt;
&lt;li&gt;不要使用与变量含义完全无关的名字&lt;/li&gt;
&lt;li&gt;避免在名字中包含易混淆的字符&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;3-制定命名规范&quot;&gt;&lt;a href=&quot;#3-制定命名规范&quot; class=&quot;headerlink&quot; title=&quot;3. 制定命名规范&quot;&gt;&lt;/a&gt;3. 制定命名规范&lt;/h1&gt;&lt;p&gt;命名规则在各种编程语言，乃至各个公司都是不同的，但也有一些比较通用的规范可以注意。限于篇幅本文不阐述变量的命名的规范，下面只提一下为何要制定命名规范：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当多个程序员合作开发一个项目时&lt;/li&gt;
&lt;li&gt;当你计划把一个程序转交给另一位程序员来修改和维护的时候（这几乎总是会发生）&lt;/li&gt;
&lt;li&gt;当你所在组织中的其他程序员评估你写的程序的时候&lt;/li&gt;
&lt;li&gt;当你写的程序规模太大，以致于你无法在脑海里同时了解事情的全貌，而必须分而治之的时候&lt;/li&gt;
&lt;li&gt;当你写的程序生命期足够长，长到你可能会在把它搁置几个星期或几个月之后又重新启动有关该程序的工作时&lt;/li&gt;
&lt;li&gt;当在一个项目中存在一些不常见的术语，并且你希望在编写代码阶段使用标准的术语或者缩写的时候&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不同规范所要求的正式程度也有所不同。通常，一个项目所需的规范正式程度取决于为项目组的人员数量，程序的规模，以及程序预期的生命周期。对于微小的、用完即弃的项目而言，实施严格的规则可能就没什么必要。但对于多人协作的大型项目而言，无论是在开始阶段还是贯穿整个程序的生命周期，正式规范都是成为提高可读性的必不可少的辅助手段。&lt;/p&gt;
&lt;p&gt;参考文献：电子工业出版社《代码大全（第2版）》第10、11章&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;变量的好与坏就在很大程度上取决于它的命名的好坏，在给变量命名的时候需要小心谨慎。本文首先详细讲述构建活动中的基本组成成分，即变量的使用原则，接着再讲述适用于为变量——对象和基本数据——命名的原则。这些原则也适用于类、包、文件及其他的编程实体。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="综合" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/"/>
    
      <category term="软件工程" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="软件构建" scheme="http://raytaylorlin.com/tags/%E8%BD%AF%E4%BB%B6%E6%9E%84%E5%BB%BA/"/>
    
      <category term="软件工程" scheme="http://raytaylorlin.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="代码大全" scheme="http://raytaylorlin.com/tags/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>软件构建（三）——高质量的类和子程序</title>
    <link href="http://raytaylorlin.com/tech/complex/software/software-construction-3/"/>
    <id>http://raytaylorlin.com/tech/complex/software/software-construction-3/</id>
    <published>2016-04-05T06:11:59.000Z</published>
    <updated>2016-05-12T13:14:20.579Z</updated>
    
    <content type="html">&lt;p&gt;在计算时代的早期，程序员基于语句思考编程问题。到了20世纪七八十年代，程序员开始基于子程序去思考编程。进入21世纪，程序员以类为基础思考编程问题。类是由一组数据和子程序构成的集合，这些数据和子程序共同拥有一组内聚的、明确定义的职责。由此可见类和子程序在现代编程中的地位。本文将就如何创建高质量的类和子程序提供一些建议。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-高质量的类&quot;&gt;&lt;a href=&quot;#1-高质量的类&quot; class=&quot;headerlink&quot; title=&quot;1. 高质量的类&quot;&gt;&lt;/a&gt;1. 高质量的类&lt;/h1&gt;&lt;h2 id=&quot;1-1-类的基础：抽象数据类型（ADT）&quot;&gt;&lt;a href=&quot;#1-1-类的基础：抽象数据类型（ADT）&quot; class=&quot;headerlink&quot; title=&quot;1.1 类的基础：抽象数据类型（ADT）&quot;&gt;&lt;/a&gt;1.1 类的基础：抽象数据类型（ADT）&lt;/h2&gt;&lt;p&gt;要想理解面向对象编程，首先要理解ADT（Abstract Data Type）。ADT是指一些数据以及对这些数据所进行的操作的集合。这些操作既向程序的其余部分描述了这些数据是怎么样的，也允许程序的其余部分改变这些数据。抽象数据类型可以让你像在现实世界中一样操作实体，而不必纠结在低层如何实现上。&lt;/p&gt;
&lt;h3 id=&quot;1-1-1-使用ADT的好处&quot;&gt;&lt;a href=&quot;#1-1-1-使用ADT的好处&quot; class=&quot;headerlink&quot; title=&quot;1.1.1 使用ADT的好处&quot;&gt;&lt;/a&gt;1.1.1 使用ADT的好处&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;可以隐藏实现细节&lt;/li&gt;
&lt;li&gt;改动不会影响到整个程序&lt;/li&gt;
&lt;li&gt;让接口能提供更多信息&lt;/li&gt;
&lt;li&gt;更容易提高性能&lt;/li&gt;
&lt;li&gt;程序更具自我说明性&lt;/li&gt;
&lt;li&gt;无须在程序内到处传递数据&lt;/li&gt;
&lt;li&gt;可以像在现实世界中那样操作实体，而不用在底层实现上操作它&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1-1-2-使用ADT的指导建议&quot;&gt;&lt;a href=&quot;#1-1-2-使用ADT的指导建议&quot; class=&quot;headerlink&quot; title=&quot;1.1.2 使用ADT的指导建议&quot;&gt;&lt;/a&gt;1.1.2 使用ADT的指导建议&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;把常见的底层数据类型创建为ADT并使用这些ADT，而不再使用底层数据类型（要尽可能选择最高的抽象层次）&lt;/li&gt;
&lt;li&gt;把像文件这样的常用对象当成ADT&lt;/li&gt;
&lt;li&gt;简单的事物也可当做ADT（如灯的“开”“关”操作可以放到单独的方法）&lt;/li&gt;
&lt;li&gt;不要让ADT依赖于其存储介质&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-2-良好的类接口&quot;&gt;&lt;a href=&quot;#1-2-良好的类接口&quot; class=&quot;headerlink&quot; title=&quot;1.2 良好的类接口&quot;&gt;&lt;/a&gt;1.2 良好的类接口&lt;/h2&gt;&lt;p&gt;上一节所讲的ADT构成了类的基础，类可以看成是抽象数据类型再加上继承和多态两个概念。创建高质量的类最重要的一步是创建一个好的接口，包括通过接口来展现良好的抽象，并确保细节被很好地封装在类中。封装是一个比抽象更强的概念：抽象通过提供一个可以让你忽略实现细节的模型来管理复杂度，而封装则强制阻止你看到细节。一般来说，抽象和封装要么两者皆有，要么两者皆无。&lt;/p&gt;
&lt;h3 id=&quot;1-2-1-良好的抽象&quot;&gt;&lt;a href=&quot;#1-2-1-良好的抽象&quot; class=&quot;headerlink&quot; title=&quot;1.2.1 良好的抽象&quot;&gt;&lt;/a&gt;1.2.1 良好的抽象&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;类的接口应该展现一致的抽象层次：每一个类应该&lt;strong&gt;只实现一个ADT&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;一定要理解类所实现的抽象是什么&lt;/li&gt;
&lt;li&gt;提供成对的服务：例如开和关，添加和删除，但一定要考虑是否真的需要，不要盲目创建相反的操作&lt;/li&gt;
&lt;li&gt;把不相关的信息转移到其他类&lt;/li&gt;
&lt;li&gt;尽可能让接口可编程，而不是表达语义：可编程的部分能被编译器检查，但语义部分是由“本接口将会被怎样使用”的假定组成（比如“ RoutineA必须在RoutineB之前被调用”或“如果dataMember未经初始化就传给RoutineA的话，将会导致RoutineA崩溃”）&lt;/li&gt;
&lt;li&gt;谨防在修改时破坏接口的抽象：在对类进行修改和扩展时要特别注意&lt;/li&gt;
&lt;li&gt;不要添加与接口抽象不一致的公用成员&lt;/li&gt;
&lt;li&gt;同时考虑抽象性和内聚性&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1-2-2-良好的封装&quot;&gt;&lt;a href=&quot;#1-2-2-良好的封装&quot; class=&quot;headerlink&quot; title=&quot;1.2.2 良好的封装&quot;&gt;&lt;/a&gt;1.2.2 良好的封装&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;尽可能地限制类和成员的可访问性&lt;/li&gt;
&lt;li&gt;不要公开暴露成员数据：使用get、set访问器来访问&lt;/li&gt;
&lt;li&gt;&lt;em&gt;避免把私用的实现细节放入类的接口中&lt;/em&gt;（特指C++）：应尽量避免在类的头文件中查看private的内容。《Efective C++》第2版第34条建议，把类的接口与类的实现隔离开，并在类的声明中包含一个指针，让该指针指向类的实现，但不能包含任何其他实现细节。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;避免使用友元类&lt;/em&gt;（特指C++）&lt;/li&gt;
&lt;li&gt;不要因为一个子程序里仅使用公用子程序，就把它归入公开接口&lt;/li&gt;
&lt;li&gt;不要对类的使用者做出任何假设，要格外警惕从语义上破坏封装：&lt;strong&gt;每当你发现自己是通过查看类的内部实现来得知该如何使用这个类的时候，你就不是在针对接口编程了，而是在透过接口针对内部实现编程了&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-3-有关设计和实现类的问题&quot;&gt;&lt;a href=&quot;#1-3-有关设计和实现类的问题&quot; class=&quot;headerlink&quot; title=&quot;1.3 有关设计和实现类的问题&quot;&gt;&lt;/a&gt;1.3 有关设计和实现类的问题&lt;/h2&gt;&lt;p&gt;通常类和类之间的关系，有“包含”和“继承”两种。继承需要更多的技巧，而且更容易出错，包含才是面向对象编程中的主力技术。以下是一些关于包含和继承技术的参考原则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;警惕包含超过约7个数据成员的类&lt;/li&gt;
&lt;li&gt;要么使用继承并进行详细说明，要么就不要用它：如果某个类并未设计为可被继承，要明确声明不可被继承&lt;/li&gt;
&lt;li&gt;遵循&lt;a href=&quot;http://baike.baidu.com/view/1688346.htm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;里氏替换原则&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;确保只继承需要继承的部分：注意父类方法的&lt;strong&gt;默认实现&lt;/strong&gt;和子类方法的&lt;strong&gt;覆盖（override）性&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;不要“覆盖”一个不可覆盖的成员函数：换种说法，即子类方法不要和父类的private方法同名&lt;/li&gt;
&lt;li&gt;把共用的接口、数据及操作放到继承树中尽可能高的位置&lt;/li&gt;
&lt;li&gt;只有一个实例的类是值得怀疑的：可以考虑用单例模式&lt;/li&gt;
&lt;li&gt;只有一个派生类的基类也值得怀疑：不要“提前设计”任何非绝对必要的继承结构&lt;/li&gt;
&lt;li&gt;派生后覆盖了某个子程序，但在其中没做任何操作，这种情况也值得怀：这表明基类的设计有错误&lt;/li&gt;
&lt;li&gt;避免让继承体系过深&lt;/li&gt;
&lt;li&gt;尽量使用多态，避免大量的类型检查：警惕频繁重复出现的switch case语句&lt;/li&gt;
&lt;li&gt;避免创建万能类/避免用动词命名的类/消除无关紧要的类&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关于类的数据和方法（包括构造函数）的参考原则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;让类中子程序的数量尽可能少&lt;/li&gt;
&lt;li&gt;禁止隐式地产生你不需要的成员函数和运算符&lt;/li&gt;
&lt;li&gt;减少类所使用的不同子程序的数量&lt;/li&gt;
&lt;li&gt;对其他类的子程序的间接调用要尽可能少&lt;/li&gt;
&lt;li&gt;如果可能，应该在所有的构造函数中初始化所有的数据成员&lt;/li&gt;
&lt;li&gt;用private构造函数来强制实现单例属性&lt;/li&gt;
&lt;li&gt;优先采用深拷贝，除非论证可行才使用浅拷贝&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://www.kancloud.cn/raytaylorlin/code-complete-checklist/135274&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;核对表：类的质量&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;2-高质量的子程序&quot;&gt;&lt;a href=&quot;#2-高质量的子程序&quot; class=&quot;headerlink&quot; title=&quot;2. 高质量的子程序&quot;&gt;&lt;/a&gt;2. 高质量的子程序&lt;/h1&gt;&lt;h2 id=&quot;2-1-创建子程序的理由&quot;&gt;&lt;a href=&quot;#2-1-创建子程序的理由&quot; class=&quot;headerlink&quot; title=&quot;2.1 创建子程序的理由&quot;&gt;&lt;/a&gt;2.1 创建子程序的理由&lt;/h2&gt;&lt;p&gt;创建子程序的理由包括但不限于：降低复杂度，引入中间的、易懂的抽象，避免代码重复，支持子类化，隐藏顺序，隐藏指针操作，提高可移植性，简化复杂的逻辑判断，改善性能。同样很多创建类的理由也是创建子程序的理由。&lt;/p&gt;
&lt;p&gt;注意一些过于简单的看上去似乎没必要写成子程序的操作，写一个只有两三行代码的子程序看起来有些大才小用，经常会成为心理障碍。但实际上小的子程序有许多优点，可以看看以下这个例子。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/* 不使用子程序：经常可以看到以下代码出现在十几处地方 */
// 从设备单位（device unit）到磅数（point）的转换计算
points = deviceUnits * （POINTS_PER_INCH / DeviceUnitsPerInch());

/* 使用子程序：不仅更具可读性（甚至达到自我注解的程度），可以更易于维护和测试 */
int DeviceUnitsToPoints(int deviceUnits) {
    if (DeviceUnitsPerInch() != 0)
        return deviceUnits * （POINTS_PER_INCH / DeviceUnitsPerInch();
    else
        return 0;
}
points = DeviceUnitsToPoints(deviceUnits);
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;2-2-好的子程序名字&quot;&gt;&lt;a href=&quot;#2-2-好的子程序名字&quot; class=&quot;headerlink&quot; title=&quot;2.2 好的子程序名字&quot;&gt;&lt;/a&gt;2.2 好的子程序名字&lt;/h2&gt;&lt;p&gt;一个子程序由名字、参数列表和程序体组成。一个好的名字能清晰地描述子程序所做的一切，是一个好的子程序的起点。子程序命名应该遵循如下原则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;描述子程序所做的&lt;strong&gt;所有&lt;/strong&gt;事情&lt;/li&gt;
&lt;li&gt;避免使用无意义的、模糊或表述不清的动词：像&lt;code&gt;Handle&lt;/code&gt;、&lt;code&gt;Perform&lt;/code&gt;、&lt;code&gt;Process&lt;/code&gt;等等动词都没有精确地描述操作，例如把&lt;code&gt;HandleOutput()&lt;/code&gt;改为&lt;code&gt;FormatAndPrintOutput()&lt;/code&gt;就能更容易看清楚子程序的功能。&lt;/li&gt;
&lt;li&gt;不要仅通过数字来形成不同的子程序各字：不要出现像&lt;code&gt;OutputUser1&lt;/code&gt;、&lt;code&gt;OutputUser2&lt;/code&gt;子程序然后将它们组成一个大程序的情况。&lt;/li&gt;
&lt;li&gt;根据需要确定子程序名字的长度：变量名的最佳长度是9到15个字符，而子程序要更复杂些，长短要视该名字是否清晰易懂而定。&lt;/li&gt;
&lt;li&gt;给函数命名时要对返回值有所描述：&lt;code&gt;customerid.Next()&lt;/code&gt;、&lt;code&gt;printer.IsReady()&lt;/code&gt;、&lt;code&gt;pen.CurrentColor()&lt;/code&gt;等都是不错的例子。&lt;/li&gt;
&lt;li&gt;给过程起名时使用语气强烈的动词加宾语的形式：如&lt;code&gt;PrintDocument()&lt;/code&gt;、&lt;code&gt;CheckOrderInfo()&lt;/code&gt;。对于面向对象语言是特例，因为对象（宾语）本身已经包含在调用语句中了，如&lt;code&gt;document.Print()&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;为常用操作确立命名规则：在实际项目中，约定一套语义命名规则。避免出现不同人写出像&lt;code&gt;employee.id.Get()&lt;/code&gt;，&lt;code&gt;employee.GetId()&lt;/code&gt;，&lt;code&gt;employee.id()&lt;/code&gt;这样难以记住的细节。&lt;/li&gt;
&lt;li&gt;准确使用对仗词：有助于保持一致性和可读性&lt;ul&gt;
&lt;li&gt;&lt;code&gt;add/remove&lt;/code&gt;，&lt;code&gt;open/close&lt;/code&gt;，&lt;code&gt;begin/end&lt;/code&gt;，&lt;code&gt;insert/delete&lt;/code&gt;，&lt;code&gt;show/hide&lt;/code&gt;，&lt;code&gt;create/destroy&lt;/code&gt;，&lt;code&gt;source/target&lt;/code&gt;，&lt;code&gt;first/last&lt;/code&gt;，&lt;code&gt;min/max&lt;/code&gt;，&lt;code&gt;start/stop&lt;/code&gt;，&lt;code&gt;get/set&lt;/code&gt;，&lt;code&gt;next/previous&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-3-写好子程序的参数&quot;&gt;&lt;a href=&quot;#2-3-写好子程序的参数&quot; class=&quot;headerlink&quot; title=&quot;2.3 写好子程序的参数&quot;&gt;&lt;/a&gt;2.3 写好子程序的参数&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;按照输入-修改-输出的顺序排列参数：不要随机地或按字母顺序排列参数&lt;/li&gt;
&lt;li&gt;&lt;em&gt;考虑自己创建IN和OUT关键字&lt;/em&gt;（特指C++）：定义无值的宏扩展C++语言，在项目中要极其谨慎&lt;/li&gt;
&lt;li&gt;如果几个子程序都用了类似的一些参数，应该让这些参数的排列顺序保持一致：如C语言中的&lt;code&gt;fprintf()/printf()&lt;/code&gt;，&lt;code&gt;strncpy()/memcpy()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用所有的参数：既然往子程序中传递了一个参数，就一定要用到这个参数。&lt;em&gt;使用条件编译而忽略了某一些参数的情况除外。&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;把状态或出错变量放在最后&lt;/li&gt;
&lt;li&gt;不要把子程序的参数用做工作变量：&lt;strong&gt;不要修改任何输入参数&lt;/strong&gt;，应明确引入一些中间的工作变量&lt;/li&gt;
&lt;li&gt;在接口中对参数的假定加以说明：用注释甚至断言，说明参数的单位、状态或错误值的含义、数值的范围、不该出现的特定数值等等&lt;/li&gt;
&lt;li&gt;把子程序的参数个数限制在大约7个以内：若传参过多，说明子程序之间的耦合过紧，应重新设计子程序&lt;/li&gt;
&lt;li&gt;考虑对参数采用某种表示输入、修改、输出的命名规则：如i&lt;em&gt;、m&lt;/em&gt;、Output_等前缀&lt;/li&gt;
&lt;li&gt;为子程序传递用以维持其接口抽象的变量或对象：考虑传入的是若干底层数据，还是一个包装对象&lt;/li&gt;
&lt;li&gt;确保实际参数与形式参数的类型相匹配：注意传入参数时可能发生的隐式类型转换&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-4-子程序的内容&quot;&gt;&lt;a href=&quot;#2-4-子程序的内容&quot; class=&quot;headerlink&quot; title=&quot;2.4 子程序的内容&quot;&gt;&lt;/a&gt;2.4 子程序的内容&lt;/h2&gt;&lt;p&gt;关于子程序的长度没有定论。与其对子程序的长度强加限制，还不如让下面这些因素——如子程序的内聚性、嵌套的层次、变量的数量、决策点的数量、解释子程序用意所需的注释数量以及其他些跟复杂度相关的考虑事项等——来决定子程度的长度。但是，这里要引用一下《代码整洁之道》3.1节“短小”中的内容来辅助参考子程序应该达到的长度。我个人总结，决定子程序的长短的唯一标准，是&lt;strong&gt;一个函数只做一件事&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;……经过漫长的试错，经验告诉我，函数就该小……函数也不该有100行那么长，20行封顶最佳……每个函数都一目了然。每个函数都只说一件事。而且，每个函数都依序把你带到下一个函数。这就是函数应该达到的短小程度！……通常来说，应该短于代码清单3-2中的函数（该函数有10行）……&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在子程序的设计上，应该注重其内聚性，即子程序中各种操作之间联系的紧密程度。我们的目标是让&lt;strong&gt;每个子程序只把一件事做好，不再做任何其他事情&lt;/strong&gt;。理解下面几个关于内聚性层次的概念有助于思考如何让子程序尽可能地内聚。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最好的内聚&lt;ul&gt;
&lt;li&gt;功能的内聚性：如&lt;code&gt;GetCustomerName()&lt;/code&gt;、&lt;code&gt;EraseFile()&lt;/code&gt;，前提是子程序所执行的操作与其名字相符。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;不够理想的内聚&lt;ul&gt;
&lt;li&gt;顺序上的内聚性：子程序内包含有需要按特定顺序执行的操作，这些步骤需要共享数据，而且只有在全部执行完毕后才完成了一项完整的功能。&lt;/li&gt;
&lt;li&gt;通信上的内聚性：一个子程序中的不同操作使用了同样的数据，但不存在其他任何联系。&lt;/li&gt;
&lt;li&gt;临时的内聚性：含有一些因为需要同时执行才放到一起的操作的子程序，如&lt;code&gt;Startup()&lt;/code&gt;中塞进一堆互不相关的初始化代码，应该把临时性的子程序看做是一系列事件的组织者，并去调用其他子程序。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;不可取的内聚&lt;ul&gt;
&lt;li&gt;过程上的内聚性：一个子程序中的操作是按特定的顺序进行的。&lt;/li&gt;
&lt;li&gt;逻辑上的内聚性：若干操作被放入同一个子程序中，通过传入的控制标志（由if/else或switch/case控制）选择执行其中的一项操作。这种情况下子程序唯一的功能应该是发布各种命令调用底层子程序，其自身并不做任何处理。&lt;/li&gt;
&lt;li&gt;巧合的内聚性：指子程序中的各个操作之间没有任何可以看到的关联。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://www.kancloud.cn/raytaylorlin/code-complete-checklist/135273&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;核对表：高质量的子程序&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;参考文献：电子工业出版社《代码大全（第2版）》第6、7章&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在计算时代的早期，程序员基于语句思考编程问题。到了20世纪七八十年代，程序员开始基于子程序去思考编程。进入21世纪，程序员以类为基础思考编程问题。类是由一组数据和子程序构成的集合，这些数据和子程序共同拥有一组内聚的、明确定义的职责。由此可见类和子程序在现代编程中的地位。本文将就如何创建高质量的类和子程序提供一些建议。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="综合" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/"/>
    
      <category term="软件工程" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="软件构建" scheme="http://raytaylorlin.com/tags/%E8%BD%AF%E4%BB%B6%E6%9E%84%E5%BB%BA/"/>
    
      <category term="软件工程" scheme="http://raytaylorlin.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="代码大全" scheme="http://raytaylorlin.com/tags/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>软件构建（二）——架构与设计</title>
    <link href="http://raytaylorlin.com/tech/complex/software/software-construction-2/"/>
    <id>http://raytaylorlin.com/tech/complex/software/software-construction-2/</id>
    <published>2016-04-01T03:37:35.000Z</published>
    <updated>2016-05-12T13:14:17.308Z</updated>
    
    <content type="html">&lt;p&gt;软件架构（software architecture）是软件设计的高层部分，是用于支撑更细节的设计的框架。本文关注的并不是如何开发一个软件的架构，而是设计一个架构时应该关注的部分。此外，设计就是把需求分析和编码调试连在一起的活动，好的高层设计能提供一个可以稳妥容纳多个较低层次设计的结构，其对于小型项目非常有用，对大型项目更是不可或缺。因此，本文将总结软件构建中设计的基础概念及基本方法。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-软件构建的主要活动&quot;&gt;&lt;a href=&quot;#1-软件构建的主要活动&quot; class=&quot;headerlink&quot; title=&quot;1. 软件构建的主要活动&quot;&gt;&lt;/a&gt;1. 软件构建的主要活动&lt;/h1&gt;&lt;h2 id=&quot;1-1-软件架构的概念&quot;&gt;&lt;a href=&quot;#1-1-软件架构的概念&quot; class=&quot;headerlink&quot; title=&quot;1.1 软件架构的概念&quot;&gt;&lt;/a&gt;1.1 软件架构的概念&lt;/h2&gt;&lt;p&gt;一个经过慎重考虑的架构为“从顶层到底层维护系统的概念完整性”提供了必备的结构和体系，它为程序员提供了指引，将工作分为几个部分，使多个开发者可以独立工作。好的架构使得构建活动变得更容易。糟糕的架构则使构建活动几乎寸步难行。在构建期间或者更晚的时候进行架构变更，代价也是高昂的。&lt;/p&gt;
&lt;h2 id=&quot;1-2-架构的典型组成部分&quot;&gt;&lt;a href=&quot;#1-2-架构的典型组成部分&quot; class=&quot;headerlink&quot; title=&quot;1.2 架构的典型组成部分&quot;&gt;&lt;/a&gt;1.2 架构的典型组成部分&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;程序组织：定义程序的主要构造块（子系统或模块），它们的责任以及它们之间的通信规则&lt;/li&gt;
&lt;li&gt;主要的类：指出每个主要的类的责任，以及该类如何与其他类交互（继承体系、状态转换、对象持久化等）&lt;/li&gt;
&lt;li&gt;数据设计：描述所用到的主要数据文件和数据表的设计&lt;/li&gt;
&lt;li&gt;业务规则：描述某些特殊的业务规则对系统设计的影响&lt;/li&gt;
&lt;li&gt;用户界面设计：架构应模块化，以便替换UI部分&lt;/li&gt;
&lt;li&gt;资源管理：描述管理稀缺资源（数据库连接、线程、内存等）的计划&lt;/li&gt;
&lt;li&gt;安全性：描述实现设计层面和代码层面的安全性的方法，并建立威胁模型&lt;/li&gt;
&lt;li&gt;性能：如果需要关注性能，就应该在需求中详细定义性能目标&lt;/li&gt;
&lt;li&gt;可伸缩性：描述系统如何应对未来需求的增长（如用户数量、服务器数量、网络节点数量等等）&lt;/li&gt;
&lt;li&gt;国际化/本地化：考虑典型的字符串和字符集问题&lt;/li&gt;
&lt;li&gt;输入/输出：定义数据的读取和写入策略&lt;/li&gt;
&lt;li&gt;错误处理：确定一种“一致处理错误”的策略（纠正还是检测错误？主动还是被动检测错误？程序如何传播错误？程序在什么层次处理错误？等等）&lt;/li&gt;
&lt;li&gt;容错性：考虑系统在出错时，让系统转入“部分运转”状态，还是某种“功能退化”状态，甚至自动关闭或重启&lt;/li&gt;
&lt;li&gt;架构的可行性：必须论证系统在技术上是否可实现&lt;/li&gt;
&lt;li&gt;关于“买”还是“造”的决策：决定购买组件，使用第三方组件，还是自己造轮子&lt;/li&gt;
&lt;li&gt;关于复用的决策：说明如何对复用的软件进行加工，使之符合其他架构目标&lt;/li&gt;
&lt;li&gt;变更策略：考虑如何让架构足够灵活，能够适应可能出现的变化&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://www.kancloud.cn/raytaylorlin/code-complete-checklist/133369&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;核对表：架构&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;2-软件构建中设计的基础&quot;&gt;&lt;a href=&quot;#2-软件构建中设计的基础&quot; class=&quot;headerlink&quot; title=&quot;2. 软件构建中设计的基础&quot;&gt;&lt;/a&gt;2. 软件构建中设计的基础&lt;/h1&gt;&lt;h2 id=&quot;2-1-理解设计的挑战&quot;&gt;&lt;a href=&quot;#2-1-理解设计的挑战&quot; class=&quot;headerlink&quot; title=&quot;2.1 理解设计的挑战&quot;&gt;&lt;/a&gt;2.1 理解设计的挑战&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;设计是一个险恶的问题：必须首先把这个问题“解决”一遍以便能够明确地定义它，然后再次解决该问题&lt;/li&gt;
&lt;li&gt;设计是个了无章法的过程：设计过程中会犯很多错，并且很难判断设计何时算是“足够好”&lt;/li&gt;
&lt;li&gt;设计就是确定取舍和调整顺序的过程&lt;/li&gt;
&lt;li&gt;设计受到诸多限制：时间、资源、空间等等&lt;/li&gt;
&lt;li&gt;设计是不确定的：让三个人设计同一套程序，可能会做出三套截然不同而且都不错的设计&lt;/li&gt;
&lt;li&gt;设计是一个启发式过程：由于充满不确定性，设计是具有探索性的不是能保证产生预期结果的可重复过程&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-2-关键的设计概念&quot;&gt;&lt;a href=&quot;#2-2-关键的设计概念&quot; class=&quot;headerlink&quot; title=&quot;2.2 关键的设计概念&quot;&gt;&lt;/a&gt;2.2 关键的设计概念&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;软件的首要技术使命便是管理复杂度。&lt;/strong&gt;在软件架构的层次上，可以通过把整个系统分解为多个子系统来降低问题的复杂度。子系统间的相互依赖越少，就越容易在同一时间里专注问题的一小部分。精心设计的对象关系使关注点相互分离，从而使你能在每个时刻只专注于一件事情。可以用这两种方法来管理复杂度：把任何人在同一时间需要处理的本质复杂度的量减到最少；不要让偶然性的复杂度无谓地快速增长。一旦你能理解软件开发中任何其他技术目标都不如管理复杂度重要时，众多设计上的考虑就都变得直截了当了。&lt;/p&gt;
&lt;h2 id=&quot;2-3-理想的设计特征&quot;&gt;&lt;a href=&quot;#2-3-理想的设计特征&quot; class=&quot;headerlink&quot; title=&quot;2.3 理想的设计特征&quot;&gt;&lt;/a&gt;2.3 理想的设计特征&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;最小的复杂度：设计要简单且易于理解&lt;/li&gt;
&lt;li&gt;易维护：为做维护工作的程序猿着想&lt;/li&gt;
&lt;li&gt;松散耦合：让程序的各个组成部分之间关联最小&lt;/li&gt;
&lt;li&gt;可扩展性：增强系统的功能而无须破坏其底层结构&lt;/li&gt;
&lt;li&gt;可重用性：系统的组成部分能在其他系统中重复使用&lt;/li&gt;
&lt;li&gt;高扇入：让大量的类使用某个给定的类（系统很好地利用了在较低层次上的工具类）&lt;/li&gt;
&lt;li&gt;低扇出：让一个类里少量或适中地使用其他的类&lt;/li&gt;
&lt;li&gt;可移植性：方便移植到其他环境中&lt;/li&gt;
&lt;li&gt;精简性：系统没有多余的部分&lt;/li&gt;
&lt;li&gt;层次性：保持系统各个分解层的层次性，使你能在任意的层面观察系统，并得到某种具有一致性的看法&lt;/li&gt;
&lt;li&gt;标准技术：尽量用标准化的、常用的方法，而不是依赖许多外来的稀奇古怪的技术或组件&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-4-设计的层次&quot;&gt;&lt;a href=&quot;#2-4-设计的层次&quot; class=&quot;headerlink&quot; title=&quot;2.4 设计的层次&quot;&gt;&lt;/a&gt;2.4 设计的层次&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://raytaylorlin-blog.qiniudn.com/image%2Fsoftware%2F%E4%B8%80%E4%B8%AA%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%B1%82%E6%AC%A1.png&quot; alt=&quot;一个软件系统的设计层次&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;3-软件构建中设计的方法&quot;&gt;&lt;a href=&quot;#3-软件构建中设计的方法&quot; class=&quot;headerlink&quot; title=&quot;3. 软件构建中设计的方法&quot;&gt;&lt;/a&gt;3. 软件构建中设计的方法&lt;/h1&gt;&lt;h2 id=&quot;3-1-启发式方法&quot;&gt;&lt;a href=&quot;#3-1-启发式方法&quot; class=&quot;headerlink&quot; title=&quot;3.1 启发式方法&quot;&gt;&lt;/a&gt;3.1 启发式方法&lt;/h2&gt;&lt;p&gt;由于软件设计是非确定性的，因此灵活熟练地运用一组有效的启发式方法（试探法），便成了合理的软件设计的核心工作。下面根据管理软件复杂度的原则，给出了一些参考的启发式设计方法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;找出现实世界中的对象&lt;ul&gt;
&lt;li&gt;辨识对象及其属性（数据）&lt;/li&gt;
&lt;li&gt;确定可以对各个对象进行的操作（方法）&lt;/li&gt;
&lt;li&gt;确定各个对象能对其他对象进行的操作&lt;/li&gt;
&lt;li&gt;确定对象的哪些部分对其他对象不可见&lt;/li&gt;
&lt;li&gt;定义每个对象的公开接口&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;形成一致的抽象：注意参考2.4中层次对系统分层抽象，抽象可以让你忽略无关的细节&lt;/li&gt;
&lt;li&gt;封装实现细节：抽象可以“让你从高层的细节来看待一个对象”，而封装则让你“不能看到对象的任何其他细节层次”&lt;/li&gt;
&lt;li&gt;信息隐藏&lt;ul&gt;
&lt;li&gt;类的接口应该尽可能少地暴露其内部工作机制&lt;/li&gt;
&lt;li&gt;隐藏复杂度，包括复杂的数据类型、文件结构、布尔判断以及晦涩的算法&lt;/li&gt;
&lt;li&gt;隐藏变化源，当变化发生时，其影响就能被限制在局部范围内&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;当继承能简化设计时就继承：继承很强大，但如果使用不当，也有极大的弊端&lt;/li&gt;
&lt;li&gt;找出容易改变的区域&lt;ul&gt;
&lt;li&gt;应对变化的措施：找出看起来容易变化的部分，单独划分成类，并设计好类接口将变化隔离开来&lt;/li&gt;
&lt;li&gt;容易变化的区域：业务规则、对硬件的依赖、输入输出、非标准的编程语言特性、困难的设计区域和构建区域、状态变量、数据量的限制等等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;保持松散耦合&lt;ul&gt;
&lt;li&gt;衡量模块间耦合度的参考标准：规模（模块间的连接数）、可见性（模块间连接的显著程度）、灵活性（模块间的连接是否容易改动）&lt;/li&gt;
&lt;li&gt;耦合的种类：简单数据参数耦合（模块间传简单类型数据，&lt;strong&gt;正常&lt;/strong&gt;）、简单对象耦合（一个模块实例化一个对象，&lt;strong&gt;正常&lt;/strong&gt;）、对象参数耦合（模块间传对象参数，&lt;strong&gt;谨慎&lt;/strong&gt;）、语义上的耦合（必须知道另一个模块内部工作细节才能使用，&lt;strong&gt;危险&lt;/strong&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;查阅常用的设计模式&lt;ul&gt;
&lt;li&gt;通过提供现成的抽象来减少复杂度&lt;/li&gt;
&lt;li&gt;通过把常见解决方案的细节予以制度化来减少出错&lt;/li&gt;
&lt;li&gt;通过提供多种设计方案而带来启发性的价值&lt;/li&gt;
&lt;li&gt;通过把设计对话提升到一个更高的层次上来简化与同事间的交流&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;其他启发式方法&lt;ul&gt;
&lt;li&gt;高内聚性：使类所达到的目标（内聚性）尽可能高&lt;/li&gt;
&lt;li&gt;为测试而设计：思考诸如“如果为了便于测试而设计这个系统，那么系统会是什么样子”的问题很有益处&lt;/li&gt;
&lt;li&gt;避免失误：充分考虑系统可能的失败模式&lt;/li&gt;
&lt;li&gt;画一个图：图可以在一个更高的抽象层次上表达问题&lt;/li&gt;
&lt;li&gt;创建中央控制点&lt;/li&gt;
&lt;li&gt;考虑使用蛮力突破&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;3-2-设计实践&quot;&gt;&lt;a href=&quot;#3-2-设计实践&quot; class=&quot;headerlink&quot; title=&quot;3.2 设计实践&quot;&gt;&lt;/a&gt;3.2 设计实践&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;迭代：在备选的设计方案之中&lt;strong&gt;循环并且尝试一些不同的做法&lt;/strong&gt;时，将同时从高层和低层的不同视角去审视问题。&lt;/li&gt;
&lt;li&gt;分而治之：把程序分解为不同的关注区域，然后分别处理每一个区域。&lt;/li&gt;
&lt;li&gt;自上而下和自下而上：前者始于抽象，逐步向底层分解；后者始于细节，向一般性延伸。两者并不冲突，可以相互协作。&lt;/li&gt;
&lt;li&gt;建立试验性原型：写出用于&lt;strong&gt;回答特定设计问题的、量最少且能够随时扔掉&lt;/strong&gt;的代码。注意不要把原型用在最终产品中。&lt;/li&gt;
&lt;li&gt;合作设计：与同事讨论，审查，甚至共同设计&lt;/li&gt;
&lt;li&gt;要做多少设计才够：若编码前还判断不了应该坐多深入的设计，宁可继续做更详细的设计，也不要事后才发现设计得还不够。&lt;/li&gt;
&lt;li&gt;记录设计成果：把设计文档插入到代码里、用Wiki来记录设计讨论和决策、写总结邮件、拍照、保留设计挂图、使用CRC（类、职责、合作者）卡片、在适当的细节层创建UML图&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://www.kancloud.cn/raytaylorlin/code-complete-checklist/134109&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;核对表：软件构造中的设计&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;参考文献：电子工业出版社《代码大全（第2版）》3.5节，第5章&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;软件架构（software architecture）是软件设计的高层部分，是用于支撑更细节的设计的框架。本文关注的并不是如何开发一个软件的架构，而是设计一个架构时应该关注的部分。此外，设计就是把需求分析和编码调试连在一起的活动，好的高层设计能提供一个可以稳妥容纳多个较低层次设计的结构，其对于小型项目非常有用，对大型项目更是不可或缺。因此，本文将总结软件构建中设计的基础概念及基本方法。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="综合" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/"/>
    
      <category term="软件工程" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="软件构建" scheme="http://raytaylorlin.com/tags/%E8%BD%AF%E4%BB%B6%E6%9E%84%E5%BB%BA/"/>
    
      <category term="软件工程" scheme="http://raytaylorlin.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="代码大全" scheme="http://raytaylorlin.com/tags/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>软件构建（一）——软件构建基础</title>
    <link href="http://raytaylorlin.com/tech/complex/software/software-construction-1/"/>
    <id>http://raytaylorlin.com/tech/complex/software/software-construction-1/</id>
    <published>2016-03-29T08:17:53.000Z</published>
    <updated>2016-05-12T13:14:11.842Z</updated>
    
    <content type="html">&lt;p&gt;开发计算机软件是一个非常复杂的过程，而软件“构建”是指建设过程中“动手”的部分，其中不仅仅包括“写代码”，还包含了计划、设计、测试、集成等等其他工作。本文首先总结软件构建的含义以及其主要活动；接着列举了一个比较合理的隐喻——建造房子——来理解软件开发；最后阐述了软件构建的前期准备工作的重要性，阐述了定义问题和分析需求的重要性，以及应该准备哪些事情。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-软件构建的主要活动&quot;&gt;&lt;a href=&quot;#1-软件构建的主要活动&quot; class=&quot;headerlink&quot; title=&quot;1. 软件构建的主要活动&quot;&gt;&lt;/a&gt;1. 软件构建的主要活动&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://raytaylorlin-blog.qiniudn.com/image%2Fsoftware%2F%E8%BD%AF%E4%BB%B6%E6%9E%84%E5%BB%BA%E7%9A%84%E4%B8%BB%E8%A6%81%E6%B4%BB%E5%8A%A8.png&quot; alt=&quot;软件构建的主要活动（阴影覆盖的部分）&quot;&gt;&lt;/p&gt;
&lt;p&gt;如图所示，软件构建活动主要是编码与调试，但也涉及详细设计、规划构建、单元测试、集成、集成测试等其他活动。下面列出一些具体的构建活动中的任务：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;验证有关的基础工作已经完成，因此构建活动可以顺利地进行下去&lt;/li&gt;
&lt;li&gt;确定如何测试所写的代码&lt;/li&gt;
&lt;li&gt;设计并编写类和子程序&lt;/li&gt;
&lt;li&gt;创建并命名变量和具名常量&lt;/li&gt;
&lt;li&gt;选择控制结构，组织语句块&lt;/li&gt;
&lt;li&gt;对代码进行单元测试和集成测试，并排除其中的错误&lt;/li&gt;
&lt;li&gt;评审开发团队其他成员的底层设计和代码，并让他们评审你的工作&lt;/li&gt;
&lt;li&gt;润饰代码，仔细进行代码的格式化和注释&lt;/li&gt;
&lt;li&gt;将单独开发的多个软件组件集成为一体&lt;/li&gt;
&lt;li&gt;调整代码，让它更快、更省资源&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;2-用隐喻来更充分地理解软件开发&quot;&gt;&lt;a href=&quot;#2-用隐喻来更充分地理解软件开发&quot; class=&quot;headerlink&quot; title=&quot;2. 用隐喻来更充分地理解软件开发&quot;&gt;&lt;/a&gt;2. 用隐喻来更充分地理解软件开发&lt;/h1&gt;&lt;p&gt;当向一个非程序员解释什么是软件开发的时候，最好的办法就是通过某种隐喻或类比来解释。隐喻把软件开发过程与其他你熟系的活动联系在一起，帮助你更好地理解。不同的隐喻彼此并不排斥，应当使用对你最有益处的某种隐喻组合。&lt;/p&gt;
&lt;p&gt;使用&lt;strong&gt;建造房子&lt;/strong&gt;是一个很好的隐喻，此处做个引用摘录：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;首先你要决定准备建一个什么类型的房子一一在软件开发里的类似事项称为问题定义。接下来，你必须和某个建筑师探讨这一总体设计，并得到批准。这跟软件架构设计十分相似。然后你画出详细的蓝图，雇一个承包人，就像软件的详细设计。再然后，你要准备好建造地点，打好地基，搭建房屋框架，砌好边墙，盖好房顶，通好水、电、煤气等。这就如同是软件的构建一样。在房子大部分完成之后，庭院设计师、油漆匠和装修工还要来把你新盖的家以及里面的家什美化一番。这就好比软件的优化过程。在整个过程中，还会有各种监查人员来检查工地、地基、框架、布线以及其他需要检查的地方。这相当于软件复查评审。&lt;/p&gt;
&lt;p&gt;建造一个房子的时候，你不会去试着建造那些能买得到的现成的东西。你会买洗衣机、烘干机、洗碗机、电冰箱以及冷藏柜……当开发软件时，你会大量使用高级语言所提供的功能，而不会自己去编写操作系统层次的代码。你可能还要用些现成的程序库，比如说一些容器类、科学计算函数、用户界面组件、数据库访问组件，等等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;3-前期准备&quot;&gt;&lt;a href=&quot;#3-前期准备&quot; class=&quot;headerlink&quot; title=&quot;3. 前期准备&quot;&gt;&lt;/a&gt;3. 前期准备&lt;/h1&gt;&lt;h2 id=&quot;3-1-前期准备的重要性&quot;&gt;&lt;a href=&quot;#3-1-前期准备的重要性&quot; class=&quot;headerlink&quot; title=&quot;3.1 前期准备的重要性&quot;&gt;&lt;/a&gt;3.1 前期准备的重要性&lt;/h2&gt;&lt;p&gt;就像修建建筑物一样，项目的成败很大程度上在构建活动开始之前就已经注定了。建造住宅小区的施工人员，在开始建造第一栋房子之前，并不需要知道小区里面每一栋房子的每一个细节。但他会调查施工场所，制定下水道和电线的走向等。如果施工人员准备不充分，那么建造过程很可能会因为“需要在某所已经造好的房子的地下挖一条下水道”而延误。&lt;/p&gt;
&lt;p&gt;准备工作的中心目标就是降低风险：一个好的项目规划者能够尽可能早地将主要的风险清除掉，以便项目的大部分工作能够尽可能平稳地进行。有时候用户在一开始并不完全确定自己想要的是什么，因此值得花费比理想情况下更多的力气，找出他们真正想要的东西。但这至少比“先做一个错误的东西出来，然后扔掉，并从头来过”的成本要低廉。&lt;/p&gt;
&lt;h2 id=&quot;3-2-准备工作和构建活动的平衡&quot;&gt;&lt;a href=&quot;#3-2-准备工作和构建活动的平衡&quot; class=&quot;headerlink&quot; title=&quot;3.2 准备工作和构建活动的平衡&quot;&gt;&lt;/a&gt;3.2 准备工作和构建活动的平衡&lt;/h2&gt;&lt;p&gt;真实项目大致可以分为“商业系统”（Web站点、游戏、信息管理系统等），“使命攸关的系统”（软件工具、盒装软件、Web服务等）和“使命攸关的嵌入式系统”（航空软件、医疗设备、操作系统等）三大类。不同种类的软件项目，需要在“准备工作”和“构建活动”之间做出不同的平衡。你应该首先确定哪些前期准备活动适合你的项目。有些项目在前期准备土面花的时间太少了，结果使得在构建活动中遇到大量不必要的反复修改，同时阻碍了项目的稳步前进。有些项目则预先做了太多的事情，固执地坚持原有的需求和计划，后来事实证明这些需求和计划是无效的，这同样阻止了构建活动的顺利进展。此外，项目的实际情况也决定了哪一种开发方法更加合适，下表给出了参考。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;需求&lt;/th&gt;
&lt;th&gt;设计&lt;/th&gt;
&lt;th&gt;领域熟悉程度&lt;/th&gt;
&lt;th&gt;项目风险&lt;/th&gt;
&lt;th&gt;后期改动代价&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;序列式开发&lt;/td&gt;
&lt;td&gt;稳定&lt;/td&gt;
&lt;td&gt;直截了当&lt;/td&gt;
&lt;td&gt;熟悉&lt;/td&gt;
&lt;td&gt;小&lt;/td&gt;
&lt;td&gt;昂贵&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;迭代式开发&lt;/td&gt;
&lt;td&gt;不稳定&lt;/td&gt;
&lt;td&gt;复杂，有挑战性&lt;/td&gt;
&lt;td&gt;不熟悉&lt;/td&gt;
&lt;td&gt;大&lt;/td&gt;
&lt;td&gt;较低&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&quot;3-3-明确问题和需求&quot;&gt;&lt;a href=&quot;#3-3-明确问题和需求&quot; class=&quot;headerlink&quot; title=&quot;3.3 明确问题和需求&quot;&gt;&lt;/a&gt;3.3 明确问题和需求&lt;/h2&gt;&lt;p&gt;在开始构建之前，必须对这个系统要解决的&lt;strong&gt;问题&lt;/strong&gt;做出清楚的描述。“问题定义”只定义了“问题是什么”，应该从客户的角度用客户的语言来描述问题，而不应该用计算机的专业术语叙述（除非需要解决的就是与计算机本身相关的问题）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;需求&lt;/strong&gt; 详细描述软件系统应该做什么。明确的需求有助于确保是用户（而不是程序员〉驾驭系统的功能，有助于减少开始编程开发之后的系统变更情况，有助于避免争论。但是在构建期间，需求通常会有25%的变化，要更好地应对需求变更，可以采用以下方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用&lt;a href=&quot;http://www.kancloud.cn/raytaylorlin/code-complete-checklist/132375&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;需求核对表&lt;/a&gt;来评估你的需求的质量&lt;/li&gt;
&lt;li&gt;确保每一个人都知道需求变更的代价&lt;/li&gt;
&lt;li&gt;建立一套变更控制程序&lt;/li&gt;
&lt;li&gt;使用能适应变更的开发方法（如演进原型、演进交付）&lt;/li&gt;
&lt;li&gt;考虑项目的商业价值&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;3-4-花费在前期准备上的时间&quot;&gt;&lt;a href=&quot;#3-4-花费在前期准备上的时间&quot; class=&quot;headerlink&quot; title=&quot;3.4 花费在前期准备上的时间&quot;&gt;&lt;/a&gt;3.4 花费在前期准备上的时间&lt;/h2&gt;&lt;p&gt;一般说来，一个运作良好的项目会在需求、架构以及其他前期计划方面投入10%~20%的工作量和20%~30%的时间。如果需求不稳定，同时你从事的是一个大型正式项目，那你就很可能需要为“与需求分析师协商”预留一些时间，以解决构建活动早期指出的需求问题；如果从事的是小型非正式项目，要预留足够的时间，将需求定义足够清晰，让需求的不稳定性对构建活动的负面影响降至最低。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这就好比你是一名承包商，有人请你建一栋房子。客户问你：“完成这项工作要花多少钱？”你会合理地询间：“你想要我做什么？”客户说：“我不能告诉你，不过我想知道需要花费多少钱？”你该明智地感谢他浪费了你的时间，然后转身回家。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;参考文献：电子工业出版社《代码大全（第2版）》第1-4章&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;开发计算机软件是一个非常复杂的过程，而软件“构建”是指建设过程中“动手”的部分，其中不仅仅包括“写代码”，还包含了计划、设计、测试、集成等等其他工作。本文首先总结软件构建的含义以及其主要活动；接着列举了一个比较合理的隐喻——建造房子——来理解软件开发；最后阐述了软件构建的前期准备工作的重要性，阐述了定义问题和分析需求的重要性，以及应该准备哪些事情。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="综合" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/"/>
    
      <category term="软件工程" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="软件构建" scheme="http://raytaylorlin.com/tags/%E8%BD%AF%E4%BB%B6%E6%9E%84%E5%BB%BA/"/>
    
      <category term="软件工程" scheme="http://raytaylorlin.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="代码大全" scheme="http://raytaylorlin.com/tags/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>新版Hexo主题Raytaylorism v2发布</title>
    <link href="http://raytaylorlin.com/daily/hexo-theme-raytaylorism-v2/"/>
    <id>http://raytaylorlin.com/daily/hexo-theme-raytaylorism-v2/</id>
    <published>2016-03-18T03:28:32.000Z</published>
    <updated>2016-03-29T07:03:33.085Z</updated>
    
    <content type="html">&lt;p&gt;时隔两年多，我自制的Hexo主题Raytaylorism（&lt;a href=&quot;https://github.com/raytaylorlin/hexo-theme-raytaylorism&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Github地址&lt;/a&gt;）终于喜迎v2版本的发布。这个项目可以说是我在学生时代Web前端领域中的收官之作，因此在本次升级主题的过程中，一切都尽量做到精细。例如所有的页面都经过重新设计，采用清新的的响应式的Material Design风格，加入了个性化的“读书”“关于”页面，以及皮肤自定义、分类目录、正文滚动目录、打赏等等特色功能，并且该主题支持最新的Hexo 3.1版本。由于主题的功能较为复杂，所有的安装说明和配置事项都写在了Github项目的README中，需要使用主题的同学请&lt;strong&gt;认真仔细阅读README&lt;/strong&gt;哦，&lt;strong&gt;特别是&lt;a href=&quot;https://github.com/raytaylorlin/hexo-theme-raytaylorism#启用重要&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;启用&lt;/a&gt;那一节的说明很重要！很重要！很重要！一定要照做否则你会发现hexo启动不起来或最终效果和截图上的不一样。&lt;/strong&gt; 使用过程中有任何问题欢迎给我开issue。下面正文将介绍主题在Github上没有详细解释但又非常有特色的功能。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-换肤功能&quot;&gt;&lt;a href=&quot;#1-换肤功能&quot; class=&quot;headerlink&quot; title=&quot;1. 换肤功能&quot;&gt;&lt;/a&gt;1. 换肤功能&lt;/h1&gt;&lt;p&gt;我个人非常喜欢Material Design这种简洁清新的设计风格，也非常喜欢其定义的各种颜色。博客主题是一种非常个性化的东西，我喜欢的配色方案（包括主题默认的indigo-pink方案）不一定是你喜欢的，因此raytaylorism在几乎所有带颜色的区域都预留了配置的接口（具体参见&lt;a href=&quot;https://github.com/raytaylorlin/hexo-theme-raytaylorism#样式&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;README-样式-主题颜色配置&lt;/a&gt;）。不过，总有一些设计感不强的同学不知道如何下手，所以下面给出了3款参考的皮肤配置方案，大家可以各取所需随意发挥。配色的一个基本原则，就是选好一种主色和强调色。&lt;/p&gt;
&lt;h2 id=&quot;1-1-夏日甜橙&quot;&gt;&lt;a href=&quot;#1-1-夏日甜橙&quot; class=&quot;headerlink&quot; title=&quot;1.1 夏日甜橙&quot;&gt;&lt;/a&gt;1.1 夏日甜橙&lt;/h2&gt;&lt;p&gt;主色：blue 强调色：deep-orange&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://raytaylorlin-blog.qiniudn.com/image%2Fdaily%2Fblue_deeporange.jpg&quot; alt=&quot;夏日甜橙&quot;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;color:
    header: indigo
    footer: indigo
    page_nav: indigo
    side_nav: indigo darken-1
    tag: green accent-4
    link: indigo
    pagination: green
    tab: green
    archive_item: grey
    fab: green
    fab_2: blue
    fab_3: orange
    new: pink
    about_header: indigo
    about_title: indigo
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;1-2-绿野仙踪&quot;&gt;&lt;a href=&quot;#1-2-绿野仙踪&quot; class=&quot;headerlink&quot; title=&quot;1.2 绿野仙踪&quot;&gt;&lt;/a&gt;1.2 绿野仙踪&lt;/h2&gt;&lt;p&gt;主色：green 强调色：red&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://raytaylorlin-blog.qiniudn.com/image%2Fdaily%2Fgreen_red.jpg&quot; alt=&quot;绿野仙踪&quot;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;color:
    header: green
    footer: green
    page_nav: green
    side_nav: green darken-1
    tag: red lighten-1
    article_title_link: green
    link: red
    pagination: red
    tab: red
    archive_item: grey
    fab: red
    fab_2: cyan
    fab_3: light-green
    new: red
    about_header: green
    about_title: green
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;1-3-林地木屋&quot;&gt;&lt;a href=&quot;#1-3-林地木屋&quot; class=&quot;headerlink&quot; title=&quot;1.3 林地木屋&quot;&gt;&lt;/a&gt;1.3 林地木屋&lt;/h2&gt;&lt;p&gt;主色：brown 强调色：light-green&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://raytaylorlin-blog.qiniudn.com/image%2Fdaily%2Fbrown_lightgreen.jpg&quot; alt=&quot;林地木屋&quot;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;color:
    header: brown darken-1
    footer: brown darken-1
    page_nav: brown darken-1
    side_nav: brown darken-1
    tag: light-green
    article_title_link: brown
    link: light-green
    pagination: light-green
    tab: light-green
    archive_item: grey
    fab: light-green
    fab_2: red
    fab_3: purple
    new: light-green
    about_header: brown darken-1
    about_title: brown
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;2-文章分类目录&quot;&gt;&lt;a href=&quot;#2-文章分类目录&quot; class=&quot;headerlink&quot; title=&quot;2. 文章分类目录&quot;&gt;&lt;/a&gt;2. 文章分类目录&lt;/h1&gt;&lt;p&gt;如果点击我的博客菜单中的“分类”按钮，会发现左侧侧滑栏会出来一个带有多个层级的文章分类列表。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://raytaylorlin-blog.qiniudn.com/image%2Fdaily%2Fraytaylorism-category.png&quot; alt=&quot;主题的分类目录&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果你也想要得到类似的效果（包括标签tag），需要按照&lt;a href=&quot;https://hexo.io/docs/front-matter.html#Categories-amp-Tags&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;hexo官方的categories/tags说明文档&lt;/a&gt;给你的博客文章设置正确的&lt;code&gt;categories&lt;/code&gt;和&lt;code&gt;tags&lt;/code&gt;配置项。也就是说你的每一篇博文的markdown文件中，需要设置类似于下方的几行配置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;categories:
- 一级目录
- 二级目录
- 三级目录
tags:
- 第一个标签
- 第二个标签
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;准确设置后，启动hexo时主题会自动解析所有文章并形成分类树，最终生成上图那样的分类层次。&lt;/p&gt;
&lt;h1 id=&quot;3-读书页面&quot;&gt;&lt;a href=&quot;#3-读书页面&quot; class=&quot;headerlink&quot; title=&quot;3. 读书页面&quot;&gt;&lt;/a&gt;3. 读书页面&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://raytaylorlin-blog.qiniudn.com/image%2Fdaily%2Fraytaylorism-reading.png&quot; alt=&quot;读书页面截图&quot;&gt;&lt;/p&gt;
&lt;p&gt;在&lt;a href=&quot;https://github.com/raytaylorlin/hexo-theme-raytaylorism#数据&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;README-数据-读书页面&lt;/a&gt;中其实已经说明了如何配置读书页面的数据，照着例子来改就行了。值得注意的是，“已读”“在读”“想读”这些标签的文字是可以通过&lt;code&gt;reading.json&lt;/code&gt;中的&lt;code&gt;define&lt;/code&gt;字段来修改的，甚至你还可以仿照读书页面，扩展出自己的专属页面，例如“作品”页面等。只要是满足这种列表条目的数据均可以在其上自由发挥。&lt;/p&gt;
&lt;h1 id=&quot;4-关于页面&quot;&gt;&lt;a href=&quot;#4-关于页面&quot; class=&quot;headerlink&quot; title=&quot;4. 关于页面&quot;&gt;&lt;/a&gt;4. 关于页面&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://raytaylorlin-blog.qiniudn.com/image%2Fdaily%2Fraytaylorism-about.png&quot; alt=&quot;关于页面截图&quot;&gt;&lt;/p&gt;
&lt;p&gt;在&lt;a href=&quot;https://github.com/raytaylorlin/hexo-theme-raytaylorism#数据&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;README-数据-关于页面&lt;/a&gt;中也说明了个&lt;code&gt;about.json&lt;/code&gt;中各个字段的含义，照着例子改就行了。&lt;/p&gt;
&lt;p&gt;另外关于页面的末尾还有一个“打赏”功能，点开后会出现微信和支付宝的二维码，这个需要你自己去制作自己的付款二维码，然后把&lt;code&gt;reward&lt;/code&gt;字段的两个图片链接替换掉。如果暂时不需要的话请将该字段设为null，&lt;strong&gt;千万不要傻乎乎地把主题照搬让别人给我的账号打赏了=。=&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;关于主题任何使用上的疑问，欢迎在&lt;a href=&quot;https://github.com/raytaylorlin/hexo-theme-raytaylorism/issues&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Issues&lt;/a&gt;上提问。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;时隔两年多，我自制的Hexo主题Raytaylorism（&lt;a href=&quot;https://github.com/raytaylorlin/hexo-theme-raytaylorism&quot;&gt;Github地址&lt;/a&gt;）终于喜迎v2版本的发布。这个项目可以说是我在学生时代Web前端领域中的收官之作，因此在本次升级主题的过程中，一切都尽量做到精细。例如所有的页面都经过重新设计，采用清新的的响应式的Material Design风格，加入了个性化的“读书”“关于”页面，以及皮肤自定义、分类目录、正文滚动目录、打赏等等特色功能，并且该主题支持最新的Hexo 3.1版本。由于主题的功能较为复杂，所有的安装说明和配置事项都写在了Github项目的README中，需要使用主题的同学请&lt;strong&gt;认真仔细阅读README&lt;/strong&gt;哦，&lt;strong&gt;特别是&lt;a href=&quot;https://github.com/raytaylorlin/hexo-theme-raytaylorism#启用重要&quot;&gt;启用&lt;/a&gt;那一节的说明很重要！很重要！很重要！一定要照做否则你会发现hexo启动不起来或最终效果和截图上的不一样。&lt;/strong&gt; 使用过程中有任何问题欢迎给我开issue。下面正文将介绍主题在Github上没有详细解释但又非常有特色的功能。&lt;/p&gt;
    
    </summary>
    
      <category term="日常" scheme="http://raytaylorlin.com/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="博客" scheme="http://raytaylorlin.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="Hexo" scheme="http://raytaylorlin.com/tags/Hexo/"/>
    
  </entry>
  
</feed>
