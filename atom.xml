<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ray Taylor Lin&#39;s world</title>
  <subtitle>林寿山的技术博客 Ray Taylor Lin&#39;s world</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://raytaylorlin.com/"/>
  <updated>2016-12-31T14:52:35.540Z</updated>
  <id>http://raytaylorlin.com/</id>
  
  <author>
    <name>Ray Taylor Lin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>运行时游戏对象模型（上）——模型架构</title>
    <link href="http://raytaylorlin.com/tech/game/engine/runtime-gameobject-model/"/>
    <id>http://raytaylorlin.com/tech/game/engine/runtime-gameobject-model/</id>
    <published>2016-12-31T14:37:32.000Z</published>
    <updated>2016-12-31T14:52:35.540Z</updated>
    
    <content type="html">&lt;p&gt;在游戏性基础系统的各种组件中，运行时对象模型可能是最复杂的，通常它会提供这些核心功能：动态产生（spawn）和销毁（destroy）游戏对象，联系底层引擎系统，实时模拟对象行为，对象查询和引用，存档及对象持久性等等。本文将从对象模型架构开始，阐述“以对象为中心”和“以属性为中心”的两种基本架构，接着介绍几种游戏对象引用和查询的方法。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-各种运行时对象模型架构&quot;&gt;&lt;a href=&quot;#1-各种运行时对象模型架构&quot; class=&quot;headerlink&quot; title=&quot;1. 各种运行时对象模型架构&quot;&gt;&lt;/a&gt;1. 各种运行时对象模型架构&lt;/h1&gt;&lt;h2 id=&quot;1-1-以对象为中心的架构&quot;&gt;&lt;a href=&quot;#1-1-以对象为中心的架构&quot; class=&quot;headerlink&quot; title=&quot;1.1 以对象为中心的架构&quot;&gt;&lt;/a&gt;1.1 以对象为中心的架构&lt;/h2&gt;&lt;p&gt;这种架构中每个逻辑游戏对象会实现为类的实例，或一组互相连接的实例。然而单纯使用继承和多态会导致一系列类层次结构的问题。&lt;/p&gt;
&lt;h3 id=&quot;1-1-1-使用面向对象架构的问题&quot;&gt;&lt;a href=&quot;#1-1-1-使用面向对象架构的问题&quot; class=&quot;headerlink&quot; title=&quot;1.1.1 使用面向对象架构的问题&quot;&gt;&lt;/a&gt;1.1.1 使用面向对象架构的问题&lt;/h3&gt;&lt;p&gt;类层次结构逐渐变得单一庞大。如下图①实现《吃豆人》（PacMan）的一种简单类结构，随着功能增长，该结构会同时往纵、横方向发展，并出现以下问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类难以理解、维护及修改：要理解一个类，就要理解其所有父类（例如在派生类中修改一个看似无害的虚函数，就可能会违背了众基类中某个基类的假设），参考下图②复杂的单一类树节选&lt;/li&gt;
&lt;li&gt;不能表达多维分类：继承有着“是一个”的语义，导致在分类对象时只能从一个维度去设计。如下图③，各类载具的分类看似合乎逻辑，但如果再加入一种“水陆两用载具”则无从下手&lt;/li&gt;
&lt;li&gt;多重继承的弊端：解决“水陆两用载具”的解决方法之一就是使用C++的多重继承，如下图④。然而多重继承有其严重弊端，此处不再赘述&lt;/li&gt;
&lt;li&gt;使用接口：像C#或Java类只能继承一个类，但可以实现多个接口，这样共用的功能就能抽出来（也称为mix-in类）。如下图⑤，任何继承MHealth的类会有血量信息，并可以被杀&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;冒泡效应&lt;/strong&gt;：当游戏加入越来越多的功能，程序员很容易不断把若干个类中&lt;strong&gt;公用但与基类无关&lt;/strong&gt;的代码上升到基类中（即为了所谓的复用利用了继承的便利），这种趋势会令功能代码沿层次结构上移到基类（冒泡），从而违背类职责应该保持单一的原则&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://raytaylorlin-blog.qiniudn.com/image/engine/%E4%BD%BF%E7%94%A8%E5%8D%95%E4%B8%80%E5%BA%9E%E5%A4%A7%E7%9A%84%E7%B1%BB%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E7%9A%84%E5%90%84%E7%A7%8D%E9%97%AE%E9%A2%98.jpg&quot; alt=&quot;使用单一庞大的类层次结构的各种问题&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;1-1-2-使用“合成”来简化层次结构&quot;&gt;&lt;a href=&quot;#1-1-2-使用“合成”来简化层次结构&quot; class=&quot;headerlink&quot; title=&quot;1.1.2 使用“合成”来简化层次结构&quot;&gt;&lt;/a&gt;1.1.2 使用“合成”来简化层次结构&lt;/h3&gt;&lt;p&gt;面向对象设计中过度使用“是一个（is-a）”关系，会限制了我们创造新游戏类型的设计选择，而且难以扩展现存类的功能。若像下图左边的继承结构，希望一个游戏对象类有碰撞功能，它必须要继承自CollidableObject ，即使它可能是隐形的而并不需要RenderableObject的功能。若把不同的功能分离为独立的“组件”类，它们互不相干，由一个轻量的GameObject采用“有一个（has-a）”关系持有并管理，如下图右边，则可以大大简化。Unity便是运用这种思想的例子。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://raytaylorlin-blog.qiniudn.com/image/engine/%E4%BD%BF%E7%94%A8%E7%BB%84%E4%BB%B6%E5%90%88%E6%88%90%E6%B8%B8%E6%88%8F%E5%AF%B9%E8%B1%A1.jpg&quot; alt=&quot;使用组件合成游戏对象&quot;&gt;&lt;/p&gt;
&lt;p&gt;对于GameObject管理其组件声明周期的具体实现，具体的做法是GameObject持有所有可能组件的指针并默认为空，而具体的游戏对象继承GameObject后，自行初始化所需的基本组件，并实现自己的特殊组件。但是当需要扩展新组件时，都要修改GameObject类，不符合开闭原则，因此更好的做法是以下这种GameObject持有Component列表的结构。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://raytaylorlin-blog.qiniudn.com/image/engine/%E4%BD%BF%E7%94%A8%E9%80%9A%E7%94%A8%E7%BB%84%E4%BB%B6%E7%9A%84%E8%AE%BE%E8%AE%A1.jpg&quot; alt=&quot;使用通用组件的设计&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-2-以属性为中心的架构&quot;&gt;&lt;a href=&quot;#1-2-以属性为中心的架构&quot; class=&quot;headerlink&quot; title=&quot;1.2 以属性为中心的架构&quot;&gt;&lt;/a&gt;1.2 以属性为中心的架构&lt;/h2&gt;&lt;p&gt;以对象为中心，会自然地关注对象属性和行为。以属性为中心，则是先定义所有属性，再为每个属性键表存储关联该属性的对象，&lt;em&gt;像数据库表就是这种设计&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;这种设计的优点是趋向更有效地使用内存，因为只需储存实际上用到的属性；也更容易使用数据驱动的方式来建模。最后是比以对象为中心的模型更加缓存友好，因为有些游戏硬件的内存存取成本远高于执行指令和运算。把数据连续储存于内存之中，能减少或消除缓存命中失败。这种数据布局方式称为&lt;strong&gt;数组的结构（struct of array）&lt;/strong&gt;。以下代码展示了与传统 &lt;em&gt;结构的数组（array of struct）&lt;/em&gt;的对比。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static const U32 MAX_GAME_OBJECTS = 1024;
// 传统结构的数组方式
struct GameObject
{
    U32 m_uniqueId;
    Vector m_pos;
    Quaternion m_rot;
};
GameObject g_AllGameObjects[MAX_GAME_OBJECTS];

// 对缓存更友好的数组的结构方式
struct AllGameObjects
{
    U32 m_UniqueId[MAX_GAME_OBJECTS];
    Vector m_Pos[MAX_GAME_OBJECTS];
    Quaternion m_Rot[MAX_GAME_OBJECTS];
}
AllGameObjects g_allGameObjects;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这种设计的缺点是单凭凑齐一些细粒度的属性去实现一个大规模的行为，并非易事。这种系统也可能更难以除错，因为程序员不能一次性地把游戏对象拉到监视视窗中检查它的属性。&lt;/p&gt;
&lt;h1 id=&quot;2-对象引用与世界查询&quot;&gt;&lt;a href=&quot;#2-对象引用与世界查询&quot; class=&quot;headerlink&quot; title=&quot;2. 对象引用与世界查询&quot;&gt;&lt;/a&gt;2. 对象引用与世界查询&lt;/h1&gt;&lt;h2 id=&quot;2-1-对象引用方法&quot;&gt;&lt;a href=&quot;#2-1-对象引用方法&quot; class=&quot;headerlink&quot; title=&quot;2.1 对象引用方法&quot;&gt;&lt;/a&gt;2.1 对象引用方法&lt;/h2&gt;&lt;h3 id=&quot;2-1-1-指针&quot;&gt;&lt;a href=&quot;#2-1-1-指针&quot; class=&quot;headerlink&quot; title=&quot;2.1.1 指针&quot;&gt;&lt;/a&gt;2.1.1 指针&lt;/h3&gt;&lt;p&gt;每个游戏对象通常需要某种唯一标识符以便互相区分，并且能在运行时或工具方（世界编辑器）找到所需的对象，也可用该标识符作为对象间通信的目标。当通过查询找到一个游戏对象时，需要以某种方式引用它。C/C++中最常见的做法就是使用指针，因为指针是实现对象引用最快、最高效并最容易使用的方式。但使用指针很容易出现孤立对象、过时指针、无效指针等问题，所以开发引擎的团队制定严格的编程惯例，或使用安全的约束方法如智能指针。&lt;/p&gt;
&lt;p&gt;智能指针是一个小型对象，行为与指针非常接近，但其扩展了规避原始C/C++指针所衍生的问题。关于智能指针可参考C++的一些高级书目，此处不赘述，仅建议&lt;strong&gt;尽量不要在项目中尝试自己实现恶心的智能指针&lt;/strong&gt;，如果必须使用，尽量选用像Boost这样的成熟实现。&lt;/p&gt;
&lt;h3 id=&quot;2-1-2-句柄&quot;&gt;&lt;a href=&quot;#2-1-2-句柄&quot; class=&quot;headerlink&quot; title=&quot;2.1.2 句柄&quot;&gt;&lt;/a&gt;2.1.2 句柄&lt;/h3&gt;&lt;p&gt;句柄就是某全局句柄表的整数索引，而句柄表则储存指向引用对象的指针。下图说明了此数据结构。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://raytaylorlin-blog.qiniudn.com/image/engine/%E5%8F%A5%E6%9F%84%E5%BC%95%E7%94%A8%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8.jpg&quot; alt=&quot;句柄引用对象的实现方式及常见应用&quot;&gt;&lt;/p&gt;
&lt;p&gt;虽然句柄可以实现为原始整数，但句柄表的索引通常会包装成一个简单类，以提供更方便创建句柄和解引用的接口。以下是一种简单实现（省略其他与句柄无关的实现）。注意在。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/* GameObject类储存了它的句柄索引，当要创建新句柄时就不用以地址搜寻句柄表了 */
class GameObject
{
private:
    GameObjectId m_uniqueId;  // 对象唯一标识符
    U32 m_handleIndex;  // 供更快地创建句柄
    friend class GameObjectHandle;  // 让它访问id及索引
public:
    GameObject()
    {
        m_uniqueId = AssignUniqueObjectId();
        m_handleIndex = FindFreeSlotInHandleTable();
    }
}

// 定义句柄表的大小，以及同时间的最大对象数目
static const U32 MAX_GAME_OBJECTS = ...;
// 全局句柄表，只是简单的数组，储存游戏对象指针
static GameObject* g_apGameObject[MAX_GAME_OBJECTS];

/* 句柄封装类 */
class GameObjectHandle
{
private：
    U32 m_handleIndex;
    GameObjectId m_uniqueId;
public:
    explicit GameObjectHandle(GameObject&amp;amp; object) :
        m_handleIndex(object.m_handleIndex),
        m_uniqueId(object.m_uniqueId) {}
    // 句柄解引用
    GameObject* ToObject() const
    {
        GameObject* pObject = g_apGameObject[m_handleIndex];
        if (pObject != NULL &amp;amp;&amp;amp; pObject-&amp;gt;m_uniqueId == m_uniqueId)
            return pObject;
        return NULL;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;2-2-对象查询方法&quot;&gt;&lt;a href=&quot;#2-2-对象查询方法&quot; class=&quot;headerlink&quot; title=&quot;2.2 对象查询方法&quot;&gt;&lt;/a&gt;2.2 对象查询方法&lt;/h2&gt;&lt;p&gt;取决于具体的游戏设计，开发者需要根据业务来查询不同种类的对象，例如找出玩家视线范围内的所有敌人角色，找出所有血量少于80%的可破坏游戏对象等等。游戏团队通常要判断，在游戏开发过程中哪些是可能最常用到的查询类型，并实现专用的数据结构加速查询。以下列举了一些可用于加速某类游戏对象查询的专门的数据结构。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以唯一标识符搜寻：游戏对象的指针或句柄可储存于以唯一标识符为键的散列表或二叉查找树&lt;/li&gt;
&lt;li&gt;对合乎某条件的所有对象进行迭代：可预先以某种条件排序，并把结果储存在某个列表（例如不断维护一个在玩家某半径范围内的所有对象的列表来加速查询实现范围内的敌人）&lt;/li&gt;
&lt;li&gt;搜寻抛射体路径或对某目标点视线内的所有对象：通常会利用碰撞系统实现，多数碰撞系统会提供一些极快的光线投射功能&lt;/li&gt;
&lt;li&gt;搜寻某区域或半径范围内的所有对象：用一些空间散列数据结构去储存游戏对象，如四叉树、八叉树、kd树等等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考文献：电子工业出版社《游戏引擎架构》第14.1、14.2、14.5节&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在游戏性基础系统的各种组件中，运行时对象模型可能是最复杂的，通常它会提供这些核心功能：动态产生（spawn）和销毁（destroy）游戏对象，联系底层引擎系统，实时模拟对象行为，对象查询和引用，存档及对象持久性等等。本文将从对象模型架构开始，阐述“以对象为中心”和“以属性为中心”的两种基本架构，接着介绍几种游戏对象引用和查询的方法。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="游戏开发" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
      <category term="游戏引擎" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    
      <category term="游戏引擎" scheme="http://raytaylorlin.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
      <category term="游戏对象模型" scheme="http://raytaylorlin.com/tags/%E6%B8%B8%E6%88%8F%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>游戏引擎的游戏性系统简介</title>
    <link href="http://raytaylorlin.com/tech/game/engine/gameplay-system-introduction/"/>
    <id>http://raytaylorlin.com/tech/game/engine/gameplay-system-introduction/</id>
    <published>2016-12-21T08:45:32.000Z</published>
    <updated>2016-12-21T13:52:04.015Z</updated>
    
    <content type="html">&lt;p&gt;游戏引擎是复杂的多层软件系统，而游戏的本质，并非在于其使用的引擎或技术，而是其游戏性（gameplay）。游戏机制（game mechanics）一词，可以把游戏性这个概念变得更为具体。游戏机制通常定义为一些规则，这些规则主宰了游戏中多个实体之间的互动，如定义玩家的目标、成败的准则、角色的各种能力、游戏体验的整体流程等等。本文将简单介绍用于定义及管理游戏机制的引擎系统及相关工具。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-剖析游戏世界&quot;&gt;&lt;a href=&quot;#1-剖析游戏世界&quot; class=&quot;headerlink&quot; title=&quot;1. 剖析游戏世界&quot;&gt;&lt;/a&gt;1. 剖析游戏世界&lt;/h1&gt;&lt;p&gt;游戏类型虽然五花八门，但大多数会有一种基本的结构模式，通常由以下部分组成：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;世界元素&lt;ul&gt;
&lt;li&gt;静态元素：地形、建筑等等几乎不会动或主动与游戏性交互的物体&lt;/li&gt;
&lt;li&gt;动态元素：角色、NPC、道具、粒子特效、动态光源、区域等等&lt;/li&gt;
&lt;li&gt;区分静态和动态元素，主要是用于优化性能——静态元素都可以预先计算或忽略，减少运行时游戏世界中动态元素的运算&lt;/li&gt;
&lt;li&gt;有一些游戏含有可破坏环境，算是模糊静态和动态元素分界的例子，说明元素是否静态并不是绝对的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;世界组块：庞大的游戏世界通常会被拆分成为独立可玩的区域，可以演化成关卡、地图、地区等等。分割关卡有几个原因，首先是内存限制；其次它也是一个控制游戏整体流程的方便机制；最后它可以作为分工的单位，方便开发团队分别构建及管理。&lt;/li&gt;
&lt;li&gt;高级游戏流程：指由玩家&lt;strong&gt;目标&lt;/strong&gt;所组成的序列、树或图，可演化成任务、关卡、波（如塔防波次）、胜利条件或失败惩罚。在故事驱动的游戏中，流程可能也包含多个游戏内置电影、过场动画。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;2-游戏世界编辑器&quot;&gt;&lt;a href=&quot;#2-游戏世界编辑器&quot; class=&quot;headerlink&quot; title=&quot;2. 游戏世界编辑器&quot;&gt;&lt;/a&gt;2. 游戏世界编辑器&lt;/h1&gt;&lt;h2 id=&quot;2-1-典型功能&quot;&gt;&lt;a href=&quot;#2-1-典型功能&quot; class=&quot;headerlink&quot; title=&quot;2.1 典型功能&quot;&gt;&lt;/a&gt;2.1 典型功能&lt;/h2&gt;&lt;p&gt;游戏性内容对应的创作工具便是游戏世界编辑器，其用于定义世界组块，并填入静态及动态元素。所有商用游戏引擎都有某种形式的世界编辑工具，大部分会提供以下列出的主要功能。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;世界组块创建及管理：除了组块管理基本功能外，还可以连接若干静态网格，以及AI用的导航地图、可攀抓边缘信息等等静态数据。有的还提供专门的地形编辑器用于编辑地形（或解析高度场地形）和水体。&lt;/li&gt;
&lt;li&gt;可视化游戏世界：可让开发者大幅提高开发效率，通常3D游戏提供顶、侧、正视图和三维透视视图4部分，2D游戏提供正射视角。有的编辑器直接整合自制的渲染引擎至工具中，有的把自身整合至第三方3D软件，有的会通过与实际的游戏引擎通信，利用游戏引擎来渲染三维视图，甚至整合至游戏引擎本身。&lt;/li&gt;
&lt;li&gt;导航：提供滚动、放大缩小、聚焦某个对象旋转、摄像机飞行模式、记录历史摄像机位置并跳转等等方便开发的功能。&lt;/li&gt;
&lt;li&gt;选取：在编辑器中可以选取个别或框选多个游戏对象，并对它们批量操作。使用光线投射方式选取三维对象时，编辑器可让用户循环选取与光线相交的所有对象，而不是总选取最近者。&lt;/li&gt;
&lt;li&gt;图层：把对象用预设或用户自定义的图层来分组，把游戏世界中的内容有条理地组织起来。图层也是分工的重要工具，多人可以在同个世界组块上的不同图层工作而不冲突。&lt;/li&gt;
&lt;li&gt;属性网格：如下图所示，可视化编辑游戏对象的属性（一般是键值对），不仅可以编辑常见的数值和字符串，还能支持下拉框、复选框、滑块、颜色选取器等控件编辑。&lt;ul&gt;
&lt;li&gt;选取多个对象后的编辑方式：此高级特性把选中的对象的共有属性混合在一起显示。在网格中编辑公共值时，会把新值更新至所有选取对象的属性中。&lt;/li&gt;
&lt;li&gt;自由格式属性：通常这种属性集会关联到某个用户自定义的对象，以形成新的“自由格式”属性，如光源属性集包含位置、方向、颜色、强度及光源类型属性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://raytaylorlin-blog.qiniudn.com/image/engine/%E5%B1%9E%E6%80%A7%E7%BD%91%E6%A0%BC%E7%A4%BA%E4%BE%8B.jpg&quot; alt=&quot;属性网格示例&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;安放对象及对齐辅助工具：除了基本的平移、旋转、缩放工具外，有的编辑器还提供对齐至网格，对齐至地形，对齐至对象，多个对象分布或对齐等功能。&lt;/li&gt;
&lt;li&gt;特殊对象类型&lt;ul&gt;
&lt;li&gt;光源：通常用特殊图标表示，因为光源没有网格。编辑器可能会尝试模拟光源对场景的照明效果，让设计师能实时调整并能看到场景的最终大致效果。&lt;/li&gt;
&lt;li&gt;粒子发射器：若编辑器是独立于渲染引擎之上，则可简单用图标表示，或尝试在编辑器中模拟效果；若编辑器是内置于游戏引擎，则可以实际模拟调整，达到“所见即所得”的效果。&lt;/li&gt;
&lt;li&gt;区域：即空间中的体积，供游戏侦测相关事件用（如Unity中的trigger）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;读/写世界组块：有的引擎把每个组块储存为单个文件，有的可以独立读/写个别的图层；有的引擎使用自定义的二进制文件格式，有的使用如XML的文本格式。&lt;/li&gt;
&lt;li&gt;快速迭代：优秀的编辑器会支持某程度的动态微调功能以供快速迭代。有的编辑器在游戏本身内执行，让用户即时看到改动的效果，有的连接至运行中的游戏，或完全脱机运行。具体的机制并不重要，最重要的是给用户足够短的往返迭代时间。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-2-集成资产管理工具&quot;&gt;&lt;a href=&quot;#2-2-集成资产管理工具&quot; class=&quot;headerlink&quot; title=&quot;2.2 集成资产管理工具&quot;&gt;&lt;/a&gt;2.2 集成资产管理工具&lt;/h2&gt;&lt;p&gt;有些引擎的编辑器会整合游戏资产数据库的其他方面功能，例如设定网格/材质的属性、设定动画/混合树/动画状态机、设置对象的碰撞/物理属性、管理材质资源等，著名的例子有UnrealEd和Unity。它们能对用户提供统一、实时、所见即所得的资产管理视图，促进快速高效的游戏开发过程。&lt;/p&gt;
&lt;p&gt;不同的工具对资产的优化时间点也不一样。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;UnrealEd在导入资产时就会对资产优化，这样在关卡设计上能缩短法代时间，但是改动网格、动画、音频等来源资产会变得更痛苦。&lt;/li&gt;
&lt;li&gt;Source及雷神之锤引擎，把资产优化延后至烘焙关卡、执行游戏之前。&lt;/li&gt;
&lt;li&gt;《光环（Halo）》给用户选择在任意时刻转换原始资源——这些资源在第一次载入至引擎前转换至优化格式并缓存，避免每次执行游戏时都要再做无意义的转换。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;3-游戏性基础系统的组件&quot;&gt;&lt;a href=&quot;#3-游戏性基础系统的组件&quot; class=&quot;headerlink&quot; title=&quot;3. 游戏性基础系统的组件&quot;&gt;&lt;/a&gt;3. 游戏性基础系统的组件&lt;/h1&gt;&lt;p&gt;如果可以合理地画出游戏与游戏引擎的分界线，那么游戏性基础系统就是刚刚位于该线之下。理论上，我们可以建立一个游戏性基础系统，其大部分是各个游戏皆通用的。实际上不同引擎之间有许多共有模式，以下列出一些常用组件，后续的文章就会逐渐记录这些组件的功能和设计方法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;运行时游戏对象（runtime game object）模型&lt;/li&gt;
&lt;li&gt;实时更新对象模型&lt;/li&gt;
&lt;li&gt;关卡管理及串流&lt;/li&gt;
&lt;li&gt;目标及游戏流程管理&lt;/li&gt;
&lt;li&gt;消息及事件处理&lt;/li&gt;
&lt;li&gt;脚本&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考文献：电子工业出版社《游戏引擎架构》第13章&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;游戏引擎是复杂的多层软件系统，而游戏的本质，并非在于其使用的引擎或技术，而是其游戏性（gameplay）。游戏机制（game mechanics）一词，可以把游戏性这个概念变得更为具体。游戏机制通常定义为一些规则，这些规则主宰了游戏中多个实体之间的互动，如定义玩家的目标、成败的准则、角色的各种能力、游戏体验的整体流程等等。本文将简单介绍用于定义及管理游戏机制的引擎系统及相关工具。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="游戏开发" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
      <category term="游戏引擎" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    
      <category term="游戏引擎" scheme="http://raytaylorlin.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
      <category term="游戏性系统" scheme="http://raytaylorlin.com/tags/%E6%B8%B8%E6%88%8F%E6%80%A7%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>人体学接口设备（HID）</title>
    <link href="http://raytaylorlin.com/tech/game/engine/human-interface-device/"/>
    <id>http://raytaylorlin.com/tech/game/engine/human-interface-device/</id>
    <published>2016-07-13T08:45:32.000Z</published>
    <updated>2016-07-13T08:54:40.612Z</updated>
    
    <content type="html">&lt;p&gt;游戏是有互动性的计算机模拟，为游戏而设的人体学接口设备（Human Interface Device，HID）种类繁多，包括摇杆、手柄、键盘、鼠标、Wii遥控器，以及方向盘、跳舞毯、电子吉他等等专用输入设备。本文探讨游戏引擎如何自入体学接口设备读取输入，处理输入，以及向玩家反馈输出。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-HID的接口技术&quot;&gt;&lt;a href=&quot;#1-HID的接口技术&quot; class=&quot;headerlink&quot; title=&quot;1. HID的接口技术&quot;&gt;&lt;/a&gt;1. HID的接口技术&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;轮询&lt;ul&gt;
&lt;li&gt;像手柄这样的简单设备，可通过定期轮询硬件来读取输入（通常在主游戏循环里每次迭代轮询一次）&lt;/li&gt;
&lt;li&gt;要明确查询（输出）设备的状态，可直接读取硬件寄存器；读取经内存映射的I/O端口，或通过较高级的软件接口间接读取&lt;/li&gt;
&lt;li&gt;微软为Xbox 360手柄而设的XInput API是简单轮询的好例子。游戏在每帧调用&lt;code&gt;XInputGetState()&lt;/code&gt;函数，它与硬件／驱动通信，适当地读取数据，并把所有结果包装成&lt;code&gt;XINPUT_STATE&lt;/code&gt;结构，此结构含有手柄设备上所有输入的当前状态&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;中断：像鼠标这样的设备没必要在静止时还不断发送数据。这类设备通常以硬件中断方式来通信。中断服务程序用来读取设备状态，把状态储存以供后续处理，然后交还CPU给主程序&lt;/li&gt;
&lt;li&gt;无线设备：对于蓝牙设备，软件必须以&lt;strong&gt;蓝牙协议&lt;/strong&gt;和它们通信。这种通信一般由引擎主线程以外的线程负责处理，或至少被封装为简单接口供主循环调用。从程序员的角度来说，蓝牙基本和其他传统轮询设备的状态一样&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;2-HID的输入输出类型&quot;&gt;&lt;a href=&quot;#2-HID的输入输出类型&quot; class=&quot;headerlink&quot; title=&quot;2. HID的输入输出类型&quot;&gt;&lt;/a&gt;2. HID的输入输出类型&lt;/h1&gt;&lt;h2 id=&quot;2-1-输入类型&quot;&gt;&lt;a href=&quot;#2-1-输入类型&quot; class=&quot;headerlink&quot; title=&quot;2.1 输入类型&quot;&gt;&lt;/a&gt;2.1 输入类型&lt;/h2&gt;&lt;h3 id=&quot;2-1-1-数字式按钮&quot;&gt;&lt;a href=&quot;#2-1-1-数字式按钮&quot; class=&quot;headerlink&quot; title=&quot;2.1.1 数字式按钮&quot;&gt;&lt;/a&gt;2.1.1 数字式按钮&lt;/h3&gt;&lt;p&gt;数字式按钮只有两个状态——按下（down或press）或释放（up或release），软件中则以1或0表示。有时设备上所有按钮的状态会结合为一个无符号整数值，如XBox 360手柄的状态是以&lt;code&gt;XINPUT_GAMEPAD&lt;/code&gt;结构传回。这个结构体第一个字段是一个16位无符号整数变量wButtons，存放所有按钮的状态。每个按钮都会定义一个掩码，实际使用时将wButtons和掩码做&amp;amp;运算来判断是否被按下。&lt;/p&gt;
&lt;h3 id=&quot;2-1-2-模拟式轴和相对性轴&quot;&gt;&lt;a href=&quot;#2-1-2-模拟式轴和相对性轴&quot; class=&quot;headerlink&quot; title=&quot;2.1.2 模拟式轴和相对性轴&quot;&gt;&lt;/a&gt;2.1.2 模拟式轴和相对性轴&lt;/h3&gt;&lt;p&gt;模拟式输入是指可获取一个范围以内的数值。此类输入通常用来代表摇杆的二维位置（使用两个模拟输入， 一个x轴一个y轴）。模拟式输入信号通常都要被数字化，表示为软件中的整数，再送入引擎处理。像Xbox 360手柄拇指摇杆的偏转量（sThumbLX/sThumbLY/sThumbRX/sThumbRY）取值范围是-32768~32767，而左右扳机（bLeftTrigger/bRightTrigger）取值范围是0（没扣压）~255（完全扣压）。&lt;/p&gt;
&lt;p&gt;上述模拟式轴的位置都是&lt;strong&gt;绝对&lt;/strong&gt;的，而有些输入是&lt;strong&gt;相对&lt;/strong&gt;性的。这类设备不能界定在哪个位置的输入值为0，相反，输入为0代表设备的位置没变动，非零值代表自上次读取输入至今的增量，如鼠标、鼠标滚轮和轨迹球等等。&lt;/p&gt;
&lt;h3 id=&quot;2-1-3-加速计及三维定向&quot;&gt;&lt;a href=&quot;#2-1-3-加速计及三维定向&quot; class=&quot;headerlink&quot; title=&quot;2.1.3 加速计及三维定向&quot;&gt;&lt;/a&gt;2.1.3 加速计及三维定向&lt;/h3&gt;&lt;p&gt;Wii遥控器、PS3的Sixaxis及智能手机都包含加速传感器，能感应xyz三个主轴的加速度。Wii的一些游戏会利用3个加速计去估算控制器在玩家手上的定向。其原理是基于我们在地球表面上玩这些游戏，而地球的1g引力能对物体产生固定的向下加速度。&lt;/p&gt;
&lt;p&gt;若把控制器完美地水平放置，并指向电视方向，那么垂直方向（z）的加速计应量度到大约-1g。若垂直握着控制器，使其指向上方，则可以预期z应为0，而y应为1g（ 因为y传感器会感受到完整的引力效果）。当我们校准加速计得知每个轴的零点，就可以使用逆正弦和逆余弦，轻松求得偏航角、俯仰角和滚动角。&lt;/p&gt;
&lt;h2 id=&quot;2-2-输出类型&quot;&gt;&lt;a href=&quot;#2-2-输出类型&quot; class=&quot;headerlink&quot; title=&quot;2.2 输出类型&quot;&gt;&lt;/a&gt;2.2 输出类型&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;震动反馈：模拟游戏角色在游戏中受到扰动或撞击等感觉。震动通常由若干个马达驱动，每个马达带有稍不平衡的负重，以不同速度旋转。游戏可开关这些马达，并通过调节其旋转速度来向玩家双手产生不同的触觉效果&lt;/li&gt;
&lt;li&gt;力反馈：通过由马达驱动的制动器，以其产生的力对抗玩家施于HID上的力。常见于街机赛车游戏——当玩家尝试转方向盘时，方向盘会产生阻力，其输出原理同震动反馈&lt;/li&gt;
&lt;li&gt;其他输入/输出：有些HID设备含扬声器、麦克风等音频接口；较老的像Dreamcast的手柄支持插入记忆卡；Xbox 360手柄和Wii遥控器带有4个软件控制的LED灯；乐器、跳舞毯等特殊设备有其专门的输入／输出类型；近年发展的姿势界面（如Kinect）和VR设备，也是非常独特的HID&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;3-游戏引擎的HID系统&quot;&gt;&lt;a href=&quot;#3-游戏引擎的HID系统&quot; class=&quot;headerlink&quot; title=&quot;3. 游戏引擎的HID系统&quot;&gt;&lt;/a&gt;3. 游戏引擎的HID系统&lt;/h1&gt;&lt;p&gt;多数游戏引擎不会直接使用HID的原始输入数据，而是引入至少一个在HID和游戏之间的间接层，将输入以多种形式抽象化。下面会介绍一些HID系统的典型需求。&lt;/p&gt;
&lt;h2 id=&quot;3-1-死区&quot;&gt;&lt;a href=&quot;#3-1-死区&quot; class=&quot;headerlink&quot; title=&quot;3.1 死区&quot;&gt;&lt;/a&gt;3.1 死区&lt;/h2&gt;&lt;p&gt;假定模拟轴的输入值范围是$I_{min}$到$I_m$，未触碰模拟轴时，稳定及清晰的“未扰动”输入值为$I_0$。&lt;/p&gt;
&lt;p&gt;HID本质上是模拟设备，其产生的电压含有噪声，以致实际上量度到的输入会轻微$I_0$附近浮动。解决办法是引入一个围绕$I_0$的死区。对于摇杆，死区可以定义为$[I_0-\sigma, I_0+\sigma]$；对于扳机，则定义为$[I_0, I_0+\sigma]$。任何位于死区的输入值都可以简单地被钳制为$I_0$。死区必须足够大以容纳未扰动控制的最大噪声，同时也必须足够小以免影响玩家对HID的反应手感。&lt;/p&gt;
&lt;h2 id=&quot;3-2-模拟信号过滤&quot;&gt;&lt;a href=&quot;#3-2-模拟信号过滤&quot; class=&quot;headerlink&quot; title=&quot;3.2 模拟信号过滤&quot;&gt;&lt;/a&gt;3.2 模拟信号过滤&lt;/h2&gt;&lt;p&gt;即使控制器不在死区范围，其输入仍会有信号噪声问题，这些噪声有时候会导致游戏中的行为显得抖动或不自然。由于噪声信号的频率通常比玩家产生的要高。所以，解决办法之一是，先利用低通滤波器过滤原始输入，再把结果传送至游戏中使用。&lt;/p&gt;
&lt;p&gt;结合未过滤输入的时变函数$u(t)$，己过滤输入为$f(t)=(1-a)f(t-\Delta t)+au(t)$，其中参数$a$由帧持续时间$\Delta t$和过滤常数$RC$所确定，即$a=\frac{\Delta t}{RC+\Delta t}$。公式转换C++代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;F32 lowPassFilter(F32 unfilteredInput, F32 lastFramesFilteredInput, F32 rc, F32 dt) {
    F32 a = dt / (rc + dt);
    return (1 - a) * lastFramesFilteredInput + a * unfilteredInput;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;另一个过滤HID输入的方法是计算移动平均。例如，若要计算3帧时间范围内的输入数据平均，只需把原始输入数据简单地储存于3个元素大小的循环缓冲区里，把此数组的值求和除3，就是过滤后的输入值。因为初始时该数组并未填满有效数据，要注意处理前两帧的输入。&lt;/p&gt;
&lt;h2 id=&quot;3-3-输入事件检测&quot;&gt;&lt;a href=&quot;#3-3-输入事件检测&quot; class=&quot;headerlink&quot; title=&quot;3.3 输入事件检测&quot;&gt;&lt;/a&gt;3.3 输入事件检测&lt;/h2&gt;&lt;h3 id=&quot;3-3-1-按下和释放按钮&quot;&gt;&lt;a href=&quot;#3-3-1-按下和释放按钮&quot; class=&quot;headerlink&quot; title=&quot;3.3.1 按下和释放按钮&quot;&gt;&lt;/a&gt;3.3.1 按下和释放按钮&lt;/h3&gt;&lt;p&gt;假设按钮的输入位在释放时为0，按下时为1。可以记录上一帧的状态（32位位整型），和本帧的状态位异或，为1的位表示状态发生变化。再审视每个按钮的当前状态，若某按钮的状态有改变，而当前的状态是按下，则产生按下事件，否则产生释放事件。&lt;/p&gt;
&lt;h3 id=&quot;3-3-2-弦（chord）&quot;&gt;&lt;a href=&quot;#3-3-2-弦（chord）&quot; class=&quot;headerlink&quot; title=&quot;3.3.2 弦（chord）&quot;&gt;&lt;/a&gt;3.3.2 弦（chord）&lt;/h3&gt;&lt;p&gt;弦是指一组按钮，当同时被按下时，会在游戏中产生一个独特行为。一般通过检测两个或以上的按钮状态，当该组按钮全部同时被按下才执行操作。但弦有许多细节值得注意：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;小心避免同时产生个别按钮的动作和弦的动作。要在检测个别按钮的时候，同时检查弦里的&lt;strong&gt;其他按键并没有被按下&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;弦的检测代码必须健壮，防止人们按下弦中的某一按钮稍早于其他按钮。有几种方法可以处理这些情况&lt;ul&gt;
&lt;li&gt;从策划的角度，将按钮输入设计为，弦总是作用于某个按钮的动作再加上额外的动作。例如，若按L1是主武器开火，按L2投射手榴弹，可能L1+L2的弦是令主要武器开火、投射手榴弹，并发送能量波使这些武器的伤害力加倍。这样从玩家的角度来说游戏表现出的行为没有不同&lt;/li&gt;
&lt;li&gt;在个别按钮按下后，加入一段延迟时间，然后才算作是一个有效的游戏事件。在延迟期间（如2或3帧），若检测到一个弦，那么那个弦就会凌驾个别按钮产生事件&lt;/li&gt;
&lt;li&gt;按下单个按钮时立即执行动作，但容许这些动作被之后弦的动作抢占&lt;/li&gt;
&lt;li&gt;按下按钮时检测弦，但之后释放按钮时才产生效果&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;3-3-3-序列检测&quot;&gt;&lt;a href=&quot;#3-3-3-序列检测&quot; class=&quot;headerlink&quot; title=&quot;3.3.3 序列检测&quot;&gt;&lt;/a&gt;3.3.3 序列检测&lt;/h3&gt;&lt;p&gt;序列指玩家通过HID，在一段时间内完成一串动作，最常用于格斗游戏，如在0.5-1秒内连续按下“左右左ABA”。序列检测的基本原理是：保留HID输入的动作短期记录，当检测到序列第一个成分，就会把该成分及其时间戳记录在历史缓冲区中。之后，检测到每个后续成分时，需要检查距上一个成分所经过的时间，若时间仍在容许范围内，就把该成分加入缓冲区中。若整个序列于限定时间内完成，就会产生对应的事件。若在过程中检测到无效输入，或超过规定事件，那么整个历史缓冲区会被重置。&lt;/p&gt;
&lt;p&gt;要检测连打按钮频率，只须记录该按钮上一次被按下事件的时间Tlast和两次按下按钮的时间间隔。若该间隔超过了给定的阈值，则不更新Tlast。那么，在有一对新的够迅速的按钮按下事件产生之前，序列会一直判定为无效。&lt;/p&gt;
&lt;p&gt;要检测诸如“在1s内连续按下ABA的序列”，可以参照下面的伪代码。其中&lt;code&gt;ButtonsJustWentDown()&lt;/code&gt;函数来检查若干个按钮的按下事件。当成功检测到序列，就会广播指定事件，令整个游戏都能接收到。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class ButtonSequenceDetector {
    U32 m_aButtonIds; // 检测的序列
    U32 m_buttonCount; // 序列中的按钮数目
    F32 m_dtMax; // 整个序列的最大时限
    EventId m_eventId ; // 完成序列的事件
    U32 m_iButton; // 要检测的下一个按钮
    F32 m_tStart; // 序列的开始时间，以秒为单位

public:
    void Update() {
        ASSERT(m_iButton &amp;lt; m_buttonCount);
        // 计算下个预期的按钮，以位掩码表示（把1左移至正确的位索引）
        U32 buttonMask = (1U &amp;lt;&amp;lt; m_aButtonid[m_iButton]);
        // 若玩家按下预期以外的按钮，废止现时的序列（使用位取反运算检测所有其他按钮）
        if (ButtonsJustWentDown(~buttonMask)) {
            m_iButton = 0; // 重置
        }
        // 否则，若预期按钮刚被按下，检查dt及适当更新状态
        else if (ButtonsJustWentDown(buttonMask)) {
            // 序列中第一个按钮
            if (m_iButton == 0) {
                m_tStart = CurrentTime();
                ++m_iButton;
            } else {
                F32 dt = CurrentTime() - m_tStart;
                // 时间间隔符合要求，序列仍然有效
                if (dt &amp;lt; m_dtMax) {
                    ++m_iButton;
                    // 判断序列是否完成
                    if (m_iButton == m_buttonCount) {
                        // 广播事件并重置
                        BroadcastEvent(m_eventId);
                        m_iButton = 0;
                    }
                }
                // 按得不够快，重置
                else {
                    m_iButton = 0;
                }
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;再复杂的序列包含了摇杆方向，例如检测左拇指摇杆沿顺时针方向旋转一周。可以把遥杆位置的二维范围分割成4个象限。顺时针方向旋转时，经过的象限顺序是左上，右上，右下，左下。只要把象限检测当作按钮处理，就可稍修改上文按钮序列检测代码来完成任务。&lt;/p&gt;
&lt;h2 id=&quot;3-4-跨平台HID系统&quot;&gt;&lt;a href=&quot;#3-4-跨平台HID系统&quot; class=&quot;headerlink&quot; title=&quot;3.4 跨平台HID系统&quot;&gt;&lt;/a&gt;3.4 跨平台HID系统&lt;/h2&gt;&lt;p&gt;引擎处理多平台的HID数据时，应该提供某形式的硬件抽象层，使游戏代码和硬件相关细节隔离。此抽象层能把目标硬件的原始控制标识符转化为抽象的控制索引。例如Xbox 360及PS3的两款手柄的控制布局几乎相同，所以可以设立一套抽象标识符来屏蔽它们的差异。&lt;/p&gt;
&lt;h2 id=&quot;3-5-输入的重映射&quot;&gt;&lt;a href=&quot;#3-5-输入的重映射&quot; class=&quot;headerlink&quot; title=&quot;3.5 输入的重映射&quot;&gt;&lt;/a&gt;3.5 输入的重映射&lt;/h2&gt;&lt;p&gt;许多游戏提供给玩家修改键位的选项，这就需要把原始输入映射到最终的游戏功能上。可以给每个游戏功能一个唯一标识符，然后加一个简单的表，把每个抽象的控制索引映射至游戏中的逻辑功能。要改变映射，可以更换整个表，或是让玩家设置该表中的个别条目。&lt;/p&gt;
&lt;p&gt;但要小心不同的输入种类和取值范围，像某个游戏逻辑需要轴，就不能改用按钮操控。为了允许合理的输入映射，可以把所有输入分类并归一化：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数字式按钮：按钮状态打包成32位字，每一位代表一个按钮的状态&lt;/li&gt;
&lt;li&gt;单向绝对轴（如扳机、模拟式按钮）：产生[O, 1]的浮点数&lt;/li&gt;
&lt;li&gt;双向绝对轴（如摇杆）：产生[-1, 1]的浮点数&lt;/li&gt;
&lt;li&gt;相对轴（如鼠标滚轮、轨迹球）：产生[-1, 1]的浮点数，其中±1代表单帧内最大的相对偏移值&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;3-6-上下文相关控制&quot;&gt;&lt;a href=&quot;#3-6-上下文相关控制&quot; class=&quot;headerlink&quot; title=&quot;3.6 上下文相关控制&quot;&gt;&lt;/a&gt;3.6 上下文相关控制&lt;/h2&gt;&lt;p&gt;许多游戏里一个物理控制会根据上下文有着不同功能，例如若角色站在门前，按“使用”按钮会开门，若角色附近有一个物体，按“使用”按钮会拾起该物体。上下文相关控制可简单地采用状态机来实现，即根据当前状态个别HID控制可能有不同用途。要注意有时还需要实现优先系统，为不同物体赋予权值，来决定同等条件下优先让哪个物体（状态）生效。&lt;/p&gt;
&lt;h2 id=&quot;3-7-禁用输入&quot;&gt;&lt;a href=&quot;#3-7-禁用输入&quot; class=&quot;headerlink&quot; title=&quot;3.7 禁用输入&quot;&gt;&lt;/a&gt;3.7 禁用输入&lt;/h2&gt;&lt;p&gt;在某些场合可能需要禁用玩家的输入，例如过场动画禁用所有输入，玩家经过窄巷暂停自由旋转摄像机。一个较差的方法是使用位掩码来禁用设备上的某些控制，这种方法缺陷是如果忘记重置掩码，很可能使玩家持续失去控制。所以应该小心处理游戏逻辑，并加入一些防故障机制。&lt;/p&gt;
&lt;p&gt;另一个更好的做法是，把禁用某玩家动作及行为的逻辑写进玩家或摄像机的代码里。这样，若摄像机某时刻决定要忽略右拇指轴的输入，游戏引擎内其他系统仍然能自由读取该输入做其他用途。&lt;/p&gt;
&lt;p&gt;参考文献：电子工业出版社《游戏引擎架构》第8章&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;游戏是有互动性的计算机模拟，为游戏而设的人体学接口设备（Human Interface Device，HID）种类繁多，包括摇杆、手柄、键盘、鼠标、Wii遥控器，以及方向盘、跳舞毯、电子吉他等等专用输入设备。本文探讨游戏引擎如何自入体学接口设备读取输入，处理输入，以及向玩家反馈输出。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="游戏开发" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
      <category term="游戏引擎" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    
      <category term="游戏引擎" scheme="http://raytaylorlin.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
      <category term="架构" scheme="http://raytaylorlin.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>实时游戏的时间模拟</title>
    <link href="http://raytaylorlin.com/tech/game/engine/real-time-simulation/"/>
    <id>http://raytaylorlin.com/tech/game/engine/real-time-simulation/</id>
    <published>2016-06-28T08:29:02.000Z</published>
    <updated>2016-06-28T08:30:05.929Z</updated>
    
    <content type="html">&lt;p&gt;游戏是实时的、动态的、互动的计算机模拟，所以&lt;strong&gt;时间&lt;/strong&gt;在电子游戏中担当非常重要的角色。游戏中有不同种类的时间——实时、游戏时间、动画的本地时间线、某函数实际消耗的CPU周期等。本文谈及实时、动态模拟软件如何运作，并探讨这类模拟中运用时间的常见方法。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-抽象时间线&quot;&gt;&lt;a href=&quot;#1-抽象时间线&quot; class=&quot;headerlink&quot; title=&quot;1. 抽象时间线&quot;&gt;&lt;/a&gt;1. 抽象时间线&lt;/h1&gt;&lt;p&gt;时间线是连续的一维轴，其原点（t=0）可以设置为系统中其他时间线的任何相对位置。时间线可以用简单的时钟变量实现，以整数或浮点数格式储存绝对时间值。时间线可能存在如下几种形式。&lt;/p&gt;
&lt;h2 id=&quot;1-1-真实时间线&quot;&gt;&lt;a href=&quot;#1-1-真实时间线&quot; class=&quot;headerlink&quot; title=&quot;1.1 真实时间线&quot;&gt;&lt;/a&gt;1.1 真实时间线&lt;/h2&gt;&lt;p&gt;可以直接使用CPU的高分辨率计时寄存器来量度时间。此时间线的原点定义为计算机上次启动或重置之时。这种时间的度量单位是CPU周期（或其倍数），但其实只要简单地乘以CPU的高分辨率计时器频率，此单位便可以转换为秒数。&lt;/p&gt;
&lt;h2 id=&quot;1-2-游戏时间线&quot;&gt;&lt;a href=&quot;#1-2-游戏时间线&quot; class=&quot;headerlink&quot; title=&quot;1.2 游戏时间线&quot;&gt;&lt;/a&gt;1.2 游戏时间线&lt;/h2&gt;&lt;p&gt;在正常情况下，游戏时间和真实时间是一致的。但若希望暂停游戏，就可以简单地临时停止对游戏时间的更新，若要把游戏变成慢动作，可以把游戏时钟更新得慢于实时时钟。&lt;/p&gt;
&lt;p&gt;控制游戏时间是很有用的调试工具。例如在追查不正常的渲染时，可以暂停游戏时间，冻结所有动作，然后使用另外时钟的渲染引擎及调试用飞行摄像机继续运作，就能以任意角度观察问题所在。也可以在暂停模式下，手动“逐步更新”推前帧率来调试。要注意这种调试方法暂停游戏时，游戏循环是持续进行的，仅仅是游戏时钟停止，而通过对暂停的时钟加上1/30s去实现单步更新。&lt;/p&gt;
&lt;h2 id=&quot;1-3-局部与全局时间线&quot;&gt;&lt;a href=&quot;#1-3-局部与全局时间线&quot; class=&quot;headerlink&quot; title=&quot;1.3 局部与全局时间线&quot;&gt;&lt;/a&gt;1.3 局部与全局时间线&lt;/h2&gt;&lt;p&gt;可以想象每个动画或音频片段都含有一个局部时间线，其原点定义为片段的开始。在游戏中播放片段时，正常播放、加速、减速、反转等效果可以视觉化为局部到全局时间线的映射。下图给出了几种映射的情况，其中在做缩放播放时，播放速率记为R。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://raytaylorlin-blog.qiniudn.com/image/engine/%E5%B1%80%E9%83%A8%E5%88%B0%E5%85%A8%E5%B1%80%E6%97%B6%E9%97%B4%E7%BA%BF%E6%98%A0%E5%B0%84%E7%9A%84%E5%90%84%E7%A7%8D%E6%83%85%E5%86%B5.jpg&quot; alt=&quot;局部到全局时间线映射的各种情况&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;2-测量及处理时间&quot;&gt;&lt;a href=&quot;#2-测量及处理时间&quot; class=&quot;headerlink&quot; title=&quot;2. 测量及处理时间&quot;&gt;&lt;/a&gt;2. 测量及处理时间&lt;/h1&gt;&lt;h2 id=&quot;2-1-帧率与时间增量&quot;&gt;&lt;a href=&quot;#2-1-帧率与时间增量&quot; class=&quot;headerlink&quot; title=&quot;2.1 帧率与时间增量&quot;&gt;&lt;/a&gt;2.1 帧率与时间增量&lt;/h2&gt;&lt;p&gt;时间增量Δt（delta time）在游戏中非常重要，其值为FPS的倒数（若为60FPS则Δt=16.6ms/f）。假设一个游戏物体以恒定速率v（单位m/s）运行，乘以一帧的时间增量（单位s/f），就能得出该物体每帧的位置变化Δx=vΔt（单位m/f）。&lt;strong&gt;游戏中物体的感知速度依赖于帧时间Δt，因此计算Δt的值是游戏编程的核心问题之一。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-1-1-受CPU速度影响&quot;&gt;&lt;a href=&quot;#2-1-1-受CPU速度影响&quot; class=&quot;headerlink&quot; title=&quot;2.1.1 受CPU速度影响&quot;&gt;&lt;/a&gt;2.1.1 受CPU速度影响&lt;/h3&gt;&lt;p&gt;早期的游戏中，程序员不会尝试在游戏循环中准确量度真实经过的时间，即忽略Δt，以Δx=v计算位置变化。这样的后果是，游戏中物体看上去的速度完全依赖于CPU的速度所产生的帧率。若在较快的CPU上运行这类游戏，游戏看上去就会像快速进带一样。&lt;/p&gt;
&lt;h3 id=&quot;2-1-2-基于经过时间的更新&quot;&gt;&lt;a href=&quot;#2-1-2-基于经过时间的更新&quot; class=&quot;headerlink&quot; title=&quot;2.1.2 基于经过时间的更新&quot;&gt;&lt;/a&gt;2.1.2 基于经过时间的更新&lt;/h3&gt;&lt;p&gt;要开发和CPU速度脱钩的游戏，就要以某种方法度量Δt，只需&lt;em&gt;将CPU的高分辨率计时器取值两次——一次于帧开始时，一次于帧结束时，然后取二者之差就能精确度量上一帧的Δt&lt;/em&gt;。绝大部分的游戏引擎都是用这种方法，但它最大的问题是：使用第k帧度量出的Δt去估计第k+1帧的所需时间，这么做不一定准确。有时甚至会产生非常坏的效果，某一帧特别慢导致预测的Δt越来越大，进入低帧率的恶性循环。&lt;/p&gt;
&lt;h3 id=&quot;2-1-3-使用移动平均&quot;&gt;&lt;a href=&quot;#2-1-3-使用移动平均&quot; class=&quot;headerlink&quot; title=&quot;2.1.3 使用移动平均&quot;&gt;&lt;/a&gt;2.1.3 使用移动平均&lt;/h3&gt;&lt;p&gt;游戏循环中每帧之间是有一些连贯性的。例如，若本帧中摄像机对着含许多渲染耗时物体的走廊，那么下一帧有很大机会仍然对着该走廊。因此可以&lt;em&gt;计算连续几帧的平均时间，用来估计下一帧的Δt&lt;/em&gt;。此方法能使游戏适应转变中的帧率，同时缓和瞬间帧率尖峰所带来的影响。&lt;/p&gt;
&lt;h3 id=&quot;2-1-4-调控帧率&quot;&gt;&lt;a href=&quot;#2-1-4-调控帧率&quot; class=&quot;headerlink&quot; title=&quot;2.1.4 调控帧率&quot;&gt;&lt;/a&gt;2.1.4 调控帧率&lt;/h3&gt;&lt;p&gt;上述方法都是预测下一帧Δt的做法，难免有误差。预期尝试估算下一帧的经过时间，不如尝试保证每帧都准确耗时固定时间，即帧率调控。首先仍然要度量本帧的耗时，&lt;em&gt;若耗时比目标时间短，则让主线程休眠，直至到达目的时间；若耗时比目标时间长，那么只好白等下一个目标时间&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;当游戏的平均帧率接近目标帧率，此方法才有效。若因经常遇到“慢”帧，就会明显降低游戏质量。因此，仍然需要让将引擎系统设计成能接受任意的Δt。在开发时，引擎停留在“可变帧率”模式，实际运行中，游戏若能一贯地达到目标帧率，就开启帧率调控获其好处。使帧率连续维持稳定对游戏多方面都很重要，例如物理模拟使用的数值积分以固定时间更新运作最佳，或者使游戏录播功能更可靠。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【题外】&lt;/strong&gt;游戏录播的实现方式：需要记录游戏进行时的所有相关事件，并把这些事件及其时间戳储存下来。然后在播放时，使用相同的初始条件和随机种子，就能准确地按时间重播那些事件。理论上，这么做能产生和原来游戏过程一模一样的重播。然而，若帧率不稳定，事情可能以不完全相同的次序发生。此问题的简单解决方法是，同时记录每帧的Δt，使游戏性的逻辑模拟部分能完全重播录制时的状态。若播放时的帧率不能维持原来的速度，可选择以较慢的速度播放，或选择略过渲染一些帧。&lt;/p&gt;
&lt;h3 id=&quot;2-1-5-垂直消隐区间&quot;&gt;&lt;a href=&quot;#2-1-5-垂直消隐区间&quot; class=&quot;headerlink&quot; title=&quot;2.1.5 垂直消隐区间&quot;&gt;&lt;/a&gt;2.1.5 垂直消隐区间&lt;/h3&gt;&lt;p&gt;画面撕裂这种显示异常现象，是指由于CRT显示器的电子枪在扫描中途交换背景和前景缓冲区，导致屏幕上半部分显示了旧的影像，而下半部分则显示了新的影像。为避免画面撕裂，许多渲染引擎会在交换缓冲区之前，等待显示器的垂直消隐区间。等待垂直消隐区间是另一种帧率调控，实际上能限制主游戏循环的帧率，使其必然为屏幕刷新率的倍数。例如，在以60Hz刷新的NTSC显示器上，游戏的真实更新率实际会被量化为1/60s的倍数。若两帧之间的时间超过1/60s，便必须等待下一次垂直消隐区间，即该帧共花了2/60s（30FPS）。&lt;/p&gt;
&lt;h2 id=&quot;2-2-高分辨率计时器&quot;&gt;&lt;a href=&quot;#2-2-高分辨率计时器&quot; class=&quot;headerlink&quot; title=&quot;2.2 高分辨率计时器&quot;&gt;&lt;/a&gt;2.2 高分辨率计时器&lt;/h2&gt;&lt;p&gt;标准C程序库函数time()分辨率为秒，不适合度量游戏帧率。度量时间游戏使用的是现代CPU的高分辨率计时器，这种计时器通常会实现&lt;br&gt;为硬件寄存器，其分辨率为纳秒，如3GHz的奔腾处理器上，计时器每秒递增30亿次。奔腾的&lt;code&gt;rdtsc&lt;/code&gt;指令，Win32 API的&lt;code&gt;QueryPerformanceCounter()&lt;/code&gt;，一些PowerPC架构的&lt;code&gt;mftb&lt;/code&gt;指令等等，都可以查询分辨率计时器。&lt;/p&gt;
&lt;p&gt;要特别注意在一些多核处理器中，每个核有其独立的高分辨率计时器，这些计时器可能会彼此漂移。若比较不同核读取的绝对计算器读数，可能会出现一些奇异情况——甚至是负数的经过时间。&lt;/p&gt;
&lt;h2 id=&quot;2-3-时间单位和时钟变量&quot;&gt;&lt;a href=&quot;#2-3-时间单位和时钟变量&quot; class=&quot;headerlink&quot; title=&quot;2.3 时间单位和时钟变量&quot;&gt;&lt;/a&gt;2.3 时间单位和时钟变量&lt;/h2&gt;&lt;p&gt;大多数计时器都是64位的无符号整数时钟，可以支持非常高的精度及很大的数值范围（3GHz CPU每周期0.333ns，约195年才循环一次），这是最具弹性的表示法。当要度量高精度但较短的时间，例如剖析一段代码的性能，可用32位整数时钟。注意仍然用64位整数变量储存起始和结束时刻，中间的差值才用32位整数变量。&lt;/p&gt;
&lt;p&gt;另一常见方法是把较小的持续时间以秒为单位储存为浮点数，即把以CPU周期为单位的时间度量除以CPU时钟频率。由于32位IEEE浮点数的限制（整数部分占用较少位），应小心避免用浮点时钟变量储存很长的持续时间，最多度量几分钟。若要储存绝对值的浮点时钟，需要定期将其重置为零，以免累加至很大的数值。&lt;/p&gt;
&lt;p&gt;有些游戏引擎支持把时间值设定为自定义单位，如以1/300秒为时间单位，优点是：许多情况下足够精确；约165.7天才会溢出；同时是NTSC和PAL制刷新率的倍数。不过这种时间单位对处理动画时间缩放精度仍不够，但对于处理像枪械每次发射间的空档时间、由AI控制的角色要等多久才开始巡逻这些问题就足够了。&lt;/p&gt;
&lt;h2 id=&quot;2-4-应付断点&quot;&gt;&lt;a href=&quot;#2-4-应付断点&quot; class=&quot;headerlink&quot; title=&quot;2.4 应付断点&quot;&gt;&lt;/a&gt;2.4 应付断点&lt;/h2&gt;&lt;p&gt;当游戏在运行时遇到调试断点，游戏循环会暂停，但CPU实时时钟仍在继续累加，当程序员继续执行程序时，该帧的持续时间会度量出一个巨大的值，显然不适合传到引擎各子系统。最简单的方法就是，在主循环中，若度量到某帧的持续时间超过阈值（如1/10s），则可假定游戏刚从断点恢复执行，于是把增量时间人工设为1/30s或1/60s（或其他目标帧率）。&lt;/p&gt;
&lt;h2 id=&quot;2-5-一个简单的时钟类&quot;&gt;&lt;a href=&quot;#2-5-一个简单的时钟类&quot; class=&quot;headerlink&quot; title=&quot;2.5 一个简单的时钟类&quot;&gt;&lt;/a&gt;2.5 一个简单的时钟类&lt;/h2&gt;&lt;p&gt;以下给出一个简单时钟类的实现。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Clock {
    U64 m_timeCycles;    // 时钟周期
    F32 m_timeScale;    // 时间缩放因子
    bool m_isPaused;    // 是否暂停
    static F32 s_cyclesPerSecond;    // CPU每秒的周期数

    // 将秒数转换为周期数
    static inline U64 secondsToCycle(F32 timeSeconds) {
        return (U64) (timeSeconds * s_cyclesPerSecond);
    }

public:
    // 游戏启动时调用此初始化
    static void init() {
        s_cyclesPerSecond = (F32)readHiResTimerFrequency();
    }

    // 构建一个时钟
    explicit Clock(F32 startTimeSeconds = 0.0f) :
        m_timeCycles(secondToCycles(startTimeSeconds)), m_timeScale(1.Of), m_isPaused(false)
    { }

    // 以周期为单位返回当前时间
    U64 getTimeCycles() const {
        return m_timeCycles;
    }

    // 应在每帧调此函数一次，并给予真实度量帧时间（以秒为单位）
    void update(F32 dtRealSeconds) {
        // 非暂停才更新时钟变量
        if (!m_isPaused) {
            U64 dtScaledCycles = secondsToCycles(dtRealSeconds * m_timeScale);    // 乘以缩放因子，实现时间缩放
            m_timeCycles += dtScaledCycles;
        }
    }

    /* 省略其余简单成员函数 */
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;参考文献：电子工业出版社《游戏引擎架构》第7.4、7.5节&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;游戏是实时的、动态的、互动的计算机模拟，所以&lt;strong&gt;时间&lt;/strong&gt;在电子游戏中担当非常重要的角色。游戏中有不同种类的时间——实时、游戏时间、动画的本地时间线、某函数实际消耗的CPU周期等。本文谈及实时、动态模拟软件如何运作，并探讨这类模拟中运用时间的常见方法。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="游戏开发" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
      <category term="游戏引擎" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    
      <category term="游戏引擎" scheme="http://raytaylorlin.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
      <category term="架构" scheme="http://raytaylorlin.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>游戏循环的实现方式</title>
    <link href="http://raytaylorlin.com/tech/game/engine/game-loop/"/>
    <id>http://raytaylorlin.com/tech/game/engine/game-loop/</id>
    <published>2016-06-24T07:30:11.000Z</published>
    <updated>2016-06-24T07:35:04.279Z</updated>
    
    <content type="html">&lt;p&gt;游戏软件本质上是由一个大循环构成的。本文从最简单的渲染循环开始，讨论各种游戏循环的架构风格，接着针对现代多处理器硬件，简要说明一些让游戏引擎利用多核硬件的常见方法。网络游戏的游戏循环比较特殊，最后也会介绍两种最常见的多人游戏循环架构。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-基本游戏循环&quot;&gt;&lt;a href=&quot;#1-基本游戏循环&quot; class=&quot;headerlink&quot; title=&quot;1. 基本游戏循环&quot;&gt;&lt;/a&gt;1. 基本游戏循环&lt;/h1&gt;&lt;h2 id=&quot;1-1-渲染循环&quot;&gt;&lt;a href=&quot;#1-1-渲染循环&quot; class=&quot;headerlink&quot; title=&quot;1.1 渲染循环&quot;&gt;&lt;/a&gt;1.1 渲染循环&lt;/h2&gt;&lt;p&gt;相比于Windows的GUI采用矩形失效技术仅让屏幕有改动的部位重绘，现代3D游戏采用和电影相同的方式产生运动的错觉和互动性——对观众快速连续地显示一连串静止映像，即渲染循环，其最简单的结构如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;while (!quit) {
    // 基于输入或预设的路径更新摄像机变换
    updateCamera();
    // 更新场景中所有动态元素的位置、定向及其他相关的视觉状态
    updateSceneElements();
    // 把静止的场景渲染至屏幕外的帧缓冲（称为“背景缓冲”）
    renderScene();
    // 交换背景缓冲和前景缓冲，令最近渲染的影像显示于屏幕之上
    // （或是在视窗模式下，把背景缓冲复制至前景缓冲）
    swapBuffers();
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;1-2-游戏循环的架构风格&quot;&gt;&lt;a href=&quot;#1-2-游戏循环的架构风格&quot; class=&quot;headerlink&quot; title=&quot;1.2 游戏循环的架构风格&quot;&gt;&lt;/a&gt;1.2 游戏循环的架构风格&lt;/h2&gt;&lt;p&gt;在游戏运行时，多数游戏引擎子系统都需要周期性地提供服务，而它们所需的服务频率各有不同。动画子系统通常需要30Hz或60Hz的更新率，和渲染子系统同步。动力学模拟可能需要更频繁地更新（如120Hz）。像人工智能这种更高级的系统，可能只需要每秒1-2次更新，而且完全不需要和渲染循环同步。&lt;/p&gt;
&lt;p&gt;最简单的游戏循环，是采用&lt;strong&gt;单一循环更新所有子系统&lt;/strong&gt;，即在一个无限循环中计算逻辑并渲染画面。此外还有其他常见的架构风格，核心由若干个简单循环组成，再加上不同的修饰。&lt;/p&gt;
&lt;h3 id=&quot;1-2-1-视窗消息泵&quot;&gt;&lt;a href=&quot;#1-2-1-视窗消息泵&quot; class=&quot;headerlink&quot; title=&quot;1.2.1 视窗消息泵&quot;&gt;&lt;/a&gt;1.2.1 视窗消息泵&lt;/h3&gt;&lt;p&gt;Windows平台下，游戏除了要服务引擎本身的子系统，还要处理来自操作系统的消息。因此需要一段成为消息泵的代码来处理，基本原理是先处理来自Windows的消息，无消息时才执行引擎的任务。这种方法的副作用是设置了处理Windows消息为先，渲染和模拟游戏为后的优先次序，导致当玩家在桌面上改变游戏的视窗大小或移动视窗时，游戏就会愣住不动。典型消息泵代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;while (true) {
    // 处理所有Windows消息
    MSG msg;
    while (PeekMessage(&amp;amp;msg, NULL, 0, 0) &amp;gt; 0) {
        TranslateMessage(&amp;amp;msg);
        DispatchMessage(&amp;amp;msg);
    }
    // 再无Windows消息需要处理，执行“真正”的游戏循环迭代一次
    RunOneIterationOfGameLoop();
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;1-2-2-回调驱动框架&quot;&gt;&lt;a href=&quot;#1-2-2-回调驱动框架&quot; class=&quot;headerlink&quot; title=&quot;1.2.2 回调驱动框架&quot;&gt;&lt;/a&gt;1.2.2 回调驱动框架&lt;/h3&gt;&lt;p&gt;游戏引擎子系统和第三方游戏中间套件既可以以程序库方式构成（提供函数和类供随意调用），也有以框架构成的，程序员需提供框架中空缺的自定义实现（编写回调函数），对应用软件的控制流程只有少量甚至没有。&lt;/p&gt;
&lt;p&gt;OGRE引擎提供一套框架，程序员需要从&lt;code&gt;Ogre::FrameListener&lt;/code&gt;派生一个类，并覆写两个虚函数：&lt;code&gt;frameStarted()&lt;/code&gt;和&lt;code&gt;frameEnded()&lt;/code&gt;，OGRE在渲染主三维场景的前后会调用这两个函数。&lt;/p&gt;
&lt;h3 id=&quot;1-2-3-基于事件的更新&quot;&gt;&lt;a href=&quot;#1-2-3-基于事件的更新&quot; class=&quot;headerlink&quot; title=&quot;1.2.3 基于事件的更新&quot;&gt;&lt;/a&gt;1.2.3 基于事件的更新&lt;/h3&gt;&lt;p&gt;在游戏中，事件是指游戏状态的改变，如玩家按下手柄上的按钮、发生爆炸、敌方角色发现玩家等等。多数游戏引擎都有一个事件系统，让各个引擎子系统登记其关注的某类型事件，当那些事件发生时就可以一一回应。&lt;/p&gt;
&lt;p&gt;上述提到的以各种频率周期性更新子系统，就需要&lt;strong&gt;容许发送未来的事件&lt;/strong&gt;的事件系统来实现，即事件先置于队列，在设定的时间间隔之后才取出处理。接着，代码可以发送一个新事件，并设定该事件在未来1/30s或1/60s生效，那么这个周期性更新就能一直延续下去。&lt;/p&gt;
&lt;h1 id=&quot;2-多处理器的游戏循环&quot;&gt;&lt;a href=&quot;#2-多处理器的游戏循环&quot; class=&quot;headerlink&quot; title=&quot;2. 多处理器的游戏循环&quot;&gt;&lt;/a&gt;2. 多处理器的游戏循环&lt;/h1&gt;&lt;h2 id=&quot;2-1-多处理器游戏机的架构&quot;&gt;&lt;a href=&quot;#2-1-多处理器游戏机的架构&quot; class=&quot;headerlink&quot; title=&quot;2.1 多处理器游戏机的架构&quot;&gt;&lt;/a&gt;2.1 多处理器游戏机的架构&lt;/h2&gt;&lt;p&gt;上述讨论了基本的单线程游戏循环，而随着并行编程的架构和技术的发展，游戏引擎也需要最大化多核硬件的使用率。Xbox 360和PlayStation 3都是多处理器游戏机，为了有意义地讨论并行软件架构，需要先简单了解它们的内核架构。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://raytaylorlin-blog.qiniudn.com/image/engine/Xbox%20360%E5%92%8CPlayStation3%E7%9A%84%E5%86%85%E6%A0%B8%E6%9E%B6%E6%9E%84.jpg&quot; alt=&quot;Xbox 360和PlayStation 3的内核架构&quot;&gt;&lt;/p&gt;
&lt;p&gt;多数现代CPU都会提供单指令多数据（SIMD）指令集，其可以让一个运算同时执行于多个数据之上，此乃一种细粒度形式的硬件并行。游戏中最常用的是并行操作4个32位浮点数，可以让三维矢量和矩阵运算加速至4倍。实际使用SIMD指令时，一般要采用封装良好的三维数学库中的函数来计算。&lt;/p&gt;
&lt;h2 id=&quot;2-2-分叉与汇合&quot;&gt;&lt;a href=&quot;#2-2-分叉与汇合&quot; class=&quot;headerlink&quot; title=&quot;2.2 分叉与汇合&quot;&gt;&lt;/a&gt;2.2 分叉与汇合&lt;/h2&gt;&lt;p&gt;基本原理是把一个单位的工作分割成更小的子单位，再把这些工作量分配到多个核或硬件线程（分叉），最后待所有工作完成后再合并结果（汇合）。游戏循环应用分治法后，其结构看上去和单线程循环相似，不过更新循环的几个主要阶段都能并行化。&lt;/p&gt;
&lt;p&gt;举个例子，若动画混合使用线性插值（LERP），其操作可以独立地施于骨骼上所有关节。假设要混合5个角色的一对骨骼姿势，每个骨骼有100个关节，总共要处理500对关节姿势，可以切割成N个批次，每批次含约500/N对关节姿势。其中N按可用的处理器资源来定，如Xbox 360是3或6（3个核，每核有2个硬件线程），PS3是1-6（视有多少个SPU可用）。&lt;/p&gt;
&lt;h2 id=&quot;2-3-子系统独立线程与作业模型&quot;&gt;&lt;a href=&quot;#2-3-子系统独立线程与作业模型&quot; class=&quot;headerlink&quot; title=&quot;2.3 子系统独立线程与作业模型&quot;&gt;&lt;/a&gt;2.3 子系统独立线程与作业模型&lt;/h2&gt;&lt;p&gt;主控线程负责控制及同步这些子系统的次级子系统，子线程用于某些需重复执行且较有隔离性的子系统，如渲染引擎、物理模拟、动画管道、音频引擎等。多线程架构需要线程库支持，Windows上会使用Win32的线程API，UNIX上用类似pthread的库。&lt;/p&gt;
&lt;p&gt;使用多线程的问题之一就是，每个线程都代表相对较粗粒度的工作量（例如把所有动画任务都置于一个线程，把所有物理任务置于另一线程），这会限制多个处理器的利用率。若某个子系统线程未完成其工作，就可能阻塞主线程和其他线程。为充分利用并行硬件架构，另一种方法是把工作分割成多个细小、比较独立的作业（一组数据与操作代码结合成对），作业准备就绪就加入队列，待有闲置的处理器，作业才会从队列取出执行。PS3的SPURS库的作业模型就实现这种方法，其6个SPU只要有闲置就投入处理细粒度的作业。这样有助于最大化处理器的利用率，也可减少对主线程的限制，自然地对任何数量的处理单元进行扩展或缩减。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://raytaylorlin-blog.qiniudn.com/image/engine/%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%8B%AC%E7%AB%8B%E7%BA%BF%E7%A8%8B%E4%B8%8EPS3%E7%9A%84%E4%BD%9C%E4%B8%9A%E6%A8%A1%E5%9E%8B.jpg&quot; alt=&quot;子系统独立线程与PS3的作业模型&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;3-网络多人游戏循环&quot;&gt;&lt;a href=&quot;#3-网络多人游戏循环&quot; class=&quot;headerlink&quot; title=&quot;3. 网络多人游戏循环&quot;&gt;&lt;/a&gt;3. 网络多人游戏循环&lt;/h1&gt;&lt;h2 id=&quot;3-1-主从式模型&quot;&gt;&lt;a href=&quot;#3-1-主从式模型&quot; class=&quot;headerlink&quot; title=&quot;3.1 主从式模型&quot;&gt;&lt;/a&gt;3.1 主从式模型&lt;/h2&gt;&lt;p&gt;网游在在C/S模型下，大部分游戏逻辑运行在服务器上，客户端仅接收设备输入，渲染，处理音频，处理网络请求，以及加上一些预测玩家的代码（为了不让玩家觉得控制的游戏角色反应非常缓慢）。客户端和服务器不一定要运行于两个独立的机器上，运行在同一个机器上也很常见。网游的游戏循环可以实现为客户端和服务器为完全独立的进程；当两者在同一机器上时，可以置于同一进程的两个线程，或者为了节省本地通信的开销，都置于单个线程，由单游戏循环控制。&lt;/p&gt;
&lt;p&gt;必须注意，客户端和服务器的代码可能以不同频率进行更新。假设服务器以20FPS运行（50ms/f），客户端以60FPS运行（16.6ms/f），可以让主游戏循环以频率快者运行（60FPS），服务器每次循环会计算上次更新至今的经过时间，若超过50ms，服务器就会运行一帧，然后重置计时器。&lt;/p&gt;
&lt;h2 id=&quot;3-2-点对点模型&quot;&gt;&lt;a href=&quot;#3-2-点对点模型&quot; class=&quot;headerlink&quot; title=&quot;3.2 点对点模型&quot;&gt;&lt;/a&gt;3.2 点对点模型&lt;/h2&gt;&lt;p&gt;在这种架构下，游戏中每个动态对象，都由其对应的单一机器所管辖。&lt;strong&gt;每个机器对其拥有管辖权的对象就如同服务器，对于其他无管辖权的对象就如同是客户端&lt;/strong&gt;，只负责渲染远端管辖者所提供的对象状态。主从模型中，客户端和服务器代码分离得比较开，而在点对点模型中，许多代码都要处理（或实现）为两种游戏对象，一种是本机有管辖权的完整“真实”游戏对象，另一种是“代理版本”，仅含远程对象状态的最小子集。&lt;/p&gt;
&lt;p&gt;注意点对点架构可以设计得更复杂，如其中一机器离开游戏，则该机器所有对象的管辖权必须转移至其他参与该游戏的机器。若有新机器加入游戏，理想地该机器应接管其他机器的一些游戏对象，以平衡每部机器的工作量。以上的讨论带出的重点是，多人架构对于游戏主循环的结构有深远影响。&lt;/p&gt;
&lt;p&gt;参考文献：电子工业出版社《游戏引擎架构》第7.1-7.3、7.6、7.7节&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;游戏软件本质上是由一个大循环构成的。本文从最简单的渲染循环开始，讨论各种游戏循环的架构风格，接着针对现代多处理器硬件，简要说明一些让游戏引擎利用多核硬件的常见方法。网络游戏的游戏循环比较特殊，最后也会介绍两种最常见的多人游戏循环架构。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="游戏开发" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
      <category term="游戏引擎" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    
      <category term="游戏引擎" scheme="http://raytaylorlin.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
      <category term="架构" scheme="http://raytaylorlin.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>游戏引擎中的资源与文件系统</title>
    <link href="http://raytaylorlin.com/tech/game/engine/resources-and-file-system/"/>
    <id>http://raytaylorlin.com/tech/game/engine/resources-and-file-system/</id>
    <published>2016-06-17T06:10:20.000Z</published>
    <updated>2016-06-17T06:16:11.682Z</updated>
    
    <content type="html">&lt;p&gt;载入及管理多种媒体，是游戏引擎必须具备的能力。多数引擎会采用某种类型的资源（或资产）管理器，载入并管理游戏所需的资源，并确保在同一时间每个媒体文件只可载入一份。每个资源管理器都会大量使用文件系统。本文将介绍现代三维游戏引擎中的各种文件系统API，再分析典型资源管理器的运作方式。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-文件系统&quot;&gt;&lt;a href=&quot;#1-文件系统&quot; class=&quot;headerlink&quot; title=&quot;1. 文件系统&quot;&gt;&lt;/a&gt;1. 文件系统&lt;/h1&gt;&lt;h2 id=&quot;1-1-文件名和路径&quot;&gt;&lt;a href=&quot;#1-1-文件名和路径&quot; class=&quot;headerlink&quot; title=&quot;1.1 文件名和路径&quot;&gt;&lt;/a&gt;1.1 文件名和路径&lt;/h2&gt;&lt;p&gt;关于文件和文件夹路径的概念，绝对路径和相对路径的概念，它们在各种操作系统之间的区别，属于常识范畴，此处不赘述。&lt;/p&gt;
&lt;p&gt;关于搜寻路径，是指含若干个路径（以特殊字符分隔）的字符串，寻找文件时会从这些路径逐个寻找，PATH环境变量就是一种搜寻路径。在运行期搜寻资产是费时的做法，而通常资产路径会在运行期之前就得知，所以应该完全避免搜寻资产。&lt;/p&gt;
&lt;p&gt;关于路径API，一般用于对路径进行多种操作，如分离“目录/文件名/扩展名”、使路径规范化、绝对和相对路径互转等等。游戏引擎通常会实现或封装轻量化的路径处理API，以便实现跨平台，从各种特殊的储存媒体（如记忆棒、DVD盘、网络文件系统等等）中存取数据，以及提供操作系统API未能提供的功能，如串流（即在游戏运行中同时载入数据）。&lt;/p&gt;
&lt;h2 id=&quot;1-2-基本文件I-O&quot;&gt;&lt;a href=&quot;#1-2-基本文件I-O&quot; class=&quot;headerlink&quot; title=&quot;1.2 基本文件I/O&quot;&gt;&lt;/a&gt;1.2 基本文件I/O&lt;/h2&gt;&lt;h3 id=&quot;1-2-1-文件I-O-API&quot;&gt;&lt;a href=&quot;#1-2-1-文件I-O-API&quot; class=&quot;headerlink&quot; title=&quot;1.2.1 文件I/O API&quot;&gt;&lt;/a&gt;1.2.1 文件I/O API&lt;/h3&gt;&lt;p&gt;许多游戏引擎都会把文件I/O API封装成自定义的API，这样至少有三个好处：保证I/O API在所有目标平台上均有相同行为；API可以简化到只剩下实际需要的函数，使维护开支维持最小限度；可提供延伸功能，如处理各种特殊的储存媒体（同自定义路径处理API）。&lt;/p&gt;
&lt;p&gt;每次调用输入/输出，都需要称为缓冲区的数据区块，以供程序和磁盘之间传送字节。当API负责管理数据缓冲，就称之为有缓冲功能的API，否则为无缓冲。C标准程序库中，以f开头的文件API是带缓冲的，如&lt;code&gt;fopen()&lt;/code&gt;，没有f开头是无缓冲的，如&lt;code&gt;read()&lt;/code&gt;。有时自行管理缓冲区是有必要的。例如往日志写数据可能会显著降低性能，可以先把数据累积在内存缓冲，满溢后才写进盘内，甚至把缓冲输出函数置于另一线程里，以避免令主游戏循环发生流水线停顿。&lt;/p&gt;
&lt;h3 id=&quot;1-2-2-同步与异步&quot;&gt;&lt;a href=&quot;#1-2-2-同步与异步&quot; class=&quot;headerlink&quot; title=&quot;1.2.2 同步与异步&quot;&gt;&lt;/a&gt;1.2.2 同步与异步&lt;/h3&gt;&lt;p&gt;C标准库的两种文件I/O库都是同步的，即程序发出I/O请求以后，必须等待读/写数据完毕，程序才能继续运行。为了提高用户体验，往往要使用串流来载入资源，这必须使用异步文件I/O库。多数异步I/O库容许主程序在请求发出后一段时间，等待I/O操作完成才继续运行。有些异步I/O库容许程序员取得某异步操作所需时间的估算，一些API也可以为请求设置时限，并设置请求超时的安排（例如取消请求、通知程序、继续尝试等）。&lt;/p&gt;
&lt;p&gt;异步I/O操作常有不同的优先权，例如从硬盘中串流音频，并且在串流其他资源时播放音频，显然前者优先权高于后者。异步I/O系统必须能暂停较低优先权的请求，才可以让较高优先权的I/O请求有机会在时限前完成。&lt;/p&gt;
&lt;p&gt;关于异步操作（不局限于文件I/O）的实现原理，一般是利用另一线程进行同步操作来实现。主线程调用异步函数时，会把请求放入一个队列，并立即传回。同时，I/O线程从队列中取出请求，并以阻塞I/O函数处理这些请求。请求的工作完成后，就会调用主线程之前提供的回调函数告之该操作己完成。若主线程选择等待完成I/O请求，就会使用信号量处理（每个请求对应一个信号量，主线程把自身处于休眠状态，等待I/O线程在完成请求工作后通知信号量）。&lt;/p&gt;
&lt;h1 id=&quot;2-资源管理器&quot;&gt;&lt;a href=&quot;#2-资源管理器&quot; class=&quot;headerlink&quot; title=&quot;2. 资源管理器&quot;&gt;&lt;/a&gt;2. 资源管理器&lt;/h1&gt;&lt;p&gt;资源管理器由两部分组成：一部分负责管理离线工具链，用来创建资产并把它们转换成引擎可用的形式；另一部分在执行期管理资源，确保资源在使用前已载入内存，不需要时从内存卸下。&lt;/p&gt;
&lt;h2 id=&quot;2-1-离线资源管理与工具链&quot;&gt;&lt;a href=&quot;#2-1-离线资源管理与工具链&quot; class=&quot;headerlink&quot; title=&quot;2.1 离线资源管理与工具链&quot;&gt;&lt;/a&gt;2.1 离线资源管理与工具链&lt;/h2&gt;&lt;h3 id=&quot;2-1-1-资产的版本控制&quot;&gt;&lt;a href=&quot;#2-1-1-资产的版本控制&quot; class=&quot;headerlink&quot; title=&quot;2.1.1 资产的版本控制&quot;&gt;&lt;/a&gt;2.1.1 资产的版本控制&lt;/h3&gt;&lt;p&gt;有些游戏团队使用源码版本控制工具来管理资源。艺术资产通常有极大的数据量，直接从中央版本库复制到本地往往是低效的。以下是一些参考解决方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用如Alienbrain这种特别针对极大量数据的商业VCS&lt;/li&gt;
&lt;li&gt;在VCS上精心设计一套系统，保证用户只会取得其真正所需的文件到本地&lt;/li&gt;
&lt;li&gt;顽皮狗开发了一款私有工具。用户拥有资产版本库的完整本地视图，只要文件未签出，本地就一直是UNIX的符号链接（Windows可以使用junction实现）以消除数据复制。当签出文件时则移除符号链接，更换为本地副本，签入时则相反。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;2-1-2-资源数据库&quot;&gt;&lt;a href=&quot;#2-1-2-资源数据库&quot; class=&quot;headerlink&quot; title=&quot;2.1.2 资源数据库&quot;&gt;&lt;/a&gt;2.1.2 资源数据库&lt;/h3&gt;&lt;p&gt;游戏引擎不会使用多数资产原本的格式，而是需要通过一些资产调节管道转换资产，转换过程中每个资源都会产生&lt;strong&gt;元数据&lt;/strong&gt;描述如何对资源进行处理。例如描述压缩纹理时，使用哪种压缩方法；描述导出动画片段时，导出哪个范围的帧。大型游戏需要“资源数据库”来管理资源管道所需的数据。无论采用什么形式，数据库都需要提供以下功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以一致的方式处理多种类型的资源&lt;/li&gt;
&lt;li&gt;创建、删除、查看、移动磁盘位置和修改资源&lt;/li&gt;
&lt;li&gt;资源交叉引用其他资源，并维持数据库内的引用完整性&lt;/li&gt;
&lt;li&gt;保存版本历史，含完整日志记录、改动者及事由&lt;/li&gt;
&lt;li&gt;支持不同形式的搜索和查询&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;2-1-3-一些成功的资源数据库设计&quot;&gt;&lt;a href=&quot;#2-1-3-一些成功的资源数据库设计&quot; class=&quot;headerlink&quot; title=&quot;2.1.3 一些成功的资源数据库设计&quot;&gt;&lt;/a&gt;2.1.3 一些成功的资源数据库设计&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;虚幻3：由万用工具UnrealEd管理，它是引擎的一部分&lt;ul&gt;
&lt;li&gt;优点：创建资产后能立即看到资产在游戏中运行的模样；以单一、整合、一致的界面管理所有类型的资源；资产必须明确导入数据库，制作初期便可检查资源有效性&lt;/li&gt;
&lt;li&gt;缺点：所有资源存于少量的大型二进制包文件，不利于VCS合并；资源重命名或移动时，使用虚拟对象，即把旧资源映射到新名称/位置，问题是虚拟对象会闲置、累积起来造成问题，尤其是删除资源时变得严重&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;顽皮狗的《神秘海域》引擎&lt;ul&gt;
&lt;li&gt;最初使用MySQL存储资源元数据，并编写自制GUI工具Builder管理，后改用Perforce以提供版本控制，元数据改为XML&lt;/li&gt;
&lt;li&gt;Builder管理演员（包含行为的动态对象）和关卡（含静态背景网格和关卡信息等）两种类型的资源，动画可以组成名为动画包（buddle）的伪文件夹&lt;/li&gt;
&lt;li&gt;引擎含一组基于命令行的工具，用于查询数据库，处理资源原生DCC文件，生成某演员或关卡&lt;/li&gt;
&lt;li&gt;优点：资源粒度小；Builder仅提供必需的特性；源文件映射显而易见，用户容易得知某资源由哪些资产而来；容易更改DCC数据的到处及处理方式；依赖系统会自动处理，生成资产非常容易&lt;/li&gt;
&lt;li&gt;缺点：欠缺预览资产的可视化工具；各种类型的工具没有完全整合&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;OGRE：拥有一个颇完备、设计非常好的运行时资源管理器，通过一组简单一致又有扩展性的接口就能载入任何类型的资源。缺点在于仅是运行时方案，本身提供的离线处理很弱&lt;/li&gt;
&lt;li&gt;微软的XNA：通过VS IDE的项目管理及生成系统，把游戏资产以同样形式管理及生成&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;2-1-4-资产调节管道&quot;&gt;&lt;a href=&quot;#2-1-4-资产调节管道&quot; class=&quot;headerlink&quot; title=&quot;2.1.4 资产调节管道&quot;&gt;&lt;/a&gt;2.1.4 资产调节管道&lt;/h3&gt;&lt;p&gt;资产调节管道用于将DCC原生格式文件转换成引擎可用的形式，一般经过3个处理阶段：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;导出器：为DCC工具编写自定义插件，将数据导出为某种中间格式。如果DCC不提供自定义方法，则应该把数据存成开放格式，或比较直观的文本格式，或其他可做反向工程的原生格式&lt;/li&gt;
&lt;li&gt;资源编译器：对DCC导出的数据进行一定处理，如把网格的三角形重新排列成三角形带，或压缩纹理。并非所有数据都要编译&lt;/li&gt;
&lt;li&gt;资源链接器：将多个资源先结合成单个有用的包，如复杂的三维模型，然后才载入至游戏引擎。并非所有数据都要链接&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如同程序的源文件，各资产之间也有依赖关系，例如某网格引用若干个材质，这些材质又引用多个纹理。这些依赖关系通常会影响资产在管道内的处理次序，也可告诉我们，当某个源资产做出改动后，要重新生成哪些资产。每个资产调节管道都需要一组规则来描述资产间的依赖关系，并自己搭建系统或使用像make这样的工具来以正确顺序生成资产。一定要管理好资产间的依赖。&lt;/p&gt;
&lt;h2 id=&quot;2-2-运行时资源管理&quot;&gt;&lt;a href=&quot;#2-2-运行时资源管理&quot; class=&quot;headerlink&quot; title=&quot;2.2 运行时资源管理&quot;&gt;&lt;/a&gt;2.2 运行时资源管理&lt;/h2&gt;&lt;h3 id=&quot;2-2-1-运行时资源管理器的责任&quot;&gt;&lt;a href=&quot;#2-2-1-运行时资源管理器的责任&quot; class=&quot;headerlink&quot; title=&quot;2.2.1 运行时资源管理器的责任&quot;&gt;&lt;/a&gt;2.2.1 运行时资源管理器的责任&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;确保任何时候，同一个资源在内存中只有一份副本&lt;/li&gt;
&lt;li&gt;管理每个资源的生命期&lt;/li&gt;
&lt;li&gt;处理复合资源的载入（如三维模型）&lt;/li&gt;
&lt;li&gt;维护引用完整性：包括单个资源内的交叉引用，以及资源间的交叉引用&lt;/li&gt;
&lt;li&gt;管理资源载入后的内存用量，确保资源储存在内存中合适的地方&lt;/li&gt;
&lt;li&gt;容许按资源类型，载入资源后执行自定义的处理&lt;/li&gt;
&lt;li&gt;通常提供统一的易扩展的接口管理多种资源类型&lt;/li&gt;
&lt;li&gt;若引擎支持，则要处理串流&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;2-2-1-资源文件及目录组织&quot;&gt;&lt;a href=&quot;#2-2-1-资源文件及目录组织&quot; class=&quot;headerlink&quot; title=&quot;2.2.1 资源文件及目录组织&quot;&gt;&lt;/a&gt;2.2.1 资源文件及目录组织&lt;/h3&gt;&lt;p&gt;资源一般储存为磁盘上的文件，并位于使创作者方便而组织的树状目录中。但引擎通常不会理会资源被放置于资源树中的哪个位置，引擎会把多个资源包裹为单一文件，这种手法能将寻道时间、开启每个文件的时间、从文件读至内存的时间都降到最低。&lt;/p&gt;
&lt;p&gt;OGRE使用ZIP存档资源，因为ZIP是开放格式，内部虚拟文件有相对路径，可被压缩（载入数据后解压所花的时间，通常比读取无压缩数据所花的时间少），并可视为模块（例如把需要本地化的资产打包，针对不同语言制作不同版本的ZIP）。虚幻3采取类似的手法，但是其所有资源都必须置于大型的pak自定义格式文件中，并不容许资源以盘上独立文件出现。&lt;/p&gt;
&lt;h3 id=&quot;2-2-2-资源文件格式和GUID&quot;&gt;&lt;a href=&quot;#2-2-2-资源文件格式和GUID&quot; class=&quot;headerlink&quot; title=&quot;2.2.2 资源文件格式和GUID&quot;&gt;&lt;/a&gt;2.2.2 资源文件格式和GUID&lt;/h3&gt;&lt;p&gt;每类资源都可能有不同的文件格式。单一文件格式也可储存多种不同类型的资产，如Granny的文件格式可轻易用来储存任何种类的数据。许多引擎会自定义文件格式，因为引擎所需部分信息可能没有标准格式可以支持，以及对资源脱机处理，以让其遵从某种内存布局加速运行时载入。&lt;/p&gt;
&lt;p&gt;所有资源都需要GUID来识别，最常见就是使用资源的文件系统路径（操作系统保证两个文件不能有相同的路径），也有使用128位散列GUID的。虚幻3的GUID格式是包名和包内资源路径串接而成，像《战争机器》的一个资源GUID为&lt;code&gt;Locust_Boomer.PhysicalMaterials.LocustBommerLeather&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;2-2-3-资源注册表&quot;&gt;&lt;a href=&quot;#2-2-3-资源注册表&quot; class=&quot;headerlink&quot; title=&quot;2.2.3 资源注册表&quot;&gt;&lt;/a&gt;2.2.3 资源注册表&lt;/h3&gt;&lt;p&gt;资源管理器都含某种形式的资源注册表，以&lt;strong&gt;保证在任何时间，载入内存的每个资源只会有一份副本&lt;/strong&gt;。最简单的实现方法是使用字典，键为资源的GUID，而值是指向内存中资源的指针。资源载入内存时，加进资源注册表字典。卸下资源时，就删除其注册表记录。&lt;/p&gt;
&lt;p&gt;若不能从表中找到请求的资源，最直觉的处理手法就是自动载入该资源。但这样做可能会因为临时从硬盘或光驱等缓慢设备读取数据而严重拖慢游戏帧率。因此引擎可采取这两种替代手法：游戏进行中完全禁止加载资源（游戏关卡的所有资源在游戏进行前全部加载，那时候通常是loading界面）；或资源以相对较难实现的异步形式加载，如玩关卡A时，关卡B的资源在后台加载。&lt;/p&gt;
&lt;h3 id=&quot;2-2-4-资源生命期&quot;&gt;&lt;a href=&quot;#2-2-4-资源生命期&quot; class=&quot;headerlink&quot; title=&quot;2.2.4 资源生命期&quot;&gt;&lt;/a&gt;2.2.4 资源生命期&lt;/h3&gt;&lt;p&gt;资源管理器的职责之一是自动管理资源生命期，或对游戏提供所需API供手动管理。每个资源对生命期有不同需求：游戏持续的所有时间（如角色网格、纹理、动画，HUD的纹理字形等等），持续某一关卡的时间，短于所在关卡的时间（如过场动画），即时串流（如BGM、环境音效等）。&lt;/p&gt;
&lt;p&gt;某资源的载入时期通常在玩家第一次看见该资源便能决定，但何时卸下资源归还内存，就难以回答，因为可能存在多个关卡共享的资源。解决方案之一就是对资源引用计数，即载入新关卡时，遍历所需资源并引用加1，再遍历即将结束的关卡的资源，所有引用减1。下图给出了资源引用计数的例子。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://raytaylorlin-blog.qiniudn.com/image%2Fengine%2F%E8%BD%BD%E5%85%A5%E6%88%96%E5%8D%B8%E4%B8%8B%E4%B8%A4%E4%B8%AA%E5%85%B3%E5%8D%A1%E6%97%B6%E8%B5%84%E6%BA%90%E7%9A%84%E5%BC%95%E7%94%A8%E5%8F%98%E5%8C%96.jpg&quot; alt=&quot;载入或卸下两个关卡时资源的引用变化&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-2-5-资源的内存管理&quot;&gt;&lt;a href=&quot;#2-2-5-资源的内存管理&quot; class=&quot;headerlink&quot; title=&quot;2.2.5 资源的内存管理&quot;&gt;&lt;/a&gt;2.2.5 资源的内存管理&lt;/h3&gt;&lt;p&gt;资源加载的内存位置可能不同，像纹理、顶点缓冲、着色器驻留在显存，大部分资源驻留在主内存。设计游戏引擎时，有时用已有的内存分配器来设计资源系统，有时则要让内存分配器配合资源管理所需。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于堆栈分配器：若游戏是以线性关卡为中心，且内存足够容纳各个完整关卡，则可用堆栈分配器。注意栈顶端先分配驻留资源（LSR，各关卡共享的资源），再分配关卡所需内存。&lt;/li&gt;
&lt;li&gt;基于池分配器：因为每个内存组块大小相同，要注意设计资源数据时，必须避免大型连续数据结构，容许资源能被切割成同等大小的块。这种分配方式天生的问题就是文件内&lt;strong&gt;最后的组块&lt;/strong&gt;空间被浪费。选择组块大小时，可以考虑设为操作系统I/O缓冲区大小的倍数，如512KB。&lt;/li&gt;
&lt;li&gt;资源组块分配器：专为解决上述组块浪费内存而设的分配模式。只需管理一个链表，内含所有未用满内存的组块以及自由内存块的位置及大小。这种方案有一个问题是卸下资源内存时，其“边角”的组块也会同时消失。解决方案是只利用该种分配器分配&lt;strong&gt;和对应关卡生命期相同的内存&lt;/strong&gt;，这需要独立地管理每个关卡的组块，且用户请求分配时指明从哪个关卡分配内存。&lt;/li&gt;
&lt;li&gt;分段资源文件：将资源文件分为若干段，每段分为若干个组块（与池分配器配合）。各段的作用不同，有的是为主内存而设的数据，有的是仅在载入过程中使用、载入后被弃置的临时数据，有的是发行版本不会载入的调试信息&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;2-2-6-资源的交叉引用&quot;&gt;&lt;a href=&quot;#2-2-6-资源的交叉引用&quot; class=&quot;headerlink&quot; title=&quot;2.2.6 资源的交叉引用&quot;&gt;&lt;/a&gt;2.2.6 资源的交叉引用&lt;/h3&gt;&lt;p&gt;资源的交叉引用意味着资源间的依赖性，所以资源数据库可以表达为依赖对象所组成的有向图。交叉引用可以分为内部（单个文件里对象间的引用）和外部（引用另一个文件的对象）。下图给出了资源数据库的交叉引用例子。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://raytaylorlin-blog.qiniudn.com/image%2Fengine%2F%E8%B5%84%E6%BA%90%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BA%A4%E5%8F%89%E5%BC%95%E7%94%A8%E4%BE%8B%E5%AD%90.png&quot; alt=&quot;资源数据库的交叉引用例子&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;2-2-6-1-处理资源内部引用&quot;&gt;&lt;a href=&quot;#2-2-6-1-处理资源内部引用&quot; class=&quot;headerlink&quot; title=&quot;2.2.6.1 处理资源内部引用&quot;&gt;&lt;/a&gt;2.2.6.1 处理资源内部引用&lt;/h4&gt;&lt;p&gt;在C++中， 由于指针的内存地址总会变，而且离开运行中的程序就失去意义，所以不能用指针来表示对象间的依赖。可以将资源引用存为GUID（全局唯一的字符串或散列码），资源管理器要维护一个全局资源查找表，其中键为GUID，值为资源在内存中的地址。&lt;/p&gt;
&lt;p&gt;储存对象到二进制文件的另一常用方法是，把指针转换为为文件偏移值，并建立指针修正表。下图给出了储存二进制文件以及将文件载入内存的指针修正示意，具体过程为：①把每个对象的内存影响遍历一次，顺序写至文件成为连续映像；②写进文件的代码，清楚知道对象的数据类型和类，也就知道每个对象的指针在哪里，把这些指针位置储存到指针修正表并一同写进文件；③载入文件至内存时，映像内对象仍保持连续，并凭借修正表修正所有指针。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://raytaylorlin-blog.qiniudn.com/image%2Fengine%2F%E5%82%A8%E5%AD%98%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E4%BB%A5%E5%8F%8A%E5%B0%86%E6%96%87%E4%BB%B6%E8%BD%BD%E5%85%A5%E5%86%85%E5%AD%98%E7%9A%84%E6%8C%87%E9%92%88%E4%BF%AE%E6%AD%A3%E7%A4%BA%E6%84%8F.jpg&quot; alt=&quot;储存二进制文件以及将文件载入内存的指针修正示意&quot;&gt;&lt;/p&gt;
&lt;p&gt;从文件载入C++对象，必须调用对象的构造函数。这个问题有两个常见解决方案：使用纯C结构体来储存数据或使用无虚函数、只含不做事情的平凡构造函数的C++ struct/class；表里记录对象属于哪个类，并使用&lt;a href=&quot;https://en.wikipedia.org/wiki/Placement_syntax&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;placement new&lt;/a&gt;语法调用构造函数，像下面的代码所示。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void* pObject = ConvertOffsetToPointer(objectOffset);
::new(pObject) ClassName;  // placement new语法，ClassName为对象所属的类名
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;2-2-6-2-处理资源外部引用&quot;&gt;&lt;a href=&quot;#2-2-6-2-处理资源外部引用&quot; class=&quot;headerlink&quot; title=&quot;2.2.6.2 处理资源外部引用&quot;&gt;&lt;/a&gt;2.2.6.2 处理资源外部引用&lt;/h4&gt;&lt;p&gt;以上提及的两个方案，仅对资源内部引用有效。要正确表示外部引用，除了指明偏移值或GUID，还要加上资源对象所属文件的路径。一般做法是：载入每个资源文件时，扫描文件中的交叉引用表，并载入所有被外部引用但未载入的资源文件，当载入所有互相依赖的资源时，就用主查找表把所有指针转换成真实的内存地址。&lt;/p&gt;
&lt;h3 id=&quot;2-2-7-资源载入后初始化&quot;&gt;&lt;a href=&quot;#2-2-7-资源载入后初始化&quot; class=&quot;headerlink&quot; title=&quot;2.2.7 资源载入后初始化&quot;&gt;&lt;/a&gt;2.2.7 资源载入后初始化&lt;/h3&gt;&lt;p&gt;有一些资源载入内存时需要进行一些无法避免的初始化，例如三维网格的顶点和索引载入主内存后，几乎总是要传送至显存，而且只能在运行时进行。在C++中，可以使用多态为每个类设置如&lt;code&gt;Init()&lt;/code&gt;和&lt;code&gt;Destroy()&lt;/code&gt;的虚函数用于独立初始化和销毁工作。载入后初始化和资源内存分配策略息息相关，有时初始化会在文件的数据上新增数据（如额外计算类中的成员数据），有时初始化的数据用来取代己载入的数据（如引擎载入过时格式的网格数据，自动转换为最新格式，以保证向后兼容）。可以采用先载入到临时内存区域，初始化完成后再把相关数据复制到内存最终位置。&lt;/p&gt;
&lt;p&gt;参考文献：电子工业出版社《游戏引擎架构》第6章&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;载入及管理多种媒体，是游戏引擎必须具备的能力。多数引擎会采用某种类型的资源（或资产）管理器，载入并管理游戏所需的资源，并确保在同一时间每个媒体文件只可载入一份。每个资源管理器都会大量使用文件系统。本文将介绍现代三维游戏引擎中的各种文件系统API，再分析典型资源管理器的运作方式。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="游戏开发" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
      <category term="游戏引擎" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    
      <category term="游戏引擎" scheme="http://raytaylorlin.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
      <category term="架构" scheme="http://raytaylorlin.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>游戏引擎支持系统（下）</title>
    <link href="http://raytaylorlin.com/tech/game/engine/engine-support-system-2/"/>
    <id>http://raytaylorlin.com/tech/game/engine/engine-support-system-2/</id>
    <published>2016-06-12T12:33:11.000Z</published>
    <updated>2016-06-15T03:13:24.282Z</updated>
    
    <content type="html">&lt;p&gt;游戏编程中需要使用各种各样的集合型数据结构，称为容器或集合。字符串看似是个简单基本的数据类型，但在游戏引擎中会涉及许多设计问题和限制。此外，游戏引擎总是伴随大量可调校的选项，有的通过游戏中的选项菜单给玩家调校，有的则只为游戏开发团队设置，在正式发行时被隐掉或去除。&lt;/p&gt;
&lt;p&gt;本文将接着&lt;a href=&quot;/tech/game/engine/engine-support-system-1/&quot;&gt;上一篇&lt;/a&gt;，从游戏引擎的角度描述容器、字符串和引擎配置等游戏引擎支持系统。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-容器&quot;&gt;&lt;a href=&quot;#1-容器&quot; class=&quot;headerlink&quot; title=&quot;1. 容器&quot;&gt;&lt;/a&gt;1. 容器&lt;/h1&gt;&lt;p&gt;常见的容器类型包括但不限于：数组、动态数组（可变长）、链表 、堆栈、队列、双端队列、优先队列（二叉堆）、树、二叉查找树（红黑树、伸展树、AVL树等）、字典、集合、图、有向非循环图。常见操作有：插入、移除、顺序访问/迭代、随机访问、查找、排序等等。&lt;/p&gt;
&lt;p&gt;访问容器元素通常都会使用迭代器，它“知道”如何高效地访问容器中的某个元素，移至下一个元素，并用某种方式表示是否遍历完所有元素。使用迭代器的好处是：避免破坏容器类的封装，简化迭代过程。&lt;/p&gt;
&lt;h2 id=&quot;1-1-是否建立自定义的容器类&quot;&gt;&lt;a href=&quot;#1-1-是否建立自定义的容器类&quot; class=&quot;headerlink&quot; title=&quot;1.1 是否建立自定义的容器类&quot;&gt;&lt;/a&gt;1.1 是否建立自定义的容器类&lt;/h2&gt;&lt;p&gt;许多游戏引擎会提供常见容器的自定义实现，而非使用第三方库，原因如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;完全掌控：控制数据结构的内存需求、具体算法、分配内存时机等&lt;/li&gt;
&lt;li&gt;优化的机会：如借助游戏机独有的硬件功能来优化&lt;/li&gt;
&lt;li&gt;可定制性：提供第三方库不常见的功能，如搜寻n个最相关的元素&lt;/li&gt;
&lt;li&gt;消除外部依赖：使用第三方库有无法自行调试维护的风险&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第三方库功能强大，使用方便，但有时并不适合游戏引擎。如果决定要使用第三方库，要对它们的优缺点有全方位的了解。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;STL&lt;ul&gt;
&lt;li&gt;优点：功能丰富；跨平台；几乎所有C++编译器都自带&lt;/li&gt;
&lt;li&gt;缺点：学习曲线陡峭；相比自定义数据结构速度较慢；占用更多内存；进行许多动态内存分配；各编译器的实现微小差异导致移植多平台麻烦&lt;/li&gt;
&lt;li&gt;STL比较适合PC上的引擎，而不适用于游戏主机&lt;/li&gt;
&lt;li&gt;使用经验：用某个STL类前，充分认识其效能和内存特性；避免在可能的性能瓶颈处使用STL；占小量内存的情况才使用STL；若引擎需要支持多平台，推荐会用STLport&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Boost&lt;ul&gt;
&lt;li&gt;优点：提供许多STL没有的有用功能；提供解决STL设计或实现上的问题的替代方案；有效处理智能指针这种复杂问题；文档写得很好（也是优秀的学习材料）&lt;/li&gt;
&lt;li&gt;缺点：生成颇大的.lib文件，不适合小型项目；不保证支持向后兼容；小心阅读许可证内容&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://loki-lib.sourceforge.net/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Loki&lt;/a&gt;：其模板元编程功能极其强大，但代码可能望而生畏，难以使用，而且某些元件依赖编译器的“副作用”行为。Loki不适合胆小者，但是其设计理念非常值得学习&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-2-一些常用数据结构的使用建议&quot;&gt;&lt;a href=&quot;#1-2-一些常用数据结构的使用建议&quot; class=&quot;headerlink&quot; title=&quot;1.2 一些常用数据结构的使用建议&quot;&gt;&lt;/a&gt;1.2 一些常用数据结构的使用建议&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;动态数组：游戏编程中大量使用固定大小数组以避免动态分配的开销，而且因连续而对缓存友好。可以在开发期选用动态数组，当确定适当的内存预算时，将其改为固定大小的数组（可以自行建立一个兼容&lt;code&gt;std::vector&lt;/code&gt;接口的模板&lt;/li&gt;
&lt;li&gt;链表&lt;ul&gt;
&lt;li&gt;外露式表：节点保存&lt;strong&gt;指向实际元素&lt;/strong&gt;的指针。优点是一个元素能同时置于多个链表，缺点是必须动态分配节点。使用池分配器是最佳选择。&lt;/li&gt;
&lt;li&gt;侵入式表：元素的数据结构被嵌入节点。优点是无须动态分配，缺点是没有外露式表那么有弹性。&lt;/li&gt;
&lt;li&gt;若不惜一切代价都要避免动态内存分配，则选用侵入式表；若能负担得起池分配的开销，或链表中的实例来自第三方库，则选用外露式表&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;字典和散列表：注意散列（把任意类型的键转换为整数）函数的选择是关键。若键为32位整数，把其位模式诠释为32位整数；若键为字符串，则把字符串中所有字符的ASCII或UTF码合并为单个32位整数，常见的字符串散列函数有LOOKUP3、CRC32、MD5等等&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;2-字符串&quot;&gt;&lt;a href=&quot;#2-字符串&quot; class=&quot;headerlink&quot; title=&quot;2. 字符串&quot;&gt;&lt;/a&gt;2. 字符串&lt;/h1&gt;&lt;h2 id=&quot;2-1-字符串类&quot;&gt;&lt;a href=&quot;#2-1-字符串类&quot; class=&quot;headerlink&quot; title=&quot;2.1 字符串类&quot;&gt;&lt;/a&gt;2.1 字符串类&lt;/h2&gt;&lt;p&gt;字符串类虽然方便，但有隐性成本：传递字符串对象时，函数声明或使用不当引起多个拷贝构造函数的开销；复制字符串涉及动态内存分配。若一定要使用字符串类，应该查明其运行性能特性在可接受的范围，并让所有使用它的程序员知悉其开销。&lt;/p&gt;
&lt;p&gt;在储存和管理文件系统路径时，使用特化的字符串类（如Path类）来处理多平台的字符串差异，在游戏引擎中是很有价值的。&lt;/p&gt;
&lt;h2 id=&quot;2-2-唯一标识符&quot;&gt;&lt;a href=&quot;#2-2-唯一标识符&quot; class=&quot;headerlink&quot; title=&quot;2.2 唯一标识符&quot;&gt;&lt;/a&gt;2.2 唯一标识符&lt;/h2&gt;&lt;p&gt;唯一标识符（64位或128位的GUID字符串）用于识别游戏对象或资产，由于数量非常多，大量的比较在游戏中可能极有影响。最好找到一种方法，既保留字符串的表达能力和弹性，又要有整数操作的速度。可以把字符串散列并存于表中（该过程称为字符串扣留），并通过散列码（也称为字符串标识符，string id或SID）取回原来的字符串，但要选取恰当的散列函数保证不碰撞。&lt;/p&gt;
&lt;p&gt;因为字符串扣留（散列，分配字符串内存，复制至查找表）非常缓慢，所以通常&lt;strong&gt;在运行时就进行，而且仅进行一次，把结果储存备用&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;2-3-本地化&quot;&gt;&lt;a href=&quot;#2-3-本地化&quot; class=&quot;headerlink&quot; title=&quot;2.3 本地化&quot;&gt;&lt;/a&gt;2.3 本地化&lt;/h2&gt;&lt;p&gt;对每个向用户显示的字符串，都要事先翻译为需要支持的语言（程序内部使用的，永不显示于用户的字符串无须本地化）。除了通过使用合适的字体，为所有支持语言准备字符字形，游戏还需要处理不同的文本方向（针对一些阅读顺序很特殊的语言）。&lt;/p&gt;
&lt;p&gt;推荐先阅读这篇文章：&lt;a href=&quot;http://local.joelonsoftware.com/wiki/The_Joel_on_Software_Translation_Project:%E8%90%AC%E5%9C%8B%E7%A2%BC&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《每个软件开发者都绝对必知的Unicode及字元集必备知识(没有借口！)》&lt;/a&gt;。游戏引擎中最常采用的是UTF-8和UTF-16。&lt;/p&gt;
&lt;h3 id=&quot;2-3-1-Windows下的Unicode&quot;&gt;&lt;a href=&quot;#2-3-1-Windows下的Unicode&quot; class=&quot;headerlink&quot; title=&quot;2.3.1 Windows下的Unicode&quot;&gt;&lt;/a&gt;2.3.1 Windows下的Unicode&lt;/h3&gt;&lt;p&gt;在Windows下，&lt;code&gt;wchar_t&lt;/code&gt;用来表示单个“宽”UTF-16字符（WCS），&lt;code&gt;char&lt;/code&gt;则用作ANSI字符及多字节UTF-16字符串（MBCS）。Windows容许程序员编写&lt;strong&gt;字符集无关&lt;/strong&gt;的代码，即提供&lt;code&gt;TCHAR&lt;/code&gt;数据类型，它会根据实际所用的字符集自动typedef为特定的类型。&lt;/p&gt;
&lt;p&gt;注意Windows中各种API和标准函数库，无前缀表示普通ANSI字符，前缀为“w”“wcs”表示宽字符，缀为“mbs”表示多字节UTF-16，如&lt;code&gt;strcmp()&lt;/code&gt;、&lt;code&gt;wcscmp()&lt;/code&gt;和&lt;code&gt;_mbscmp()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;对于游戏机上的Unicode，Xbox 360开发套件几乎完全采用WCS字符串。不同的引擎采用哪种编码并不重要，重要的是在项目中尽早决定，并始终贯彻使用。&lt;/p&gt;
&lt;h3 id=&quot;2-3-2-其他本地化要考虑的事&quot;&gt;&lt;a href=&quot;#2-3-2-其他本地化要考虑的事&quot; class=&quot;headerlink&quot; title=&quot;2.3.2 其他本地化要考虑的事&quot;&gt;&lt;/a&gt;2.3.2 其他本地化要考虑的事&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;本地化不仅包括字符，还包括录制语音、带文字的纹理，还要注意一些符号在不同文化中意义的差别，注意不同市场的评级界限&lt;/li&gt;
&lt;li&gt;本地化系统需要建立字符串数据库，通过SID以及全局的“当前语言”设定来查找对应的语言字符串。其函数声明可能为：&lt;code&gt;const wchar_t* getLocalizedString(const char* sid)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;数据库的实现细节不是很重要，可以用CSV，也可以用专门的DBMS&lt;/li&gt;
&lt;li&gt;程序员切记&lt;strong&gt;不要硬编码原始字符串&lt;/strong&gt;，而是采用上述查找函数取得所需字符串。注意字符串可能需要处理像&lt;code&gt;&amp;quot;Player {0} Score: {1}&amp;quot;&lt;/code&gt;这样的格式化串&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;3-引擎配置&quot;&gt;&lt;a href=&quot;#3-引擎配置&quot; class=&quot;headerlink&quot; title=&quot;3. 引擎配置&quot;&gt;&lt;/a&gt;3. 引擎配置&lt;/h1&gt;&lt;h2 id=&quot;3-1-读写选项&quot;&gt;&lt;a href=&quot;#3-1-读写选项&quot; class=&quot;headerlink&quot; title=&quot;3.1 读写选项&quot;&gt;&lt;/a&gt;3.1 读写选项&lt;/h2&gt;&lt;p&gt;可配置选项可简单实现为全局变量或单例中的成员变量，这些选项必须可供用户配置，储存到硬盘、记忆卡或其他媒体，游戏能随时读取。下面是一些读写选项的方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文本配置文件：如INI、XML、JSON等等&lt;/li&gt;
&lt;li&gt;经压缩的二进制文件：主要用于老式游戏主机上储存空间极其有限的记忆卡&lt;/li&gt;
&lt;li&gt;Windows注册表：以树形式存储，内部节点为注册表项（类似文件夹），叶节点以键值对储存选项。任何应用程序都可预留一个注册表项存储任意内容&lt;/li&gt;
&lt;li&gt;命令行选项：通过扫描命令行取得选项设置&lt;/li&gt;
&lt;li&gt;环境变量&lt;/li&gt;
&lt;li&gt;线上用户设定档：存储在中央服务器，必须通过联网存取，一般用于存储用户成就、已购买或解锁的游戏内容、游戏选项及其他信息&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;3-2-个别用户选项&quot;&gt;&lt;a href=&quot;#3-2-个别用户选项&quot; class=&quot;headerlink&quot; title=&quot;3.2 个别用户选项&quot;&gt;&lt;/a&gt;3.2 个别用户选项&lt;/h2&gt;&lt;p&gt;个别用户选项保留了每个玩家自己配置其喜欢的选项，与全局选项区分开来。需要小心控制每个玩家只能“看见”自己的选项，而不会遇见其他玩家在同一设备的选项。&lt;/p&gt;
&lt;p&gt;在Windows上，应用程序通常在&lt;code&gt;C:\Documents and Settings&lt;/code&gt;的隐藏文件夹&lt;code&gt;Application Data&lt;/code&gt;文件夹中建立自己的文件夹，存放个别用户数据。或者通过读写注册表&lt;code&gt;HKEY_CURRENT_USER&lt;/code&gt;下的注册表项，来存取管理当前用户的配置选项。&lt;/p&gt;
&lt;h2 id=&quot;3-3-真实引擎中的配置管理&quot;&gt;&lt;a href=&quot;#3-3-真实引擎中的配置管理&quot; class=&quot;headerlink&quot; title=&quot;3.3 真实引擎中的配置管理&quot;&gt;&lt;/a&gt;3.3 真实引擎中的配置管理&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;雷神之锤的主控台变量（Console Variables，CVAR）：一个储存浮点数或字符串的全局变量，可在主控台下查看及修改，部分值可储存到硬盘上的&lt;code&gt;config.cfg&lt;/code&gt;文件&lt;/li&gt;
&lt;li&gt;OGRE引擎：使用INI，像&lt;code&gt;plugins.cfg&lt;/code&gt;记录要启用的插件及路径，&lt;code&gt;resources.cfg&lt;/code&gt;包含游戏资产的路径。通过&lt;code&gt;Ogre::ConfigFile&lt;/code&gt;类可轻易读写全新的配置文件&lt;/li&gt;
&lt;li&gt;顽皮狗的神秘海域引擎：使用以下多种配置机制&lt;ul&gt;
&lt;li&gt;游戏内置菜单选项：每个可配置选项都实现为全局变量，为选项创建菜单项目时，会提供全局变量的地址，之后菜单项目就能直接控制该全局变量的值&lt;/li&gt;
&lt;li&gt;命令行参数：可指定要载入的关卡名称，以及其他常用参数&lt;/li&gt;
&lt;li&gt;Scheme（一种Lisp方言）数据定义：通过脚本定义数据结构，并用自建的数据编译器转换为二进制文件，同时自动生成C/C++的头文件以解释二进制文件的数据。可以在运行期间重编译和重加载二进制文件，以便随时修改数据结构并立即看到效果。这种系统给予程序员巨大的弹性，可以定义复杂的数据结构，如细致的动画树、物理参数、游戏机制等。下面的代码示例，用于为动画定义属性，并导出2个动画&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;;; Scheme代码，定义一个新的数据类型，名为simple-animation
(deftype simple-animation () (
    (name string)
    (speed float: default 1.0)
    (fade-in-seconds float: default 0.25)
    (fade-out-seconds float: default 0.25)
))

;; 定义此数据结构2个实例
(define-export anim-walk
    (new simple-animation
        :name &amp;quot;walk&amp;quot;
        :speed 1.0
    )
)
(define-export anim-jump
    (new simple-animation
        :name &amp;quot;jump&amp;quot;
        :fade-in-seconds 0.1
        :fade-out-seconds 0.1
    )
)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此Scheme代码会产生以下C/C++头文件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// simple-animation.h
// 警告：本文件是Scheme自动生成的，不要手工修改
struct SimpleAnimation {
    const char* m_name;
    float m_speed;
    float m_fadeInSeconds;
    float m_fadeOutSeconds;
};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在游戏编程中，可调用&lt;code&gt;LookupSymbol()&lt;/code&gt;函数读取数据，该函数&lt;strong&gt;以返回类型为模板参数&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;quot;simple-animation.h&amp;quot;

void someFunction() {
    SimpleAnimation* pWalkAnim = LookupSymbol&amp;lt;SimpleAnimation*&amp;gt;(&amp;quot;anim-walk&amp;quot;);
    SimpleAnimation* pJumpAnim = LookupSymbol&amp;lt;SimpleAnimation*&amp;gt;(&amp;quot;anim-jump&amp;quot;);
    // 在此使用这些动画......
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;参考文献：电子工业出版社《游戏引擎架构》第5.3-5.5节&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;游戏编程中需要使用各种各样的集合型数据结构，称为容器或集合。字符串看似是个简单基本的数据类型，但在游戏引擎中会涉及许多设计问题和限制。此外，游戏引擎总是伴随大量可调校的选项，有的通过游戏中的选项菜单给玩家调校，有的则只为游戏开发团队设置，在正式发行时被隐掉或去除。&lt;/p&gt;
&lt;p&gt;本文将接着&lt;a href=&quot;/tech/game/engine/engine-support-system-1/&quot;&gt;上一篇&lt;/a&gt;，从游戏引擎的角度描述容器、字符串和引擎配置等游戏引擎支持系统。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="游戏开发" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
      <category term="游戏引擎" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    
      <category term="游戏引擎" scheme="http://raytaylorlin.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
      <category term="架构" scheme="http://raytaylorlin.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>游戏引擎支持系统（上）</title>
    <link href="http://raytaylorlin.com/tech/game/engine/engine-support-system-1/"/>
    <id>http://raytaylorlin.com/tech/game/engine/engine-support-system-1/</id>
    <published>2016-06-10T14:02:07.000Z</published>
    <updated>2016-06-10T14:12:57.595Z</updated>
    
    <content type="html">&lt;p&gt;每个游戏都需要一些底层支持系统，以管理一些例行却关键的任务，例如启动及终止引擎、存取文件系统、存取各种不同资产类型（网格、纹理、动画、音频等），以及为游戏团队提供调试工具。&lt;/p&gt;
&lt;p&gt;本文（分上下篇）重点讨论多数游戏引擎中都会出现的底层支持系统，为后续探索大型的核心系统做准备。其中上篇将讨论子系统的启动和终止的顺序管理，以及各种动态内存分配器和碎片整理等内存管理问题。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-子系统的启动和终止&quot;&gt;&lt;a href=&quot;#1-子系统的启动和终止&quot; class=&quot;headerlink&quot; title=&quot;1. 子系统的启动和终止&quot;&gt;&lt;/a&gt;1. 子系统的启动和终止&lt;/h1&gt;&lt;p&gt;游戏引擎是复杂软件，由多个互相合作的子系统结合而成。各子系统间的相互依赖关系，隐含地定义了每个子系统所需的启动次序，例如子系统B依赖子系统A，那么先启动A，再启动B，而各子系统的终止顺序则相反。&lt;/p&gt;
&lt;p&gt;多数游戏引擎都是采用C++为编程语言，所以应该考虑C++原生的语法如何供启动及终止子系统所用。通常，每个子系统会被设计为单例（或称为管理器manager）。最有效的简单方法是，每个单例管理器的构造和析构函数不做任何事，而是自定义各自的&lt;code&gt;startUp()&lt;/code&gt;和&lt;code&gt;shutDown()&lt;/code&gt;方法，然后在main函数中调用控制各系统启动和终止的顺序。&lt;/p&gt;
&lt;p&gt;还有更优雅的实现方式，例如让各管理器把自己登记在一个全局的优先队列，之后再按恰当次序逐一启动；或者让每个管理器列举其依赖的管理器，定义一个管理器间的依赖图，再计算最优的启动次序。总之，蛮力法虽然粗暴，但是简单容易实现，非常容易调试和维护，是首选的方法。&lt;/p&gt;
&lt;h1 id=&quot;2-内存管理&quot;&gt;&lt;a href=&quot;#2-内存管理&quot; class=&quot;headerlink&quot; title=&quot;2. 内存管理&quot;&gt;&lt;/a&gt;2. 内存管理&lt;/h1&gt;&lt;p&gt;任何软件的性能，不仅受算法的选择和算法编码的效率所支配，程序如何运用内存也是重要因素。内存对性能的影响有动态内存分配、内存碎片和缓存等方面。&lt;/p&gt;
&lt;h2 id=&quot;2-1-优化动态内存分配&quot;&gt;&lt;a href=&quot;#2-1-优化动态内存分配&quot; class=&quot;headerlink&quot; title=&quot;2.1 优化动态内存分配&quot;&gt;&lt;/a&gt;2.1 优化动态内存分配&lt;/h2&gt;&lt;p&gt;通过malloc()/free()或C++的new/delete运算符动态分配内存通常是非常慢的，原因有两个：堆分配器是通用设施，可以处理任何大小的分配请求，需要大量的管理开销；多数操作系统上分配内存会在用户模式和内核模式来回切换，这些上下文切换可能会耗费很多时间。因此，游戏开发中一个常见的经验法则是：&lt;strong&gt;维持最低限度的堆分配，并且永不在紧凑循环中使用堆分配。&lt;/strong&gt; 当然，任何游戏引擎都无法完全避免动态内存分配，所以会实现若干个定制分配器。定制分配器比原生分配器更高效的原因有两个：从预分配的内存中完成分配请求（顶分配内存来自new），完全避免了上下文切换；对内存的使用模式做出多种假设，会比通用的堆分配器高效得多。&lt;/p&gt;
&lt;h3 id=&quot;2-1-1-基于堆栈的分配器&quot;&gt;&lt;a href=&quot;#2-1-1-基于堆栈的分配器&quot; class=&quot;headerlink&quot; title=&quot;2.1.1 基于堆栈的分配器&quot;&gt;&lt;/a&gt;2.1.1 基于堆栈的分配器&lt;/h3&gt;&lt;p&gt;许多关卡类的游戏，载入关卡时就会为关卡分配内存，关卡载入后，就会很少甚至不会动态分配内存。在玩家完成关卡之际，关卡的数据会被卸下，所有关卡占用的内存也可被释放。这类内存分配非常适合采用堆栈分配器。这种分配器要分配一大块连续内存，通过移动一个指向堆栈顶端的指针来“模拟”内存的分配和释放。释放时按分配的相反次序，不容许释放个别的内存块，而是释放从回滚点（标记）至目前堆栈顶端之间的所有内存。&lt;/p&gt;
&lt;p&gt;双端堆栈分配器（即一个分配器从内存块底端往上分配，另一个从内存块顶端往下分配）可以更有效地运用内存。一种非常优秀的从不会产生内存碎片问题的分配方案：所有内存分配自单个巨大内存块，以双端堆栈分配器管理，底堆栈用来载入及卸下游戏关卡，顶堆栈则用来分配临时内存块，这些临时内存会在每帧中分配及释放。堆栈分配器的实现模型见下图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://raytaylorlin-blog.qiniudn.com/image%2Fengine%2F%E5%A0%86%E6%A0%88%E5%88%86%E9%85%8D%E5%99%A8%E7%9A%84%E5%88%86%E9%85%8D%E6%A8%A1%E5%BC%8F.png&quot; alt=&quot;堆栈分配器的分配模式&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-1-2-池分配器&quot;&gt;&lt;a href=&quot;#2-1-2-池分配器&quot; class=&quot;headerlink&quot; title=&quot;2.1.2 池分配器&quot;&gt;&lt;/a&gt;2.1.2 池分配器&lt;/h3&gt;&lt;p&gt;矩阵、迭代器、链表中的节点、可渲染的网格实例等会分配大量同等尺寸的小块内存。池分配器是此类分配模式的完美选择。其工作方式为：首先预分配一大块内存，大小刚好是分配元素的倍数（例如每元素4字节的4×4矩阵池的大小设为64字节的倍数），池内每个元素会加到一个存放自由元素的链表。池分配器收到分配请求时，就会把自由链表的下一个元素取出，并传回该元素；释放元素之时，只需简单地把元素插回自由链表中。这些分配和释放都是O(1)的操作。&lt;/p&gt;
&lt;h3 id=&quot;2-1-3-含对齐功能的分配器&quot;&gt;&lt;a href=&quot;#2-1-3-含对齐功能的分配器&quot; class=&quot;headerlink&quot; title=&quot;2.1.3 含对齐功能的分配器&quot;&gt;&lt;/a&gt;2.1.3 含对齐功能的分配器&lt;/h3&gt;&lt;p&gt;为了提高内存的吞吐量和效率，所有内存分配器都必须能传回&lt;strong&gt;字节对齐&lt;/strong&gt;的内存块。只要在分配内存时，分配比请求所需多一点的内存，再向上调整地址至适当的对齐，最后传回调整后的地址。大多数情况下，额外分配的字节等于对齐字节。例如，若请求为16字节对齐的内存块，就可以额外分配多16字节，最坏的情况下要把地址往上移动15字节。多出的1字节可以用来存储偏移量，以便于正确释放分配的内存。&lt;/p&gt;
&lt;h3 id=&quot;2-1-4-单帧和双缓冲分配器&quot;&gt;&lt;a href=&quot;#2-1-4-单帧和双缓冲分配器&quot; class=&quot;headerlink&quot; title=&quot;2.1.4 单帧和双缓冲分配器&quot;&gt;&lt;/a&gt;2.1.4 单帧和双缓冲分配器&lt;/h3&gt;&lt;p&gt;几乎所有游戏都会在游戏循环中分配一些临时用数据，这些数据要么可在循环迭代结束时丢弃，要么可在下一迭代结束时丢弃。这种模式适用于以下两种分配模式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;单帧分配器：先预留一块内存，并以简单堆栈分配器管理。在每帧开始时，都把堆栈的顶端指针重置到内存块的底端地址。在该帧中，分配要求会使堆栈向上成长。优点是极其高效，分配了的内存永远不需要手动释放，因为每帧开始时分配器会自动清除所有内存。最大缺点在于，程序员必须有不错的自制能力，并意识到内存块只在目前的帧里有效，&lt;strong&gt;绝不能把指向单帧内存块的指针跨帧使用&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;双缓冲分配器：第i帧分配的内存块用于第(i+1)帧。实现方法就是建立两个相同尺寸的单帧堆栈分配器，并在每帧交替使用（见下方代码）。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;class DoubleBufferedAllocater {
    U32 m_curStack;
    StackAllocator m_stack[2];
public:
    void swapBuffers() {
        m_curStack = (U32)!m_curStack;
    }

    void clearCurrentBuffer() {
        m_stack[m_curStack].clear();
    }

    void *alloc(U32 mBytes) {
        return m_stack[m_curStack].alloc(nBytes)
    }
}

DoubleBufferedAllocator g_doubleBufAllocator;
// 主游戏循环
while (true) {
    // 每帧清除单帧分配器的缓冲区
    g_singleFrameAllocator.clear();
    // 对双缓冲分配器交换现行和无效的缓冲区
    g_doubleBufAllocator.swapBuffers();
    // 清空新的现行缓冲区，保留前帧的缓冲不变
    g_doubleBufAllocator.clearCurrentBuffer();

    // ...

    // 从双缓冲分配器分配内存，不影响前帧的数据，要确保这些内存仅在本帧或次帧中使用
    void* p = g_doubleFrameAllocator.alloc(nBytes);

    // ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;2-2-内存碎片&quot;&gt;&lt;a href=&quot;#2-2-内存碎片&quot; class=&quot;headerlink&quot; title=&quot;2.2 内存碎片&quot;&gt;&lt;/a&gt;2.2 内存碎片&lt;/h2&gt;&lt;p&gt;当经过非常多次随机次序的分配及释放不同尺寸的内存块，堆中就会出现许多内存“孔洞”，这就是内存碎片状态。由于分配的内存必须是连续的，所以内存碎片会导致分配请求经常失败。在支持虚拟内存的操作系统上，内存碎片并非大问题。对当代的游戏机而言，虽然技术上能支持虚拟内存，但由于其导致的开销，多数游戏引擎不会使用虚拟内存。&lt;/p&gt;
&lt;h3 id=&quot;2-2-1-用堆钱和池分配器避免内存碎片&quot;&gt;&lt;a href=&quot;#2-2-1-用堆钱和池分配器避免内存碎片&quot; class=&quot;headerlink&quot; title=&quot;2.2.1 用堆钱和池分配器避免内存碎片&quot;&gt;&lt;/a&gt;2.2.1 用堆钱和池分配器避免内存碎片&lt;/h3&gt;&lt;p&gt;使用堆栈分配器分配到的内存块总是连续的，可以完全避免内存碎片。池分配器虽然会产生碎片，但因为每个内存块都一样大，所以不会因缺乏足够大的连续内存块而造成分配失败&lt;/p&gt;
&lt;h3 id=&quot;2-2-2-碎片整理及重定位&quot;&gt;&lt;a href=&quot;#2-2-2-碎片整理及重定位&quot; class=&quot;headerlink&quot; title=&quot;2.2.2 碎片整理及重定位&quot;&gt;&lt;/a&gt;2.2.2 碎片整理及重定位&lt;/h3&gt;&lt;p&gt;若要以随机次序分配及释放不同大小的对象，以上两种也不适用。这时可以对堆定期进行碎片整理，即把每个“洞”搬移至高位，最后所有己分配内存块都会连续地凑在堆内存空间的底端。移动内存是简单的事，但背后的副作用是&lt;strong&gt;移动了己分配的内存块，若有指针指向这些内存块，这些指针便会失效。&lt;/strong&gt;其中一个解决方案就是把指向这些内存块的指针逐一更新，使移动内存块后这些指针能指到新的地址，这个过程称为指针重定位。&lt;/p&gt;
&lt;p&gt;由于C/C++不支持搜寻所有指向某地址范围的指针，若要在游戏引擎中支持碎片整理功能，程序员必须小心手动维护所有指针，另一个选择是采用智能指针或句柄（使用索引指向句柄表内的元素，每个元素储存指针，句柄的值不变，移动内存块时要修改指针）来替代。重定位的另一难题是，使用一些第三方库，该库本身不使用智能指针或句柄，那么指向库内数据结构的指针就不能被重定位。最好的办法是，让这些库在另一个特别缓冲区里分配内存，此缓冲区位于可重定位内存范围以外。或者干脆容许一些内存块不能被重定位，若这种内存块数量少且体积小，重定位系统仍可运行得相当好。&lt;/p&gt;
&lt;h3 id=&quot;2-2-3-分摊碎片整理整本&quot;&gt;&lt;a href=&quot;#2-2-3-分摊碎片整理整本&quot; class=&quot;headerlink&quot; title=&quot;2.2.3 分摊碎片整理整本&quot;&gt;&lt;/a&gt;2.2.3 分摊碎片整理整本&lt;/h3&gt;&lt;p&gt;碎片整理要复制内存块，其过程可能很慢。然而可以把碎片整理分摊至多个帧，例如容许容许每帧进行多达N次内存块移动（N是小数目，如8或16），只要分配及释放的次数低于碎片整理的移动次数，那么堆就会经常保持接近完全整理的状态。此方法只对细小的内存块有效，使移动内存块的时间短于每帧配给的重定位时间。若要重定位非常大的内存块，有时候可以把它分拆为两个或更多的小块，而每个小块可以独立被重定位。&lt;/p&gt;
&lt;h2 id=&quot;2-3-缓存一致性&quot;&gt;&lt;a href=&quot;#2-3-缓存一致性&quot; class=&quot;headerlink&quot; title=&quot;2.3 缓存一致性&quot;&gt;&lt;/a&gt;2.3 缓存一致性&lt;/h2&gt;&lt;p&gt;为了降低读写主内存的平均时间，现代处理器会采用高速缓存。每当出现缓存命中失败，程序便要被逼暂停，等待缓存线自主内存更新后才能继续运行。因为数据始终要在缓存和主内存之间移动，所以无法完全避免缓存命中失败。高效计算的诀窍在于，以最优的方式安排内存中的数据及为算法编码，尽量减少缓存命中失败的次数。&lt;/p&gt;
&lt;h3 id=&quot;2-3-1-硬件层面上的缓存&quot;&gt;&lt;a href=&quot;#2-3-1-硬件层面上的缓存&quot; class=&quot;headerlink&quot; title=&quot;2.3.1 硬件层面上的缓存&quot;&gt;&lt;/a&gt;2.3.1 硬件层面上的缓存&lt;/h3&gt;&lt;p&gt;现代的CPU架构上出现了一级L1和二级L2高速缓存，其存取方向为“CPU←→L1缓存←→L2缓存←→主内存”，存取速度依次减慢，L2缓存命中失败通常比L1的成本高。有一种特别差的缓存命中失败称为load-hit-store，此问题在PowerPC架构上（如Xbox360和PS3）极为普遍。其出现过程是，CPU往某内存地址写入数据，随即又读取该地址，而此时要等待L1缓存写回数据至主内存，造成CPU的流水线停顿。具体可以参见&lt;a href=&quot;http://assemblyrequired.crashworks.org/load-hit-stores-and-the-__restrict-keyword/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这篇文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;此外还需要意识到大多数处理器会在物理上独立分开指令缓存和数据缓存，前者会预载即将执行的机器码，后者则用来加速内存读写数据。因此程序变慢，要考虑是指令还是数据缓存命中失败。&lt;/p&gt;
&lt;h3 id=&quot;2-3-2-软件层面上避免缓冲命中失败&quot;&gt;&lt;a href=&quot;#2-3-2-软件层面上避免缓冲命中失败&quot; class=&quot;headerlink&quot; title=&quot;2.3.2 软件层面上避免缓冲命中失败&quot;&gt;&lt;/a&gt;2.3.2 软件层面上避免缓冲命中失败&lt;/h3&gt;&lt;p&gt;避免&lt;strong&gt;数据&lt;/strong&gt;缓存命中失败的最佳办法就是，&lt;strong&gt;把数据编排进连续的内存块中，尺寸越小越好，并且要顺序访问这些数据&lt;/strong&gt;。当数据是连续的（即不会经常在内存中“跳来跳去”），那么单次命中失败便会把尽可能最多的相关数据载入单个缓存线。&lt;/p&gt;
&lt;p&gt;要避免&lt;strong&gt;指令&lt;/strong&gt;缓存命中失败，需要了解C/C++链接器的一些简单规则，例如编译器和链接器按函数在cpp文件中的出现次序排列内存布局；单个函数的机器码几乎总是置于连续的内存；位于一个翻译单元内的函数总是置于连续内存中。据此可以使用以下经验法则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;高效能代码的体积越小越好，体积以机器码指令数目为单位&lt;/li&gt;
&lt;li&gt;在性能关键的代码段中，&lt;strong&gt;避免调用函数&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;若要调用某函数，就把该函数置于&lt;strong&gt;最接近&lt;/strong&gt;调用函数的地方，最好是紧接调用函数的前后，而不要把该函数置于另一翻译单元（cpp文件）&lt;/li&gt;
&lt;li&gt;谨慎使用内联函数。内联小型函数能增进效能，然而过多的内联会增大代码体积，使性能关键代码再不能完全装进缓存。若循环内的代码不能完全装进缓存，应重新考虑算法及其代码实现&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考文献：电子工业出版社《游戏引擎架构》第5.1、5.2节&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;每个游戏都需要一些底层支持系统，以管理一些例行却关键的任务，例如启动及终止引擎、存取文件系统、存取各种不同资产类型（网格、纹理、动画、音频等），以及为游戏团队提供调试工具。&lt;/p&gt;
&lt;p&gt;本文（分上下篇）重点讨论多数游戏引擎中都会出现的底层支持系统，为后续探索大型的核心系统做准备。其中上篇将讨论子系统的启动和终止的顺序管理，以及各种动态内存分配器和碎片整理等内存管理问题。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="游戏开发" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
      <category term="游戏引擎" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    
      <category term="游戏引擎" scheme="http://raytaylorlin.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
      <category term="架构" scheme="http://raytaylorlin.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>游戏引擎架构总览</title>
    <link href="http://raytaylorlin.com/tech/game/engine/game-engine-architecture-preview/"/>
    <id>http://raytaylorlin.com/tech/game/engine/game-engine-architecture-preview/</id>
    <published>2016-05-27T09:07:53.000Z</published>
    <updated>2016-05-27T09:20:51.758Z</updated>
    
    <content type="html">&lt;p&gt;游戏引擎通常由运行时组件和工具套件两部分构成。本文先探讨运行时部分的架构，给出了一个不包含工具的极其庞大的总览图（如果时间有限仅看此图即可），并对图中每一组件进行描述，最后再阐述工具方面的内容。如同所有软件系统，游戏引擎也是以软件层构建的，而且通常上层依赖下层，下层不依赖上层。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-运行时引擎架构&quot;&gt;&lt;a href=&quot;#1-运行时引擎架构&quot; class=&quot;headerlink&quot; title=&quot;1. 运行时引擎架构&quot;&gt;&lt;/a&gt;1. 运行时引擎架构&lt;/h1&gt;&lt;p&gt;下图为游戏运行时引擎架构的总览图，本图相对原书标上了序号，以方便下面各节阐述时对应其位置，并省略了一些细节的组成部分。&lt;strong&gt;图片较大，建议在新标签页中打开图片查看。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://raytaylorlin-blog.qiniudn.com/image%2Fengine%2F%E6%B8%B8%E6%88%8F%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84.png&quot; alt=&quot;游戏运行时引擎架构&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-1-硬件与操作系统&quot;&gt;&lt;a href=&quot;#1-1-硬件与操作系统&quot; class=&quot;headerlink&quot; title=&quot;1.1 硬件与操作系统&quot;&gt;&lt;/a&gt;1.1 硬件与操作系统&lt;/h2&gt;&lt;p&gt;图中的A1为目标硬件层，代表用来执行游戏的计算机系统或游戏主机。典型平台包括基于微软Windows或Linux的PC、苹果的iPhone及Machintosh、微软的Xbox360、索尼的PS4/PSP、任天堂的NDS/Wii等等。&lt;/p&gt;
&lt;p&gt;图中的A2是设备驱动程序，是由操作系统或硬件厂商提供的最低阶软件组件。驱动程序负责管理硬件资源，也隔离了操作系统及上层引擎，使上层的软件无须理解不同硬件版本的通信细节差异。&lt;/p&gt;
&lt;p&gt;图中的A3是操作系统。在PC上操作系统是一直运行的，PC游戏不能假设拥有硬件的所有控制权；而在游戏主机上，操作系统通常只是个轻量级的库，链接到游戏的执行档里。不过像Xbox 360和PS3这些新主机中，操作系统也会中断游戏的执行，接管某些系统资源以显示在线信息。&lt;/p&gt;
&lt;h2 id=&quot;1-2-第三方软件开发包和中间件&quot;&gt;&lt;a href=&quot;#1-2-第三方软件开发包和中间件&quot; class=&quot;headerlink&quot; title=&quot;1.2 第三方软件开发包和中间件&quot;&gt;&lt;/a&gt;1.2 第三方软件开发包和中间件&lt;/h2&gt;&lt;p&gt;图中的B表明大多数游戏引擎会借用第三方SDK及中间件（middleware），SDK提供基于函数或基于类的API。下面是一些常见的例子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据结构及算法：如STL、STLport、Boost、Loki。因为PC上有虚拟内存系统，所以可以无碍使用STL，而游戏主机上，只有有限的（甚至没有）虚拟内存功能，而且缓存命中失败的代价极高，所以最好编写自定义的数据结构&lt;/li&gt;
&lt;li&gt;图形：如DirextX、OpenGL、libgcm、Edge等&lt;/li&gt;
&lt;li&gt;碰撞和物理：如Havok、PhysX、ODE（Open Dynamics Engine）等&lt;/li&gt;
&lt;li&gt;角色动画：如Granny、Havok Animation、Edge等&lt;/li&gt;
&lt;li&gt;人工智能：如Kynapse，提供低阶的AI构件，例如路径搜寻、静态和动态物体回避、空间内的脆弱点辨认，以及相当好的AI和动画间接口&lt;/li&gt;
&lt;li&gt;生物力学角色模型：如Endorphin、Euphoria等，利用了真实人类运动的高阶生物力学模型，去产生角色动作&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-3-平台独立层&quot;&gt;&lt;a href=&quot;#1-3-平台独立层&quot; class=&quot;headerlink&quot; title=&quot;1.3 平台独立层&quot;&gt;&lt;/a&gt;1.3 平台独立层&lt;/h2&gt;&lt;p&gt;图中的C为平台独立层。大部分游戏引擎需要运行于不同的平台上，该层包装了常用的标准C语言库、操作系统调用及其他基础API，确保包装了的接口在所有硬件平台上均为一致。&lt;/p&gt;
&lt;h2 id=&quot;1-4-核心系统&quot;&gt;&lt;a href=&quot;#1-4-核心系统&quot; class=&quot;headerlink&quot; title=&quot;1.4 核心系统&quot;&gt;&lt;/a&gt;1.4 核心系统&lt;/h2&gt;&lt;p&gt;游戏引擎以及其他大规模复杂C++应用软件，都需要一些有用的实用软件（utility)，统称为“核心系统”，即图中的D。以下是一些核心系统层的常见功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内存管理：几乎每个游戏引擎都有若干个自定义内存分配系统，以保证高速的内存分配及释放，并控制内存碎片所造成的负面影响&lt;/li&gt;
&lt;li&gt;数学库：游戏本质上就是高度数学密集的，所以每个游戏引擎都有若干个数学库，提供矢量、矩阵、四元数旋转、三角学、数值积分、解方程组，以及其他游戏程序员需要的功能&lt;/li&gt;
&lt;li&gt;自定义数据结构及算法：除非引擎设计者想完全依靠第三方软件包，否则引擎通常要提供一组工具去管理基础数据结构和算法，以减少或完全消去动态内存分配，并保证在目标平台上的运行效率为最优&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-5-资源管理&quot;&gt;&lt;a href=&quot;#1-5-资源管理&quot; class=&quot;headerlink&quot; title=&quot;1.5 资源管理&quot;&gt;&lt;/a&gt;1.5 资源管理&lt;/h2&gt;&lt;p&gt;图中的E为资源管理器，提供一组统一的接口去访问任何类型的游戏资产及其他引擎输入数据。有些引擎使用高度集中及一致的方式（例如虚幻的包package、OGRE的ResourceManager类）。其他引擎使用专案（ad hoc）方法，比如让程序员直接读取磁盘的或压缩的文件（如雷神之锤引擎使用的PAK文件）。&lt;/p&gt;
&lt;h2 id=&quot;1-6-渲染引擎&quot;&gt;&lt;a href=&quot;#1-6-渲染引擎&quot; class=&quot;headerlink&quot; title=&quot;1.6 渲染引擎&quot;&gt;&lt;/a&gt;1.6 渲染引擎&lt;/h2&gt;&lt;p&gt;任何游戏引擎中，渲染引擎是最大及最复杂的组件之一。渲染器有很多不同的架构方式，通常采用分层架构。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;低阶渲染器（图中F1）：包含引擎中全部原始的渲染功能，着重于高速渲染丰富的几何图元集合&lt;ul&gt;
&lt;li&gt;图形设备接口：使用图形SDK（如DirectX及OpenGL），都需要编写不少代码去枚举图形设备，初始化设备，建立渲染表面等，这些工作通常由图形设备接口组件负责&lt;/li&gt;
&lt;li&gt;其他渲染器组件：目的是要收集须提交的几何图元，包括网格、线表、点表、例子、地形块、字符串等等。低阶渲染器还提供视区（viewport）抽象、材质系统及动态光照系统&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;场景图/剔除优化（图中F2）：该层基于某些可视性判别算法去限制低阶渲染器提交的图元数量。非常小的游戏世界可能只需要简单的平截头体剔除算法，比较大的游戏世界则可能需要较高阶的空间细分数据结构，令渲染更有效率&lt;/li&gt;
&lt;li&gt;视觉效果（图中F3）：支持广泛的视觉效果，例如粒子系统（烟、火、水花等）、贴花系统（弹孔、脚印等），还有一些全屏幕后期处理，例如高动态范围光照（HDR）、敷霜效果、全屏抗锯齿（FSAA）、颜色校正等等&lt;/li&gt;
&lt;li&gt;前端（图中F4）：该层主要用于显示2D图形，如平视显示器（HUD）、GUI界面等等，通常会用附有纹理的四边形结合正射投影来渲染，或者用完全三维的四边形公告板（billboard）渲染&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-7-剖析与调试工具&quot;&gt;&lt;a href=&quot;#1-7-剖析与调试工具&quot; class=&quot;headerlink&quot; title=&quot;1.7 剖析与调试工具&quot;&gt;&lt;/a&gt;1.7 剖析与调试工具&lt;/h2&gt;&lt;p&gt;图中的G用于剖析调优性能，分析内存。还包含了游戏内置调试功能，包括调试用绘图、内置菜单、主控台、录制回放游戏过程等。市场上有很多优良的通用软件剖析工具，如VTune、Quantify、Purify等等，但是多数游戏也会加入自制的剖析与调试工具以应对特殊需求。&lt;/p&gt;
&lt;h2 id=&quot;1-8-碰撞和物理&quot;&gt;&lt;a href=&quot;#1-8-碰撞和物理&quot; class=&quot;headerlink&quot; title=&quot;1.8 碰撞和物理&quot;&gt;&lt;/a&gt;1.8 碰撞和物理&lt;/h2&gt;&lt;p&gt;图中的H为碰撞与物理组件。游戏中如果没有碰撞检测，物体会互相穿透，并且无法在虚拟世界里合理地互动。碰撞和物理系统一般是紧密联系的，因为当碰撞发生时，碰撞几乎总是由物理积分及约束满足逻辑来解决。一些游戏还包含真实或半真实的刚体动力学模拟。时至今日，游戏引擎通常使用第三方的物理SDK，如Havok、PhysX和ODE。&lt;/p&gt;
&lt;h2 id=&quot;1-9-动画&quot;&gt;&lt;a href=&quot;#1-9-动画&quot; class=&quot;headerlink&quot; title=&quot;1.9 动画&quot;&gt;&lt;/a&gt;1.9 动画&lt;/h2&gt;&lt;p&gt;图中的I为动画系统，游戏常会用到精灵/纹理动画、刚体层次结构动画、骨骼动画、每顶点动画、变形目标动画5种基本动画。现今游戏&lt;br&gt;中，骨骼动画是最盛行的动画方式。此外，骨骼网格渲染组件是连接渲染器和动画系统的桥梁，这些组件合作渲染的过程称为蒙皮（skinning）。&lt;/p&gt;
&lt;p&gt;当使用布娃娃系统时，动画和物理系统便产生紧密耦合，这是因为布娃娃是无力的（经常是死了的）角色，其运动完全由物理系统模拟。物理系统把布娃娃当作受约束的刚体系统，用模拟来决定身体每部分的位置及方向。&lt;/p&gt;
&lt;h2 id=&quot;1-10-人体学接口设备&quot;&gt;&lt;a href=&quot;#1-10-人体学接口设备&quot; class=&quot;headerlink&quot; title=&quot;1.10 人体学接口设备&quot;&gt;&lt;/a&gt;1.10 人体学接口设备&lt;/h2&gt;&lt;p&gt;图中的J用于处理玩家输入，包括键盘鼠标、游戏手柄及其他专用游戏控制器（如方向盘、跳舞毯、Wii遥控器等）。除了输入功能，一些设备也提供输出，如游戏手柄的震动、Wii遥控器的音频输出等。&lt;/p&gt;
&lt;p&gt;在架构HID引擎时，通常让硬件的低阶细节与高阶游戏操作脱钩。HID引擎从硬件取得原始数据，为控制器的每个摇杆设置环绕中心点的死&lt;br&gt;区，去除按钮抖动，检测按下和释放按钮事件，演绎加速计的输入并使该输入平滑。HID引擎也可能包含一个系统，负责检测弦（chord）（即数个按钮一起按下）、序列（即接钮在时限内顺序按下）、手势（即按钮、摇杆、加速计等输入的序列）。&lt;/p&gt;
&lt;h2 id=&quot;1-11-音频&quot;&gt;&lt;a href=&quot;#1-11-音频&quot; class=&quot;headerlink&quot; title=&quot;1.11 音频&quot;&gt;&lt;/a&gt;1.11 音频&lt;/h2&gt;&lt;p&gt;图中的K为音频引擎。一些游戏团队会为这些引擎加入自定义功能，或用内部方案替换，例如微软为DirectX平台提供一个名为XACT的优秀的音频工具包，艺电也开发了内部的音频引擎SoundR!OT。然而，即使游戏团队用既有的音频引擎，开发每个游戏时仍然需要大量的定制软件开发、整合工作及注意细节，才可以制作出有高质量音频的最终产品。&lt;/p&gt;
&lt;h2 id=&quot;1-12-在线多人-网络&quot;&gt;&lt;a href=&quot;#1-12-在线多人-网络&quot; class=&quot;headerlink&quot; title=&quot;1.12 在线多人/网络&quot;&gt;&lt;/a&gt;1.12 在线多人/网络&lt;/h2&gt;&lt;p&gt;图中的L为在线多人/网络组件。多人游戏有单屏多人、切割平多人、网络多人、大型多人在线等多种基本形式。支持多人游戏，会深切影响到游戏世界对象模型、人体学接口设备系统、玩家控制系统、动画系统等多个组件的设计。把一个现有的担任引擎改装成多人引擎的难度是非常大的，但如果反过来则比较简单——许多游戏引擎把单人游戏模式当做是一个玩家参与的多人游戏。&lt;/p&gt;
&lt;h2 id=&quot;1-13-游戏性基础系统&quot;&gt;&lt;a href=&quot;#1-13-游戏性基础系统&quot; class=&quot;headerlink&quot; title=&quot;1.13 游戏性基础系统&quot;&gt;&lt;/a&gt;1.13 游戏性基础系统&lt;/h2&gt;&lt;p&gt;游戏性（gameplay）是指：游戏内进行的活动、支配游戏虚拟世界的规则、玩家角色的能力（也称为玩家机制）、其他角色和对象的能力、玩家的长短期目标。游戏性编程除了用引擎的原生语言，通常还会使用高阶的脚本语言，为了连接低阶的引擎子系统和游戏性代码，多数游戏引擎会引入一个软件层，即图中的M。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;游戏世界和游戏对象模型：游戏世界含动态与静态的元素，而典型的游戏对象有静态背景几何物体（如建筑、地形）、动态刚体（如石头、椅子）、玩家角色、NPC、武器、抛射物、载具、光源、摄像机&lt;/li&gt;
&lt;li&gt;事件系统：事件驱动架构常用于游戏对象间的通信&lt;/li&gt;
&lt;li&gt;脚本系统：使用脚本语言来编写游戏独有的游戏性规则和内容，可以快速开发，避免重新编译链接&lt;/li&gt;
&lt;li&gt;人工智能基础：像Kynapse这种商用AI引擎，抽象了大多数AI系统共有的模式，在这个基础层上可以很容易地开发个别游戏的逻辑。其功能包括用路径节点和漫游体积组成网络定义AI角色可行走的地区和路径，在漫游地区边界周围的简化碰撞信息，A*路径搜寻，联系碰撞系统及世界模型进行视线追踪及其他感知，AI决策层架构等等&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-14-个别游戏专用子系统&quot;&gt;&lt;a href=&quot;#1-14-个别游戏专用子系统&quot; class=&quot;headerlink&quot; title=&quot;1.14 个别游戏专用子系统&quot;&gt;&lt;/a&gt;1.14 个别游戏专用子系统&lt;/h2&gt;&lt;p&gt;如图中的N，每个游戏都有若干自身特有的游戏性系统。如果可以清楚地分开引擎和游戏，这条分界线会位于特定游戏专用子系统和游戏性基础软件层之间。实际上，这条分界线永远不会是完美的。一些游戏的特定知识，总是会向下渗透到游戏基础软件层中，更有甚者会延伸至引擎核心。&lt;/p&gt;
&lt;h1 id=&quot;2-工具套件&quot;&gt;&lt;a href=&quot;#2-工具套件&quot; class=&quot;headerlink&quot; title=&quot;2. 工具套件&quot;&gt;&lt;/a&gt;2. 工具套件&lt;/h1&gt;&lt;h2 id=&quot;2-1-数字内容创作工具&quot;&gt;&lt;a href=&quot;#2-1-数字内容创作工具&quot; class=&quot;headerlink&quot; title=&quot;2.1 数字内容创作工具&quot;&gt;&lt;/a&gt;2.1 数字内容创作工具&lt;/h2&gt;&lt;p&gt;游戏本质上是多媒体应用。游戏引擎的输入数据形式广泛，例如三维网格数据、纹理位图、动画数据、音频文件等。所有源数据皆由美术或音效师等专业人员使用数字内容创作（Digital Content Creation，DCC）应用软件制作，如Maya、3ds Max、Photoshop、SoundForge等等。有些游戏引擎提供专门的设计游戏世界的编辑器，而有的团队会在现有软件像3ds Max的基础上开发插件去设计场景，甚至用简单的位图编辑器去制作地形高度图。总之，游戏团队想要及时开发高完成度的产品，工具必须&lt;strong&gt;相对易用&lt;/strong&gt;，并且&lt;strong&gt;绝对可靠&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;2-2-资产（asset）调节管道&quot;&gt;&lt;a href=&quot;#2-2-资产（asset）调节管道&quot; class=&quot;headerlink&quot; title=&quot;2.2 资产（asset）调节管道&quot;&gt;&lt;/a&gt;2.2 资产（asset）调节管道&lt;/h2&gt;&lt;p&gt;DCC所生成的数据格式，很少有直接用于游戏中的，原因有两点：生成的数据格式通常比游戏所需的复杂得多，游戏引擎只需其中一小部分信息；直接读取速度过慢，而且有些格式是不公开的专有格式。因此，DCC软件制作的数据，通常要导出为容易读取的标准格式或自定义格式，有时还需要针对不同平台进行再处理，以便在游戏中使用。从DCC到游戏引擎的管道，就是所谓的资产调节管道。&lt;/p&gt;
&lt;h2 id=&quot;2-3-常见的游戏资产数据&quot;&gt;&lt;a href=&quot;#2-3-常见的游戏资产数据&quot; class=&quot;headerlink&quot; title=&quot;2.3 常见的游戏资产数据&quot;&gt;&lt;/a&gt;2.3 常见的游戏资产数据&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;几何图形数据&lt;ul&gt;
&lt;li&gt;笔刷集合图形：由凸包集合定义，每个凸包则由多个平面定义。其优点是制作迅速简单，便于设计师建立粗略的原型，也可用作碰撞体积；缺点是分辨率低难以制作复杂图形，不能支持有关节的物体或运动角色&lt;/li&gt;
&lt;li&gt;三维模型/网格：由三角形和顶点组成，每个网格使用若干个材质。网格通常在三维建模软件里制作，并且需要专用的导出器来导出游戏引擎可读的格式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;骨骼动画数据：骨骼网格是一种为关节动画而绑定到骨骼层次结构之上的特殊网格，游戏引擎需要网格本身、骨骼层次结构和若干动画片段3种数据来渲染骨骼网络&lt;/li&gt;
&lt;li&gt;音频数据：由专业的音频制作工具导出，有不同格式和采样率。音频文件通常组织成音频库，以方便管理，载入及串流。&lt;/li&gt;
&lt;li&gt;粒子系统数据：由视觉特效设计师使用第三方工具（如Houdini）或引擎自带的粒子效果编辑工具制作&lt;/li&gt;
&lt;li&gt;游戏世界数据：不少商用游戏引擎会提供优良的世界编辑器，用于编辑游戏世界&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考文献：电子工业出版社《游戏引擎架构》第1.6、1.7节&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;游戏引擎通常由运行时组件和工具套件两部分构成。本文先探讨运行时部分的架构，给出了一个不包含工具的极其庞大的总览图（如果时间有限仅看此图即可），并对图中每一组件进行描述，最后再阐述工具方面的内容。如同所有软件系统，游戏引擎也是以软件层构建的，而且通常上层依赖下层，下层不依赖上层。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="游戏开发" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
      <category term="游戏引擎" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    
      <category term="游戏引擎" scheme="http://raytaylorlin.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
      <category term="架构" scheme="http://raytaylorlin.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>软件构建（十五）——尾声</title>
    <link href="http://raytaylorlin.com/tech/complex/software/software-construction-15/"/>
    <id>http://raytaylorlin.com/tech/complex/software/software-construction-15/</id>
    <published>2016-05-14T14:21:15.000Z</published>
    <updated>2016-05-19T02:30:35.465Z</updated>
    
    <content type="html">&lt;p&gt;本文是《代码大全》学习笔记系列的最后一篇。书中最后几章是一些杂项主题，本文将简要记录这几个主题的内容，包括个人性格对编程的影响，软件开发艺术的有关问题，以及关于软件工程的推荐书单。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-个人性格&quot;&gt;&lt;a href=&quot;#1-个人性格&quot; class=&quot;headerlink&quot; title=&quot;1. 个人性格&quot;&gt;&lt;/a&gt;1. 个人性格&lt;/h1&gt;&lt;p&gt;编程过程非常耗用脑力，这种特性使得个人性格显得很重要。而编程工作本质上是项无法监督的工作，因为没人真正清楚你正在做什么。老板也无法强迫你成为好的程序员，很多时候他甚至无法判断你是否合格，一切都只能靠自己。你无法提升自己的聪明程度，但性格在一定程度上能够改进。事实证明，个人性格对于造就出程序员高手更具有决定性意义。&lt;/p&gt;
&lt;h2 id=&quot;1-1-个人性格对编程的影响&quot;&gt;&lt;a href=&quot;#1-1-个人性格对编程的影响&quot; class=&quot;headerlink&quot; title=&quot;1.1 个人性格对编程的影响&quot;&gt;&lt;/a&gt;1.1 个人性格对编程的影响&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;聪明和谦虚：高智商与优秀程序员之间并无太密切的联系。实际上许多好的编程做法都是为了减轻脑力负担，例如将系统分解是为了使之易于理解，进行审查、评审和测试是为了减少人为失误，通过各种各样的规范是为了将思路从相对繁琐的编程事务中解放出来。精通编程的人是那些了解自己头脑有多大局限性的人，都很谦虚。&lt;/li&gt;
&lt;li&gt;求知欲：技术环境的特定特征每5到10年就变化一番，如果没有足够的求知欲来跟上这些变化，就会面临落伍的威胁，下面是一些培养求知欲的方法&lt;ul&gt;
&lt;li&gt;在开发过程中建立自我意识&lt;/li&gt;
&lt;li&gt;不断用小程序来试验技术点&lt;/li&gt;
&lt;li&gt;阅读解决问题的有关方法&lt;/li&gt;
&lt;li&gt;在行动之前做分析和计划&lt;/li&gt;
&lt;li&gt;学习成功项目的开发经验，阅读高手的代码&lt;/li&gt;
&lt;li&gt;认真阅读文档和其他书本期刊&lt;/li&gt;
&lt;li&gt;同专业人士交往&lt;/li&gt;
&lt;li&gt;向专业开发看齐：专业开发可分为这样四个等级：入门级（会使用某语言的基本功能和特性），中级（已度过入门期，能使用多种 语言，并得心应手使用至少一种语言），熟练级（对语言或环境有着专业技能，通常是公司的核心开发，很多程序员不能超越该层次），技术带头人级（具有熟练级的专业技能，也明白写代码是给人看而非给机器看）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;诚实：通常表现为：不是高手时不假装是高手；乐于承认错误；力图理解编译器的警告，而非弃之不理；透彻理解自己的程序，而不要只是编译看看能否运行；提供实际的状况报告；提供现实的进度方案，在上司面前坚持自己的意见&lt;/li&gt;
&lt;li&gt;交流与合作：真正优秀的程序员知道怎样同别人融洽地工作和娱乐，并且会把提高代码可读性和修改你代码的人放在心上&lt;/li&gt;
&lt;li&gt;创造力和纪律：不要把各种标准和规范的纪律看成是对创造力的约束，相反，许多有很强创造力的人都极其遵守纪律和规范&lt;/li&gt;
&lt;li&gt;偷懒：通常表现为拖延不喜欢的任务（没有任何益处），迅速做完不喜欢的任务以摆脱之（尽管是偷懒，但毕竟用最少时间完成了任务），&lt;strong&gt;编写某个工具来完成不喜欢的任务以便再也不用做这样的事情&lt;/strong&gt;（一劳永逸的懒，无疑是最具产值的偷懒形式）&lt;/li&gt;
&lt;li&gt;习惯：优秀的程序员早就养成了编程各方面的良好习惯，而不是最近才培养的。初涉某事时，就应端正态度来学，干了一段时间后，“习惯的力量”就开始起作用。如果没养成最有效的习惯，或者想改掉坏习惯，应该用良好的新习惯去取代，而不是强行杜绝掉坏习惯&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-2-不如你想象中那样起作用的性格因素&quot;&gt;&lt;a href=&quot;#1-2-不如你想象中那样起作用的性格因素&quot; class=&quot;headerlink&quot; title=&quot;1.2 不如你想象中那样起作用的性格因素&quot;&gt;&lt;/a&gt;1.2 不如你想象中那样起作用的性格因素&lt;/h2&gt;&lt;p&gt;注意以下列举的性格都是&lt;strong&gt;反面因素&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;坚持：多数时候软件开发中的坚持其实就是没有好处的“固执”，当在某段新代码上卡壳时，不妨另辟蹊径，尝试重新设计类，或者绕过去，以后回头再试。花好几个小时干掉某一错误确实会有满足感，但实际上早点放弃固有的思路，换个角度可能可以节省更多时间。&lt;/li&gt;
&lt;li&gt;经验：由于软件技术更新换代太快，所谓的“经验”很快就会落伍，程序员要持续学些，保持与时俱进。&lt;/li&gt;
&lt;li&gt;编程狂人：彻夜编程让你感觉像是世上最好的程序员，却要花几个星期去纠正你在短暂辉煌时埋下的失误。可以热爱编程，但热情不能代替熟练的能力，请想明白什么更重要。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;2-软件开发艺术的有关问题&quot;&gt;&lt;a href=&quot;#2-软件开发艺术的有关问题&quot; class=&quot;headerlink&quot; title=&quot;2. 软件开发艺术的有关问题&quot;&gt;&lt;/a&gt;2. 软件开发艺术的有关问题&lt;/h1&gt;&lt;p&gt;这一章相当于对全书介绍的各种细节背后所折射出的哲学思想做出一个总结。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;克服复杂性：《代码大全》绝大部分的篇幅都用于阐述如何划分系统模块，抽象类和接口，遵循什么样的编程规范等等，归根结底是为了降低软件的复杂性。&lt;/li&gt;
&lt;li&gt;精选开发过程：对于小的项目，程序员的个人才能对软件质量影响最大，对于多人项目，组织性的重要程度超过了个人技能。关于开发过程的重要性，一个明显的例子是看看在需求还未确定就开始设计和编码的后果。其他有用的开发过程，如增量开发，先设计后编码，先粗调后优化，伪代码编码并不断添加注释等等，均在之前的文章提到过，不再赘述。&lt;/li&gt;
&lt;li&gt;首先为人写程序，其次才是为机器：可读的代码写起来并不比含糊的代码多花时间，得到的好处是巨大的。自己维护，后期重构，复审代码，别人修改程序，统统都要读到代码，因此一次性编写可读性强的代码，是非常经济划算的。即便是自写自用的私有代码，也应该认真对待，因为这是一种优秀的习惯（习惯在上述个人性格中提到过）。&lt;/li&gt;
&lt;li&gt;深入一门语言去编程，不浮于表面：要先考虑要干什么，然后采用手头的工具去实现目标。如果你所用的语言不支持某种你想要的特性，可以尝试用一些变通的方法以最大限度地遵循编程规范，因为规范能帮助你理清环境中的危险特性。&lt;/li&gt;
&lt;li&gt;借助规范集中注意力：规范能够节省程序员回答同样问题的麻烦，能精确地传达重要信息，免除各种编码的危险做法，还能弥补语言的某些不足之处&lt;/li&gt;
&lt;li&gt;基于问题域编程：顶层的代码要说明想解决的问题，而不要充斥各种与文件、数据结构、数据类型有关的操作细节。设计程序时，应考虑下图这样的抽象层次&lt;ul&gt;
&lt;li&gt;&lt;img src=&quot;http://raytaylorlin-blog.qiniudn.com/image%2Fsoftware%2F%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%8A%BD%E8%B1%A1%E5%B1%82%E6%AC%A1.png&quot; alt=&quot;程序的抽象层次&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;留心警告信号：当你或其他人说“这段代码暗藏玄机”时，或者类中含有比平均数目更多的错误，或者发现子程序中有许多判断点、嵌套，或者发现代码有重复，或者发现代码不容易写注释和命名变量，或者编译时出现警告等等，这些都是警告信号。任何警告信号都应让你质疑程序的质量，并促使你去寻求更满意的解决之道。&lt;/li&gt;
&lt;li&gt;一次又一次迭代：需求、设计、开发、测试，软件开发从头到尾每一步都充斥着迭代并逐步精化的过程。所以不要追求所谓的“一步登天”。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不要&lt;/strong&gt;存在软件信仰（即坚持某种做法）&lt;ul&gt;
&lt;li&gt;折中主义：要对编程问题找出最有效的解决方案时，盲目迷信某种方法只会缩小你的选择余地。折中主义是一种有益的态度，对于每个特定问题，应该将多种方法视为工具箱中的工具。多数时候工具的选择关系不大，但有些场合需要自己判断权衡，挑选最好的工具&lt;/li&gt;
&lt;li&gt;试验：要想有效地试验，应能基于试验结果改变思路。许多顽固的方法源于对错误的畏惧心理，“试图没有错误”是最大的错误。软件开发的各方面，你都应保待开放的心态&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;3-书单&quot;&gt;&lt;a href=&quot;#3-书单&quot; class=&quot;headerlink&quot; title=&quot;3. 书单&quot;&gt;&lt;/a&gt;3. 书单&lt;/h1&gt;&lt;p&gt;书中最后一章作者给出了一些建议阅读的经典著作，下面挑选了一部分有中译版本的书（有一些书再版了多次，链接给出的都是最新的版本）组成一个参考书单，供以后学习。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;软件构建类&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://book.douban.com/subject/5387402/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《程序员修炼之道》&lt;/a&gt;（《The Pragmatic Programmer》，Andrew Hunt / David Thomas）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://book.douban.com/subject/3227098/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《编程珠玑》&lt;/a&gt;（《Programming Pearls》，Jon Bentley）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://book.douban.com/subject/6524000/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《程序设计实践&lt;strong&gt;（评注版）&lt;/strong&gt;》&lt;/a&gt;（《The Practice of Programming》，Brian W. Kernighan / Rob Pike），注意这本书市面上没有很好的中译本，只有最新的这本评注版&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;软件工程综述类&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://book.douban.com/subject/26419766/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《软件开发心理学》&lt;/a&gt;（《The Psychology of Computer Programming》，Gerald M. Weinberg）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://book.douban.com/subject/2230248/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《人月神话》&lt;/a&gt;（《The Mythical Man-Month》，Frederick P.Brooks）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://book.douban.com/subject/6047742/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《软件工程：实践者的研究方法》&lt;/a&gt;（《The Mythical Man-Month》，Roger S.Pressman）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考文献：电子工业出版社《代码大全（第2版）》第33、34、35章&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;本文是《代码大全》学习笔记系列的最后一篇。书中最后几章是一些杂项主题，本文将简要记录这几个主题的内容，包括个人性格对编程的影响，软件开发艺术的有关问题，以及关于软件工程的推荐书单。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="综合" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/"/>
    
      <category term="软件工程" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="软件构建" scheme="http://raytaylorlin.com/tags/%E8%BD%AF%E4%BB%B6%E6%9E%84%E5%BB%BA/"/>
    
      <category term="软件工程" scheme="http://raytaylorlin.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="代码大全" scheme="http://raytaylorlin.com/tags/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>软件构建（十四）——代码布局与自说明代码</title>
    <link href="http://raytaylorlin.com/tech/complex/software/software-construction-14/"/>
    <id>http://raytaylorlin.com/tech/complex/software/software-construction-14/</id>
    <published>2016-05-12T13:17:18.000Z</published>
    <updated>2016-05-12T13:16:22.704Z</updated>
    
    <content type="html">&lt;p&gt;本文关注的是计算机编程的美学话题——程序源代码的布局和自说明性。尽管这些技巧并不影响执行速度、内存使用量等方面的程序性能，但它却会让你日后理解、检查以及修改代码变得更容易，也使其他人在你缺位的时候更容易阅读、理解和修改你的代码。&lt;/p&gt;
&lt;p&gt;需要注意的是，形成良好的代码布局，并让代码具备自说明性，需要始终贯穿项目的生命期，晚了就很难做好了。要想完全实现这些细节规定，在最初建构时就要着手去做。如果你干的是合作项目，更是要在开始编码之前统一大家的风格。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-代码布局&quot;&gt;&lt;a href=&quot;#1-代码布局&quot; class=&quot;headerlink&quot; title=&quot;1. 代码布局&quot;&gt;&lt;/a&gt;1. 代码布局&lt;/h1&gt;&lt;h2 id=&quot;1-1-良好布局的目标&quot;&gt;&lt;a href=&quot;#1-1-良好布局的目标&quot; class=&quot;headerlink&quot; title=&quot;1.1 良好布局的目标&quot;&gt;&lt;/a&gt;1.1 良好布局的目标&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;准确表现代码的逻辑结构：例如利用缩进、空行等空白来表达逻辑关系&lt;/li&gt;
&lt;li&gt;始终如一地表现代码的逻辑结构&lt;/li&gt;
&lt;li&gt;改善可读性：如果有一种缩进策略合乎逻辑，但却令程序更难看懂，那么它就毫无用处&lt;/li&gt;
&lt;li&gt;经得起修改：好的布局应该在修改某行时不必连带修改其他行的代码&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-2-常用布局技术与风格&quot;&gt;&lt;a href=&quot;#1-2-常用布局技术与风格&quot; class=&quot;headerlink&quot; title=&quot;1.2 常用布局技术与风格&quot;&gt;&lt;/a&gt;1.2 常用布局技术与风格&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;空白：包括空格、制表符、换行、空行等等。程序中的空白就像书籍中划分章节、段落、句子一样向读者展示组织主题的思路&lt;ul&gt;
&lt;li&gt;分组：确保相关的语句成组放在一起，用空行分隔，就像文章中的一段话一样&lt;/li&gt;
&lt;li&gt;空行：将不相关的语句分隔开，就像文章中段与段的分隔一样&lt;/li&gt;
&lt;li&gt;缩进：显示程序的逻辑结构&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;括号：对包含两个以上的项的表达式，应该用括号去澄清&lt;/li&gt;
&lt;li&gt;控制结构布局&lt;ul&gt;
&lt;li&gt;别让begin和end对两次缩进&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;单条语句&lt;/strong&gt;的代码块的格式要前后统一&lt;/li&gt;
&lt;li&gt;对于复杂的表达式，将条件分隔放在几行上&lt;/li&gt;
&lt;li&gt;case语句不要有行尾布局的例外&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;单条语句布局&lt;ul&gt;
&lt;li&gt;各种标点符号两侧使用空格会让逻辑表达式更易读&lt;/li&gt;
&lt;li&gt;使用空格让数组引用，子程序参数更易读&lt;/li&gt;
&lt;li&gt;单条语句过长时，应分行，并让续行显得更明显，通常在行尾以&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;、&lt;code&gt;||&lt;/code&gt;、&lt;code&gt;+-*/&lt;/code&gt;等符号为结尾&lt;/li&gt;
&lt;li&gt;续行要以标准的空格数缩进&lt;/li&gt;
&lt;li&gt;不要将赋值语句按等号对齐&lt;/li&gt;
&lt;li&gt;每行仅写一条语句（C++中不要让一行里有多个副作用操作（如&lt;code&gt;++a&lt;/code&gt;））&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据声明布局&lt;ul&gt;
&lt;li&gt;每行只声明一个变量&lt;/li&gt;
&lt;li&gt;合理组织声明顺序：建议按类型分类&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;注释布局&lt;ul&gt;
&lt;li&gt;注释的缩进要与相应代码一致&lt;/li&gt;
&lt;li&gt;每行注释用至少一个空行分开&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;子程序布局&lt;ul&gt;
&lt;li&gt;用空行分隔子程序的各部分&lt;/li&gt;
&lt;li&gt;将子程序参数按标准缩进，如果参数过多，可以考虑一行放一个参数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;类布局&lt;ul&gt;
&lt;li&gt;类的内容按以下顺序排布：说明类及其完整用法的头部注释、类数据、构造函数与析构函数、public子程序、protected子程序、private子程序&lt;/li&gt;
&lt;li&gt;一个文件应只有一个类，文件的命名应与类名有关&lt;/li&gt;
&lt;li&gt;在文件中清晰地分隔各子程序&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关于块结构和花括号指定的块边界，不同语言有不一样的规范。书中所提规范放在某些语言也不适用，实际使用应遵循相应的规范，此处不赘述书中所提的布局与风格。&lt;/p&gt;
&lt;h1 id=&quot;2-自说明代码&quot;&gt;&lt;a href=&quot;#2-自说明代码&quot; class=&quot;headerlink&quot; title=&quot;2. 自说明代码&quot;&gt;&lt;/a&gt;2. 自说明代码&lt;/h1&gt;&lt;h2 id=&quot;2-1-编程风格的重要性&quot;&gt;&lt;a href=&quot;#2-1-编程风格的重要性&quot; class=&quot;headerlink&quot; title=&quot;2.1 编程风格的重要性&quot;&gt;&lt;/a&gt;2.1 编程风格的重要性&lt;/h2&gt;&lt;p&gt;自说明代码代表了易读性的最高水平，而且一般是&lt;strong&gt;由良好的编码风格决定&lt;/strong&gt;，很大程度&lt;strong&gt;与注释无关&lt;/strong&gt;。对于精心编写的代码而言， 注释不过是美丽衣裳上的小饰物而已。关于自说明代码所体现出的编码风格，请参见&lt;a href=&quot;http://www.kancloud.cn/raytaylorlin/code-complete-checklist/150866&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;核对表：自说明代码&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;2-2-高效注释&quot;&gt;&lt;a href=&quot;#2-2-高效注释&quot; class=&quot;headerlink&quot; title=&quot;2.2 高效注释&quot;&gt;&lt;/a&gt;2.2 高效注释&lt;/h2&gt;&lt;p&gt;注释的作用分为六种：重复代码（用文字把代码的工作又描述一次，&lt;strong&gt;这种注释是废话，应杜绝&lt;/strong&gt;）、解释代码（通常是因为代码含糊不清，此时应&lt;strong&gt;改进代码&lt;/strong&gt;而不是添加注释）、代码标记（提示工作未做完，待修复等等）、概述代码（用一两句话把若干行代码的意思说出来）、代码意图说明（指出一段代码要解决的问题，而非解决问题的方法）、传达代码无法表述的信息（如版权声明、保密要求、doc注释符号等等）。&lt;strong&gt;对于完工的代码，只允许有的三种注释类型：概述代码、代码说明意图和代码无法表达的信息。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;注释占用太多时间通常归因于两点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;注释的风格可能耗时或枯燥乏味。如果这样，请另谋新的风格。需要庞大工作量的注释风格维护起来也会令人头痛。如果注释不便修改，人们就不愿意修改。于是注释就会变得不准确，起到误导作用，反而还不如没有注释&lt;/li&gt;
&lt;li&gt;说明程序干什么的话不好想出来。这通常是你没有真正理解程序的信号。“写注释”所占用的时间其实都用在了更好地理解程序上面，而不管你写不写注释，这些时间注定是得花的&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面是高效注释的几条指导原则。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;采用不会打断或抑制修改的注释凤格：不要为了美观而使用大量的&lt;code&gt;.-*&lt;/code&gt;符号排版的注释，例如用星号围成一个矩形的注释，每加入一行都得小心维护右边的星号。如果花大量时间增删符号只是为了对齐，你就不是在编程，而是浪费时光&lt;/li&gt;
&lt;li&gt;用伪代码编程法减少注释时间&lt;/li&gt;
&lt;li&gt;将注释集成到你的开发过程中：不要项目快结束时才开始写注释，也不要把注释当做专门的任务，而应该边写代码边注释。&lt;/li&gt;
&lt;li&gt;性能不是逃避注释的好借口：像Javascript的注释会增大网络传输的流量，但这不是理由，解决方案应该是构建不包含注释的发布版代码，区别于开发版代码&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-3-注释技术&quot;&gt;&lt;a href=&quot;#2-3-注释技术&quot; class=&quot;headerlink&quot; title=&quot;2.3 注释技术&quot;&gt;&lt;/a&gt;2.3 注释技术&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;注释单行&lt;ul&gt;
&lt;li&gt;不要随意添加无关的注释&lt;/li&gt;
&lt;li&gt;尽量不要使用行尾注释，因为写行尾难以格式化和维护，也经常是重复说明本行代码的废话。这几种例外情况可以使用行尾注释：用于数据声明，或标记代码块尾部（如end while，end if）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;注释代码段&lt;ul&gt;
&lt;li&gt;注释应表达代码段的意图，指出代码本身说不清的本意。TIPS：在给代码段写意图注释时，想象这段代码转换成一个子程序，应该命名什么名字，这个名字很有可能就是意图&lt;/li&gt;
&lt;li&gt;注释应注重“为何做（why）”而不是“怎么做（how）”&lt;/li&gt;
&lt;li&gt;用注释为后面的内容做铺垫：好的注释会让读者只要浏览注释就能了解代码在做什么，去哪找特定的操作&lt;/li&gt;
&lt;li&gt;说明非常规做法（trick）&lt;/li&gt;
&lt;li&gt;代码错误或语言环境独特点都要加注释&lt;/li&gt;
&lt;li&gt;给出不得不故意违背良好编程风格的理由&lt;/li&gt;
&lt;li&gt;不要为投机取巧的代码加注释说明，应重写之&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;注释数据声明&lt;ul&gt;
&lt;li&gt;注释数据的单位（包括单位所处的背景环境）和取值范围（包括输入数据的限制）&lt;/li&gt;
&lt;li&gt;注释枚举类型各个值的含义，注释bit位标识的含义&lt;/li&gt;
&lt;li&gt;注释全局数据：指出该数据的目的，为何必须是全局数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;注释控制结构&lt;ul&gt;
&lt;li&gt;应在每个if、case、循环前加上注释，阐明控制结构的意图&lt;/li&gt;
&lt;li&gt;在长控制结构或嵌套控制结构结尾处加上注释&lt;/li&gt;
&lt;li&gt;如果用到了上一条规则，那么应将控制结构结束处的注释看成是代码太复杂的征兆：最好办法就是重写代码，使之不再复杂到需要费劲注释的程度&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;注释子程序&lt;ul&gt;
&lt;li&gt;在子程序上部用一两句话说明其意图，如果参数很复杂要在声明参数处注释这些参数（如果参数涉及输出，还要特别说明）&lt;/li&gt;
&lt;li&gt;利用诸如Javadoc之类的代码说明工具，则可以替代上一条&lt;/li&gt;
&lt;li&gt;注释接口假设：例如假设传入的数组是有序的，传入的对象是初始化过的等等，都应该描述清楚&lt;/li&gt;
&lt;li&gt;对子程序的局限性作注释：例如指出结果的精确度，子程序碰到麻烦时的默认行为，对程序做什么修改会损坏此子程序等等&lt;/li&gt;
&lt;li&gt;说明子程序对全局数据的操作，如果有的话&lt;/li&gt;
&lt;li&gt;记录所用算法的来源&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;注释类和文件&lt;ul&gt;
&lt;li&gt;说明类的设计方法，局限性、用法假设，不要在类接口处说明实现细节&lt;/li&gt;
&lt;li&gt;在文件开头处用注释块说明文件的意图和内容&lt;/li&gt;
&lt;li&gt;在文件注释块中包含作者姓名、电子邮件、电话号码、版本控制标记、法律通告等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考文献：电子工业出版社《代码大全（第2版）》第31、32章&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;本文关注的是计算机编程的美学话题——程序源代码的布局和自说明性。尽管这些技巧并不影响执行速度、内存使用量等方面的程序性能，但它却会让你日后理解、检查以及修改代码变得更容易，也使其他人在你缺位的时候更容易阅读、理解和修改你的代码。&lt;/p&gt;
&lt;p&gt;需要注意的是，形成良好的代码布局，并让代码具备自说明性，需要始终贯穿项目的生命期，晚了就很难做好了。要想完全实现这些细节规定，在最初建构时就要着手去做。如果你干的是合作项目，更是要在开始编码之前统一大家的风格。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="综合" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/"/>
    
      <category term="软件工程" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="软件构建" scheme="http://raytaylorlin.com/tags/%E8%BD%AF%E4%BB%B6%E6%9E%84%E5%BB%BA/"/>
    
      <category term="软件工程" scheme="http://raytaylorlin.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="代码大全" scheme="http://raytaylorlin.com/tags/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>软件构建（十三）——代码集成</title>
    <link href="http://raytaylorlin.com/tech/complex/software/software-construction-13/"/>
    <id>http://raytaylorlin.com/tech/complex/software/software-construction-13/</id>
    <published>2016-05-09T07:35:29.000Z</published>
    <updated>2016-05-12T13:13:50.400Z</updated>
    
    <content type="html">&lt;p&gt;集成是指将一些独立的软件组件组合为一个完整系统。对大项目，集成也许要花数周或数月时间，把一组程序编织为一个整体。本文将首先介绍不太常用的阶段式集成，然后再介绍更为常用的增量集成，其中集成的策略是讨论的重点。最后每日构建与冒烟测试的使用原则。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;集成是在开发人员完成开发者测试之后才进行的，而且集成过程是与系统测试一道进行的，所以集成有时也被认为是一种测试行为。然而，集成本身就足够复杂了，因此应该被看做一项独立的行动。程序集成有两种方式：阶段式集成和增量集成。&lt;/p&gt;
&lt;h1 id=&quot;1-阶段式集成&quot;&gt;&lt;a href=&quot;#1-阶段式集成&quot; class=&quot;headerlink&quot; title=&quot;1. 阶段式集成&quot;&gt;&lt;/a&gt;1. 阶段式集成&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;设计、编码、测试、调试各个类，这一步称为“单元开发”&lt;/li&gt;
&lt;li&gt;将这些类组合为一个庞大的系统，这一步成为“系统集成”&lt;/li&gt;
&lt;li&gt;测试并调试整个系统，这一步成为“系统瓦解（system dis-integration）”&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这种集成的问题是，当第一次把系统中的类放到一起时，新的问题会不可避免地大量浮现，所有的类都有嫌疑导致出问题的位置难以确定。所以对绝大多数情况，阶段式集成都不是很适用。&lt;/p&gt;
&lt;h1 id=&quot;2-增量集成&quot;&gt;&lt;a href=&quot;#2-增量集成&quot; class=&quot;headerlink&quot; title=&quot;2. 增量集成&quot;&gt;&lt;/a&gt;2. 增量集成&lt;/h1&gt;&lt;h2 id=&quot;2-1-方法&quot;&gt;&lt;a href=&quot;#2-1-方法&quot; class=&quot;headerlink&quot; title=&quot;2.1 方法&quot;&gt;&lt;/a&gt;2.1 方法&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;开发一个小的系统功能部件。它可能是最小的功能部件、最难的部件、关键部件、或者以上的某种组合，对它彻底地测试并调试。将它作为骨架，稍后附着肌肉、神经、皮肤等系统的其余部件&lt;/li&gt;
&lt;li&gt;设计、编码、测试、调试某个类&lt;/li&gt;
&lt;li&gt;将这个新的类集成到系统骨架上，测试并调试“骨架和新类的结合体”。在进一步添加任何新类之前，确保该结合体能工作。如果做完了剩余的所有工作，就回到步骤2开始重复这一过程&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;2-2-相对阶段式集成的优势&quot;&gt;&lt;a href=&quot;#2-2-相对阶段式集成的优势&quot; class=&quot;headerlink&quot; title=&quot;2.2 相对阶段式集成的优势&quot;&gt;&lt;/a&gt;2.2 相对阶段式集成的优势&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;易于定位错误：降低“多个问题之间相互影响”或“一个问题将另一个问题掩盖”的风险&lt;/li&gt;
&lt;li&gt;及旱在项目里取得系统级的成果&lt;/li&gt;
&lt;li&gt;改善对进度的监控：利于管理层判断进度和需求&lt;/li&gt;
&lt;li&gt;更加充分地测试系统中的各个单元&lt;/li&gt;
&lt;li&gt;能在更短的开发进度计划内建造出整个系统&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-3-策略&quot;&gt;&lt;a href=&quot;#2-3-策略&quot; class=&quot;headerlink&quot; title=&quot;2.3 策略&quot;&gt;&lt;/a&gt;2.3 策略&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;自顶向下集成&lt;ul&gt;
&lt;li&gt;一般从主入口（Main函数、主窗体等等）开始，测试顶层类时需要一些存根（stub）类辅助，最终逐渐替换为实际的类&lt;/li&gt;
&lt;li&gt;优点：能快速得到一个能部分工作的系统，并及早地暴露一些设计上的问题&lt;/li&gt;
&lt;li&gt;缺点：棘手的系统接口的演练必须留到最后才进行，有问题的底层可能会反过来影响顶层&lt;/li&gt;
&lt;li&gt;纯粹的自顶向下集成几乎是不可能的，大多时候使用混合方法集成，或用下图的在各个竖直划分的功能块中自顶向下集成&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://raytaylorlin-blog.qiniudn.com/image%2Fsoftware%2F%E5%9C%A8%E5%90%84%E4%B8%AA%E7%AB%96%E7%9B%B4%E5%88%92%E5%88%86%E7%9A%84%E5%8A%9F%E8%83%BD%E5%9D%97%E4%B8%AD%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E9%9B%86%E6%88%90.png&quot; alt=&quot;在各个竖直划分的功能块中自顶向下集成&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自底向上集成&lt;ul&gt;
&lt;li&gt;首先要完成整个系统的设计，然后一个一个添加底层类向上层集成，最初需要编写驱动测试类&lt;/li&gt;
&lt;li&gt;优点：容易定位错误，尽早演练“可能存在问题的系统接口”&lt;/li&gt;
&lt;li&gt;缺点：如果高层存在概念上的设计问题，那么要把所有细节工作都做完才能发现&lt;/li&gt;
&lt;li&gt;一般也很少用纯粹的自底向上集成&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;三明治集成&lt;ul&gt;
&lt;li&gt;首先集成继承体系顶部的高层业务对象类，然后集成底部的与设备接口的类和广泛使用的工具类，最后集成中间层的类&lt;/li&gt;
&lt;li&gt;结合了上述两种方式的优点，是现实的实用的方法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;风险导向的集成&lt;ul&gt;
&lt;li&gt;大顺序和三明治集成一致，但细节顺序，是优先考虑高风险的实现最有挑战的部件，如顶层接口、底层系统接口、未被透彻理解的算法的类等等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;功能导向的集成&lt;ul&gt;
&lt;li&gt;首先需要搭建好骨架，然后按照功能（模块）划分顺序来集成，如下图所示&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://raytaylorlin-blog.qiniudn.com/image%2Fsoftware%2F%E5%8A%9F%E8%83%BD%E5%AF%BC%E5%90%91%E7%9A%84%E9%9B%86%E6%88%90%E7%A4%BA%E6%84%8F%E5%9B%BE.png&quot; alt=&quot;功能导向的集成示意图&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;T型集成&lt;ul&gt;
&lt;li&gt;先选中某个特定的“竖直块”及早开发并集成，这个功能块应该能从头到尾演练系统，并找出系统设计的全部主要问题。纠正所有问题后，就可以开始开发系统其它核心部件，如下图所示。这种方法常与风险导向和功能导向集成集合使用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://raytaylorlin-blog.qiniudn.com/image%2Fsoftware%2FT%E5%9E%8B%E9%9B%86%E6%88%90%E7%A4%BA%E6%84%8F%E5%9B%BE.png&quot; alt=&quot;T型集成示意图&quot;&gt;&lt;/p&gt;
&lt;p&gt;集成顺序的策略有多种多样的形状和规模，没有哪一种对所有情况而言都是最佳的。&lt;strong&gt;最佳集成步骤随项目不同而变化，最佳解决方案总是为了满足特定项目的特定需求而制定的，不要像教条一样遵循前面提到的任何过程。&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;3-每日构建与冒烟测试&quot;&gt;&lt;a href=&quot;#3-每日构建与冒烟测试&quot; class=&quot;headerlink&quot; title=&quot;3. 每日构建与冒烟测试&quot;&gt;&lt;/a&gt;3. 每日构建与冒烟测试&lt;/h1&gt;&lt;p&gt;无论选用哪种集成策略，&lt;a href=&quot;http://baike.baidu.com/view/1704207.htm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;每日构建（daily build）&lt;/a&gt;和&lt;a href=&quot;http://baike.baidu.com/view/120001.htm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;冒烟测试&lt;/a&gt;都是软件集成的好方法。这些简单的过程可以降低出现低质量软件的风险，也便于诊断缺陷，并且每天的成果可以极大地鼓舞士气。以下是这两种方法的一些使用原则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关键是&lt;strong&gt;每一天&lt;/strong&gt;坚持build：某次build失败可以将错误锁定在一天之内&lt;/li&gt;
&lt;li&gt;检查失败的build：每个项目要建立一套评定“什么才算是破坏了build”的质量标准&lt;/li&gt;
&lt;li&gt;每天进行准确的冒烟测试：冒烟测试应彻底地从头到尾演练&lt;strong&gt;已完成的&lt;/strong&gt;系统的主要功能，不要认为是浪费时间的重复性工作&lt;/li&gt;
&lt;li&gt;自动化：&lt;strong&gt;脱离自动化谈每日构建与冒烟测试是不切实际的&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;成立build小组&lt;/li&gt;
&lt;li&gt;仅当有意义时，才将修订（revisions）加入build中……：因为通常开发者编写代码的速度不会快到使系统每天都有明显的进展&lt;/li&gt;
&lt;li&gt;……但是别等太久才将修订加入进来：警惕某个开发人员接连两三天都不check in他做的改动，他很可能陷入一组牵扯到大量文件的修订中&lt;/li&gt;
&lt;li&gt;要求开发人员在把他的代码添加到系统之前，进行本地冒烟测试&lt;/li&gt;
&lt;li&gt;为即将添加到build的代码准备一块暂存区，在暂存区产生新的build并认为其可接受时，才合并到主源码中&lt;/li&gt;
&lt;li&gt;惩罚破坏build的人：build失败是异常情况，应严肃对待&lt;/li&gt;
&lt;li&gt;在早上发布build：测试人员可以当天测试，发现问题也能尽早找到开发者解决&lt;/li&gt;
&lt;li&gt;即使有进度压力，也要保持daily build和冒烟测试&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考文献：电子工业出版社《代码大全（第2版）》第29章&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;集成是指将一些独立的软件组件组合为一个完整系统。对大项目，集成也许要花数周或数月时间，把一组程序编织为一个整体。本文将首先介绍不太常用的阶段式集成，然后再介绍更为常用的增量集成，其中集成的策略是讨论的重点。最后每日构建与冒烟测试的使用原则。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="综合" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/"/>
    
      <category term="软件工程" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="软件构建" scheme="http://raytaylorlin.com/tags/%E8%BD%AF%E4%BB%B6%E6%9E%84%E5%BB%BA/"/>
    
      <category term="软件工程" scheme="http://raytaylorlin.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="代码大全" scheme="http://raytaylorlin.com/tags/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>软件构建（十二）——软件的规模与管理</title>
    <link href="http://raytaylorlin.com/tech/complex/software/software-construction-12/"/>
    <id>http://raytaylorlin.com/tech/complex/software/software-construction-12/</id>
    <published>2016-05-06T09:00:40.000Z</published>
    <updated>2016-05-12T13:14:52.322Z</updated>
    
    <content type="html">&lt;p&gt;软件开发的规模扩大并不是像“拿一个小项目来，然后增大它的每一部分”那样简单。如果要开发大型软件，就必须了解软件规模对构建的影响。此外，本文将记录与构建直接相关的一些特定管理问题。如果你是一名开发人员，本文将帮助你了解管理者需要考虑的一些问题；如果你是一名管理者，本文将帮助你了解开发人员是如何看待管理者的，以及如何才能有效地管理构建。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-程序规模对构建的影响&quot;&gt;&lt;a href=&quot;#1-程序规模对构建的影响&quot; class=&quot;headerlink&quot; title=&quot;1. 程序规模对构建的影响&quot;&gt;&lt;/a&gt;1. 程序规模对构建的影响&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;成员交流与项目规模的关系：交流路径越多，花在交流上的时间就越多（见下图），因交流而出错的机会也就越大，改善交流效率的常用方法是采用正式的文挡&lt;ul&gt;
&lt;li&gt;&lt;img src=&quot;http://7d9rl0.com1.z0.glb.clouddn.com/image/software/%E6%88%90%E5%91%98%E4%BA%A4%E6%B5%81%E4%B8%8E%E9%A1%B9%E7%9B%AE%E8%A7%84%E6%A8%A1%E7%9A%84%E5%85%B3%E7%B3%BB.png&quot; alt=&quot;成员交流与项目规模的关系&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;项目规模对错误的影响：在小项目中，构建错误大约占所有被发现错误的75%，在更大的项目中，构建错误占错误总数的比例逐步下降到50%左右，而需求错误和架构错误则弥补了其中差额。缺陷密度（每1000行代码所包含的缺陷数量）会随项目规模增大而增加&lt;/li&gt;
&lt;li&gt;顶目规模对生产率的影响：小项目的生产率会比大项目高出2至3倍，并且最小的项目和最大的项目的生产率差距可能达到5到10倍之巨&lt;/li&gt;
&lt;li&gt;顶目规模对开发活动的影响：对小型项目，构建占差不多65%的开发实践，随着项目规模增大，构建的比重逐渐减小，架构、设计、集成和测试占更多时间&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;2-管理构建&quot;&gt;&lt;a href=&quot;#2-管理构建&quot; class=&quot;headerlink&quot; title=&quot;2. 管理构建&quot;&gt;&lt;/a&gt;2. 管理构建&lt;/h1&gt;&lt;h2 id=&quot;2-1-鼓励良好的编码实践&quot;&gt;&lt;a href=&quot;#2-1-鼓励良好的编码实践&quot; class=&quot;headerlink&quot; title=&quot;2.1 鼓励良好的编码实践&quot;&gt;&lt;/a&gt;2.1 鼓励良好的编码实践&lt;/h2&gt;&lt;p&gt;从管理的角度出发，强制采用一套严格的技术标准并不是个好主意。如果项目中有人要制定标准，那么应该由一位受人尊敬的架构师来做，而不应该由管理者来做。下面给出一些编码实践，这些实践比呆板的编码标准更容易实行：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;给项目的每一部分分派两个人：结对编程，导师带学生等等&lt;/li&gt;
&lt;li&gt;同行复查代码：包括程序员本人和至少两名评审员的复查，可以为改善代码质量提供压力&lt;/li&gt;
&lt;li&gt;要求代码签名：在认定代码完成之前，高级技术人员要在代码清单上签字&lt;/li&gt;
&lt;li&gt;安排一些好的代码示例供人参考&lt;/li&gt;
&lt;li&gt;强调代码是公有财产&lt;/li&gt;
&lt;li&gt;奖励好代码：给予程序员想要的奖励，只有非常出色的代码才应得到奖励&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-2-配置管理&quot;&gt;&lt;a href=&quot;#2-2-配置管理&quot; class=&quot;headerlink&quot; title=&quot;2.2 配置管理&quot;&gt;&lt;/a&gt;2.2 配置管理&lt;/h2&gt;&lt;p&gt;配置管理即“变更控制”。如果你不对需求变更加以控制，那么就会为系统中某些最终会被去除的部件编写代码，也会去写出一些可能与系统中新的部件不兼容的代码；可能会修改某个别人也正在修改的子程序，把两个人的改动合并导致出现问题。总之，配置管理就是使用评估提交的更改、追踪更改、保留系统在不同时间点的历史版本等等技术来对软件项目的变化进行控制。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需求变更和设计变更&lt;ul&gt;
&lt;li&gt;遵循某种系统化的变更控制手续&lt;/li&gt;
&lt;li&gt;成组地处理变更请求：先记下所有的想法和建议，直到有时间再去整体处理它们，以防总是在中途突然变卦&lt;/li&gt;
&lt;li&gt;评估每项变更的成本：重新设计和编码，修改用户文档，评估代码复查，重新测试等等各种时间成本&lt;/li&gt;
&lt;li&gt;提防大量的变更请求：有时这可能是一个表明需求、架构或上层设计做的不够好导致无法支持变更的警报&lt;/li&gt;
&lt;li&gt;成立变更控制委员会或者类似机构&lt;/li&gt;
&lt;li&gt;警惕官僚主义，但也不要因为害怕官僚主义而排斥有效的变更控制&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;软件代码变更：使用合适的版本控制软件&lt;/li&gt;
&lt;li&gt;工具版本：可能有些项目需要“重新构造出‘创建软件的各个特定版本’的原样环境”的能力，这时需要把编译器、链接器、代码库等也纳入版本控制中&lt;/li&gt;
&lt;li&gt;机器配置：使用标准化的开发机器配置和操作系统映像，可以省掉许多开发前配置的麻烦&lt;/li&gt;
&lt;li&gt;备份计划：项目过程中应定期备份代码、文档、图表以及保存介质；要测试备份过程，确保所需的全部数据能正确恢复；昨晚项目后及时归档&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-3-评估构建进度&quot;&gt;&lt;a href=&quot;#2-3-评估构建进度&quot; class=&quot;headerlink&quot; title=&quot;2.3 评估构建进度&quot;&gt;&lt;/a&gt;2.3 评估构建进度&lt;/h2&gt;&lt;p&gt;对于项目预估进度和实际进度，有调查表明，开发人员的估计值比实际值要乐观20%~30%。评估项目规模的方法有很多种，例如使用评估软件，使用算法方法，聘请外界的评估专家，评估项目的每一部分并加起来等等。下面是一套评估项目的参考原则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;建立目标：理清评估的目的、内容、准确度、乐观评估和悲观评估结果等&lt;/li&gt;
&lt;li&gt;为评估留出时间，并且做出计划&lt;/li&gt;
&lt;li&gt;清楚地说明软件需求&lt;/li&gt;
&lt;li&gt;在底层细节层面（划分为多个小块并分别）进行评估&lt;/li&gt;
&lt;li&gt;使用若干不同的评估方法，并且比较其结果&lt;/li&gt;
&lt;li&gt;在项目推进过程中定期做重新评估&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了按时完成软件项目而做的“计划”中，评估是很重要的组成部分。然而，最初评估的准确度的重要性远远比不上“随后为了完成进度而成功地&lt;strong&gt;控制资源&lt;/strong&gt;”的重要性。如果项目进度落后了，人们经常会产生一些错觉：“我们后面一定会加班加点把时间补回来”，调查显示越接近项目后期，延误和超支的现象就越严重；“扩充团队来加速开发”，新手需要先花时间熟悉项目，占用现有人员的培训时间，然后才能发挥出生产率，而且仅仅增加人员数量，会导致项目交流的复杂度和数量增加，除非项目的任务是可分割的才能通过增加人手完成。&lt;/p&gt;
&lt;p&gt;缩减项目范围是在进度落后时的有效手段。最初做产品计划的时候，要把产品的功能划分成“必须有”、“有了更好”和“可选择”三类。如果进度落后了，那么就调整“可选择”和“有了更好”的优先级，并扔掉那些最不重要的功能。&lt;/p&gt;
&lt;h2 id=&quot;2-4-把程序员当人看&quot;&gt;&lt;a href=&quot;#2-4-把程序员当人看&quot; class=&quot;headerlink&quot; title=&quot;2.4 把程序员当人看&quot;&gt;&lt;/a&gt;2.4 把程序员当人看&lt;/h2&gt;&lt;p&gt;首先要了解程序员的时间分配。研究表明一个程序员大约有30%的时间花费在“对项目没有直接好处”的非技术活动之上：步行、个人事务等，学习和编写代码占约30%。&lt;/p&gt;
&lt;p&gt;其次是了解程序员的信仰问题。这些信仰涉及编程语言、编码风格、编程工具、编程方法论等等。作为一个管理者，要清楚地知道信仰是一个敏感的问题，对这些领域要使用“建议”或者“指导原则”（避免僵硬的“规则”或“标准”），并让程序员们制定他们自己的标准。当然，如果有人因可读性差等影响整个项目的实践行为，为了提高代码质量，不要怕引发一些摩擦。&lt;/p&gt;
&lt;p&gt;最后，要了解物理环境对程序员生产率有着巨大的影响。这些环境包括桌子、椅子、电脑、书籍、键盘，以及办公氛围、不经常被打扰的环境等等。如果你的工作环境属于最差的那25%，那么你有机会给生产率带来100%的提升，办法是把环境改善为最佳的那25%。&lt;/p&gt;
&lt;h2 id=&quot;2-5-管理你的管理者&quot;&gt;&lt;a href=&quot;#2-5-管理你的管理者&quot; class=&quot;headerlink&quot; title=&quot;2.5 管理你的管理者&quot;&gt;&lt;/a&gt;2.5 管理你的管理者&lt;/h2&gt;&lt;p&gt;在软件开发中，如果你需要面对非技术出身的管理者，你可能要肩负起“管理你的管理者”的责任。其要点在于，你要表现得使你的管理者认为他仍然在管理你。有这么一些应对管理者的方法：把你希望做什么的念头先藏起来，等着你的管理者组织一场有关你希望什么的头脑风暴/集体讨论；把做事情的正确方法传授给你的管理者；关注你的管理者的兴趣，按照他的真正意图去做；拒绝按照你的管理者所说的去做，坚持用正确的方法做自己的事；换工作。&lt;/p&gt;
&lt;p&gt;参考文献：电子工业出版社《代码大全（第2版）》第27、28章&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;软件开发的规模扩大并不是像“拿一个小项目来，然后增大它的每一部分”那样简单。如果要开发大型软件，就必须了解软件规模对构建的影响。此外，本文将记录与构建直接相关的一些特定管理问题。如果你是一名开发人员，本文将帮助你了解管理者需要考虑的一些问题；如果你是一名管理者，本文将帮助你了解开发人员是如何看待管理者的，以及如何才能有效地管理构建。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="综合" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/"/>
    
      <category term="软件工程" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="软件构建" scheme="http://raytaylorlin.com/tags/%E8%BD%AF%E4%BB%B6%E6%9E%84%E5%BB%BA/"/>
    
      <category term="软件工程" scheme="http://raytaylorlin.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="代码大全" scheme="http://raytaylorlin.com/tags/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>软件构建（十一）——代码性能的调整</title>
    <link href="http://raytaylorlin.com/tech/complex/software/software-construction-11/"/>
    <id>http://raytaylorlin.com/tech/complex/software/software-construction-11/</id>
    <published>2016-05-03T02:16:11.000Z</published>
    <updated>2016-05-12T13:14:47.660Z</updated>
    
    <content type="html">&lt;p&gt;本文首先概述了程序运行性能应该考虑的一些问题，然后从策略上和技术上两个方面来探讨代码性能的调整问题。技术上的代码调整并没有什么万金油的方法，也不是灵丹妙药，唯一可以信赖的法则就是每次都应当在具体的环境下评估代码调整所带来的效果，而本文所列的调整方法则仅供参考。此外，追求性能的背后往往伴随着牺牲程序的可读性和可维护性，而&lt;strong&gt;在很多情况下，代码的可读性和可维护性都要比运行速度或资源占用更为重要。&lt;/strong&gt;因此在调整代码时一定要考虑这样的性能提升是否真的必要。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-性能概述&quot;&gt;&lt;a href=&quot;#1-性能概述&quot; class=&quot;headerlink&quot; title=&quot;1. 性能概述&quot;&gt;&lt;/a&gt;1. 性能概述&lt;/h1&gt;&lt;p&gt;现实中，相对于代码质量和纯粹的性能，用户更关心的是程序的外在特性和处理能力。性能同代码速度之间存在着很松散的联系。如果只是关注于代码的运行速度，你的工作不免顾此失彼。要特别当心放弃其他功能去让你的代码跑得更快。如果过分强调速度，程序的整体性能（表现）常常不升反降。&lt;/p&gt;
&lt;p&gt;如果要追求程序的效率，可以从以下几个方面来思考问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;性能需求：客户要求的系统响应时间有时决定了设计方案的复杂度和成本，在花费时间处理一个性能问题之前，要想清楚是否真的需要满足这样的需求&lt;/li&gt;
&lt;li&gt;程序架构：优先考虑整体性能，然后再为每个子系统和类设置要达到的性能目标&lt;/li&gt;
&lt;li&gt;类和子程序设计：在这一层次，数据结构和算法将对性能产生重要影响&lt;/li&gt;
&lt;li&gt;与操作系统的交互：考虑系统I/O，系统调用等性能&lt;/li&gt;
&lt;li&gt;代码编译：这一层次由编译器和转化后的机器码决定，通常程序员无法干预&lt;/li&gt;
&lt;li&gt;硬件：有时直接升级硬件是最直接了当的提升性能的办法&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;2-策略上的代码调整&quot;&gt;&lt;a href=&quot;#2-策略上的代码调整&quot; class=&quot;headerlink&quot; title=&quot;2. 策略上的代码调整&quot;&gt;&lt;/a&gt;2. 策略上的代码调整&lt;/h1&gt;&lt;h2 id=&quot;2-1-佩雷托法则&quot;&gt;&lt;a href=&quot;#2-1-佩雷托法则&quot; class=&quot;headerlink&quot; title=&quot;2.1 佩雷托法则&quot;&gt;&lt;/a&gt;2.1 佩雷托法则&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%B8%95%E9%9B%B7%E6%89%98%E6%B3%95%E5%88%99&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;帕雷托法则&lt;/a&gt;即是众所周知的80/20法则，其对程序性能优化也是有效的，即程序中20%的子程序耗费了80%的执行时间。因此程序员们应当衡量代码的各个部分（如使用性能分析器），找出最需要关注的地方，然后集中火力来对付占用了绝大部分资源的少量代码。&lt;/p&gt;
&lt;h2 id=&quot;2-2-代码调整的一些误区&quot;&gt;&lt;a href=&quot;#2-2-代码调整的一些误区&quot; class=&quot;headerlink&quot; title=&quot;2.2 代码调整的一些误区&quot;&gt;&lt;/a&gt;2.2 代码调整的一些误区&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;在高级语言中，减少代码的行数就可以提升所生成的机器代码的运行速度，或是减少其资源占用——&lt;strong&gt;错误！&lt;/strong&gt;：实际上高级语言代码行数和程序最终的资源占用和运行速度之间并没有必然联系&lt;/li&gt;
&lt;li&gt;特定运算可能比其他的快，代码规模也较小——&lt;strong&gt;错误！&lt;/strong&gt;：程序性能受语言、编译器种类、编译器版本、库种类、库版本、中央处理器、机器内存等等环境的影响&lt;/li&gt;
&lt;li&gt;应当随时随地进行优化——&lt;strong&gt;错误！&lt;/strong&gt;：应该在整个系统完成之后综合分析，才能最准确快速地找到瓶颈&lt;/li&gt;
&lt;li&gt;程序的运行速度同其正确性同等重要——&lt;strong&gt;错误！&lt;/strong&gt;：程序要先保证正确运行，再考虑运行速度&lt;/li&gt;
&lt;li&gt;编译器的优化功能可能比你想象的要强大得多：在编写代码时自作聪明，编译器在优化这些代码的时候会痛苦不堪，结果是你的程序倒霉，&lt;strong&gt;应该使用直白的代码&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-3-常见的性能瓶颈&quot;&gt;&lt;a href=&quot;#2-3-常见的性能瓶颈&quot; class=&quot;headerlink&quot; title=&quot;2.3 常见的性能瓶颈&quot;&gt;&lt;/a&gt;2.3 常见的性能瓶颈&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;输入/输出操作：包括文件、数据库、网络等等的读写&lt;/li&gt;
&lt;li&gt;操作系统内存分页时的缺页中断&lt;/li&gt;
&lt;li&gt;系统调用：考虑编写自己的服务程序来替代，或者减少不必要的系统调用等等&lt;/li&gt;
&lt;li&gt;解释型语言&lt;/li&gt;
&lt;li&gt;代码中的错误：如没有去掉调试代码，忘记释放内存，数据库表设计失误，轮询并不存在的设备，超时等等&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-4-性能测量&quot;&gt;&lt;a href=&quot;#2-4-性能测量&quot; class=&quot;headerlink&quot; title=&quot;2.4 性能测量&quot;&gt;&lt;/a&gt;2.4 性能测量&lt;/h2&gt;&lt;p&gt;在优化代码的过程中，一定要使用工具来进行性能测量，特别是对代码进行改进之后要实际测量一下看有没有改进。一个的典型的案例是C++对矩阵元素求和，通常的写法是二重循环遍历行列求和，但有的人可能会觉得数组访问和循环条件判断会花掉很多时间，对于一个100×100的矩阵会产生一万次乘法和加法，于是考虑改成一重循环用指针访问数组（但这样会牺牲代码可读性）。但实际测量结果时修改后性能&lt;strong&gt;没有任何变化&lt;/strong&gt;，原因是编译器早已将数组访问改为用指针实现。这个案例告诉我们，&lt;strong&gt;性能问题的很多方面都是违反直觉的，而且经验对性能优化也没有太大的帮助。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;找出性能瓶颈之后，应该结合多种优化方法反复对代码进行迭代和调整，尽管每种方法单独实施起来收效并不大，但把所有方法结合起来将可以优化出非常好的结果。&lt;/p&gt;
&lt;h1 id=&quot;3-技术上的代码调整&quot;&gt;&lt;a href=&quot;#3-技术上的代码调整&quot; class=&quot;headerlink&quot; title=&quot;3. 技术上的代码调整&quot;&gt;&lt;/a&gt;3. 技术上的代码调整&lt;/h1&gt;&lt;p&gt;再次重申，&lt;strong&gt;在很多情况下，代码的可读性和可维护性都要比运行速度或资源占用更为重要。&lt;/strong&gt;因此在调整代码时一定要考虑这样的性能提升是否真的必要。而且调整完之后一定要用工具测量一下性能的提升到底有没有起效。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;逻辑判断的调整&lt;ul&gt;
&lt;li&gt;在知道答案后停止判断：利用好“短路求值”的语言特性中断and的条件判断，或者在循环遍历查找时找到后break退出&lt;/li&gt;
&lt;li&gt;按照出现频率来调整if-elseif的顺序，让运行最快和判断结果最有可能为真的判断首先被执行&lt;/li&gt;
&lt;li&gt;用查询表替代复杂表达式&lt;/li&gt;
&lt;li&gt;使用惰性求值：仅到必须使用的时候才去处理数据，例如有一张大数据表，程序仅仅用到很小一部分，与其在程序启动时生成表的所有内容，不如放到需要的时候再计算&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;循环的调整&lt;ul&gt;
&lt;li&gt;将循环中的判断往外提，避免每次在循环中做重复的判断&lt;/li&gt;
&lt;li&gt;当两个循环的下标变化相同时，可以考虑合并成一个循环，但要确保代码先后顺序一致&lt;/li&gt;
&lt;li&gt;将循环展开（减少了循环条件判断）：会严重影响可读性，而且只对少量元素的循环适用&lt;/li&gt;
&lt;li&gt;尽可能减少在循环内部做的工作：例如将重复计算的常量移到循环外&lt;/li&gt;
&lt;li&gt;在线性查找循环中，使用“哨兵值”来替代多次条件判断&lt;/li&gt;
&lt;li&gt;把最忙的（即循环次数多的）循环放在最内层&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据变换的调整&lt;ul&gt;
&lt;li&gt;使用整数而不是浮点数&lt;/li&gt;
&lt;li&gt;尽可能减少数组维度：例如考虑用一维数组来表示二维的矩阵&lt;/li&gt;
&lt;li&gt;尽可能减少数组引用&lt;/li&gt;
&lt;li&gt;使用辅助索引：添加相关数据，使得对某种数据类型的访问更为高效。例如，如果数据类型中的条目很大或是存于磁盘上难于移动，可以创建一个存放关键码和指向详细信息的指针的辅助索引，在内存中对索引进行排序或查找，最后进行一次代价高昂的访问即可&lt;/li&gt;
&lt;li&gt;使用缓存机制：缓存常用的或者需要耗费大量时间计算的值。创建新元素的代价越大，请求相同信息的次数越多，那么缓存就越有价值，风险是增加程序的复杂性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;表达式的调整&lt;ul&gt;
&lt;li&gt;利用代数恒等式：例如&lt;code&gt;not (a or b)&lt;/code&gt;比&lt;code&gt;not a and not b&lt;/code&gt;省一次not操作，判断&lt;code&gt;x &amp;lt; y&lt;/code&gt;要比判断&lt;code&gt;sqrt(x) &amp;lt; sqrt(y)&lt;/code&gt;省上几十甚至上百倍的时间&lt;/li&gt;
&lt;li&gt;削弱运算强度：如用加法替代乘法，乘法代替乘幂，移位替代乘除，三角恒等式代换等价的三角函数，单精度数代替双精度数等等&lt;/li&gt;
&lt;li&gt;编译期初始化：把代价高昂的常量计算提前定义成常量&lt;/li&gt;
&lt;li&gt;如果系统函数提供的功能过于复杂，考虑自己写一个：例如计算以2为底且是整数的对数函数，与其使用官方的浮点log函数计算，不如自己写一个穷举整数范围的Log2函数&lt;/li&gt;
&lt;li&gt;删除重复使用的公共子表达式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;子程序的调整&lt;ul&gt;
&lt;li&gt;将子程序重写为内联（C++）&lt;/li&gt;
&lt;li&gt;用低级语言重写核心代码：应先用高级语言编写整个应用程序，经过完整测试验证正确性后，如果需要改进性能，再考虑用少量的低级语言去重写核心部分。例如某些语言可能不擅长处理位操作，此时将这部分直接翻译成汇编是不错的选择&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;4-总结&quot;&gt;&lt;a href=&quot;#4-总结&quot; class=&quot;headerlink&quot; title=&quot;4. 总结&quot;&gt;&lt;/a&gt;4. 总结&lt;/h1&gt;&lt;p&gt;研究表明，任何特定优化的效果实际上都不可预测：每一步代码调整所产生的影响都受制于编程语言、编译器、编译器的版本、代码&lt;br&gt;库、库版本以及编译器设置等各种因素。此外，代码调整无可避免地为性能改善的良好愿望而付出复杂性、可读性、简单性、可维护性方面的代价。由于每一次调整后需要对性能进行重新评估，代码调整还引入了巨额的管理维护开销。&lt;/p&gt;
&lt;p&gt;进行代码调整时，应该恪守“对每一次的改进进行量化”的准则。如果某项优化非常重要，值得为它付出剖析和对优化效果进行量化测量的代价，那么只要优化有效，我们还是可以去做的。&lt;/p&gt;
&lt;p&gt;参考文献：电子工业出版社《代码大全（第2版）》第25、26章&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;本文首先概述了程序运行性能应该考虑的一些问题，然后从策略上和技术上两个方面来探讨代码性能的调整问题。技术上的代码调整并没有什么万金油的方法，也不是灵丹妙药，唯一可以信赖的法则就是每次都应当在具体的环境下评估代码调整所带来的效果，而本文所列的调整方法则仅供参考。此外，追求性能的背后往往伴随着牺牲程序的可读性和可维护性，而&lt;strong&gt;在很多情况下，代码的可读性和可维护性都要比运行速度或资源占用更为重要。&lt;/strong&gt;因此在调整代码时一定要考虑这样的性能提升是否真的必要。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="综合" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/"/>
    
      <category term="软件工程" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="软件构建" scheme="http://raytaylorlin.com/tags/%E8%BD%AF%E4%BB%B6%E6%9E%84%E5%BB%BA/"/>
    
      <category term="软件工程" scheme="http://raytaylorlin.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="代码大全" scheme="http://raytaylorlin.com/tags/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>软件构建（十）——测试与重构</title>
    <link href="http://raytaylorlin.com/tech/complex/software/software-construction-10/"/>
    <id>http://raytaylorlin.com/tech/complex/software/software-construction-10/</id>
    <published>2016-04-29T08:19:39.000Z</published>
    <updated>2016-05-12T13:14:44.045Z</updated>
    
    <content type="html">&lt;p&gt;测试可以由开发人员或专门的测试人员进行。按层级分，测试可以分为单元测试、组件测试、继承测试、回归测试、系统测试；按是否了解对象内部工作机制分，测试可以分为黑盒测试和白盒测试。本文关注的是开发人员所进行的白盒测试。重构是“在不改变软件外部行为的前提下，对其内部结构进行改变，使之更容易理解并便于修改”的过程。本文将讲述软件演化以及重构的一些理念。&lt;/p&gt;
&lt;p&gt;测试和重构都是非常大的话题，大到足以各用一本经典著作来阐述，如&lt;a href=&quot;https://book.douban.com/subject/1801050/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《软件测试》&lt;/a&gt;和&lt;a href=&quot;https://book.douban.com/subject/4262627/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《重构：改善既有代码的设计》&lt;/a&gt;。因此本文也仅是记录一些要点，如果要深入了解，还是要阅读相关的书籍为好。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-开发者测试&quot;&gt;&lt;a href=&quot;#1-开发者测试&quot; class=&quot;headerlink&quot; title=&quot;1. 开发者测试&quot;&gt;&lt;/a&gt;1. 开发者测试&lt;/h1&gt;&lt;h2 id=&quot;1-1-开发者测试在软件质量中的角色&quot;&gt;&lt;a href=&quot;#1-1-开发者测试在软件质量中的角色&quot; class=&quot;headerlink&quot; title=&quot;1.1 开发者测试在软件质量中的角色&quot;&gt;&lt;/a&gt;1.1 开发者测试在软件质量中的角色&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;测试的目标是找出错误，与其他开发活动背道而驰&lt;/li&gt;
&lt;li&gt;测试永远不可能彻底证明程序中没有错误&lt;/li&gt;
&lt;li&gt;测试本身并不能改善软件的质量，只能用来指示&lt;/li&gt;
&lt;li&gt;测试时要求你假设会在代码里面找到错误&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根据项目大小和复杂程度的不同，开发者测试应该占整个项目时间的8%~25%。测试得出的结果，可以用来评估产品的可靠性，并指导对软件的修正。&lt;/p&gt;
&lt;h2 id=&quot;1-2-推荐方法&quot;&gt;&lt;a href=&quot;#1-2-推荐方法&quot; class=&quot;headerlink&quot; title=&quot;1.2 推荐方法&quot;&gt;&lt;/a&gt;1.2 推荐方法&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;对每一项相关的需求进行测试，以确保需求都已经被实现：最好在需求阶段就计划好这一部分的测试用例，并注意测试安全级别、数据存储、安装过程及系统可靠性等这些厂被忽略的测试点&lt;/li&gt;
&lt;li&gt;对每一项相关的设计关注点进行测试，以确保设计已经被实现&lt;/li&gt;
&lt;li&gt;使用一个检查表，其中记录着你在本项目迄今为止所犯的，以及在过去的项目中所犯的错误类型&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;推荐先写测试用例再写代码&lt;/strong&gt;：可以更早地把需求问题暴露出来，迫使你写代码前思考一下设计，并更早地发现代码中的缺陷&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1-2-1-结构化基础测试&quot;&gt;&lt;a href=&quot;#1-2-1-结构化基础测试&quot; class=&quot;headerlink&quot; title=&quot;1.2.1 结构化基础测试&quot;&gt;&lt;/a&gt;1.2.1 结构化基础测试&lt;/h3&gt;&lt;p&gt;一个子程序所需的测试用例的&lt;strong&gt;最少数量&lt;/strong&gt;可以用下面的简单方法计算：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对通过子程序的直路，开始的时候记1&lt;/li&gt;
&lt;li&gt;遇到if、while、repeat、for、and以及or关键字或者其等价物时，加1&lt;/li&gt;
&lt;li&gt;遇到每一个case语句就加1，如果case语句没有缺省情况，则再加1&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;假设一个子程序有5个if或for语句，那么至少需要6个测试用例，其中1个测试所有布尔条件都为真的正常情况，其余5个测试每一种假的情况。不过，结构化基础测试能够向你保证所有的代码都得到执行，但它并不能说明数据的变化情况。&lt;/p&gt;
&lt;h3 id=&quot;1-2-2-数据流测试&quot;&gt;&lt;a href=&quot;#1-2-2-数据流测试&quot; class=&quot;headerlink&quot; title=&quot;1.2.2 数据流测试&quot;&gt;&lt;/a&gt;1.2.2 数据流测试&lt;/h3&gt;&lt;p&gt;编写数据流测试用例的关键是要对所有可能的&lt;strong&gt;定义-使用&lt;/strong&gt;路径进行测试，即对每一个变量测试所有在某处定义而在另一处使用的组合。因此添加完整的“己定义-已使用”所需的用例可以覆盖到结构化基础测试所覆盖不到的情况。&lt;/p&gt;
&lt;h3 id=&quot;1-2-3-其他测试建议&quot;&gt;&lt;a href=&quot;#1-2-3-其他测试建议&quot; class=&quot;headerlink&quot; title=&quot;1.2.3 其他测试建议&quot;&gt;&lt;/a&gt;1.2.3 其他测试建议&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;猜测错误：猜测程序会在哪里出错的基础之上建立测试用例，通常基于直觉或者过去的经验&lt;/li&gt;
&lt;li&gt;边界值分析：除了分析边界点、允许的最大最小值之外，还应该注意多个变量互相关联时的边界&lt;/li&gt;
&lt;li&gt;测试几类坏数据：数据太少（没有数据），数据太多，无效数据，长度错误的数据，未初始化的数据&lt;/li&gt;
&lt;li&gt;测试几类好数据：正常的情形（所期望的值），最小和最大的正常情况，与旧数据的兼容性&lt;/li&gt;
&lt;li&gt;采用容易手工检查的测试用例&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-3-改善测试过程&quot;&gt;&lt;a href=&quot;#1-3-改善测试过程&quot; class=&quot;headerlink&quot; title=&quot;1.3 改善测试过程&quot;&gt;&lt;/a&gt;1.3 改善测试过程&lt;/h2&gt;&lt;h3 id=&quot;1-3-1-测试支持工具&quot;&gt;&lt;a href=&quot;#1-3-1-测试支持工具&quot; class=&quot;headerlink&quot; title=&quot;1.3.1 测试支持工具&quot;&gt;&lt;/a&gt;1.3.1 测试支持工具&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;为测试各个类构造脚手架：使用“模仿对象（mock object）”或“桩函数（stub routine）”来模拟测试&lt;/li&gt;
&lt;li&gt;Diff工具：将程序输出重定向到一个文件，并与预计输出文件作比较&lt;/li&gt;
&lt;li&gt;测试数据生成器：正确设计的随机数据生成器可以产生不寻常的测试数据组合，并且比手工构造数据更能彻底对程序进行测试&lt;/li&gt;
&lt;li&gt;覆盖率监视器：跟踪哪些代码己经测试过了，而哪些代码还没有&lt;/li&gt;
&lt;li&gt;数据记录器/日志记录器：监视程序，并在错误发生的时候为收集程序状态信息；另外可考虑编写自己的数据记录工具，并编译进开发版本中&lt;/li&gt;
&lt;li&gt;符号调试器：对代码进行单步调试，跟踪变量的值等等调试手段，可以作为测试和走查代码的辅助手段&lt;/li&gt;
&lt;li&gt;系统干扰器：这类工具有内存填充、内存抖动、选择性内存失败（模拟内存不足的情况）、内存访问边界检查（监视指针操作）等系统功能&lt;/li&gt;
&lt;li&gt;错误数据库：用于存放以往的错误，以便检查重复出现的错误&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1-3-2-改善测试过程&quot;&gt;&lt;a href=&quot;#1-3-2-改善测试过程&quot; class=&quot;headerlink&quot; title=&quot;1.3.2 改善测试过程&quot;&gt;&lt;/a&gt;1.3.2 改善测试过程&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;有计划的测试：就重要性而言，测试应该于设计和编码平起平坐，这就要求项目重视测试并保障这一过程的质量&lt;/li&gt;
&lt;li&gt;回归测试：要保证每次回归测试都&lt;strong&gt;使用相同的测试用例&lt;/strong&gt;，随着产品的不断发展，会添加新的测试用例，但仍应保留旧的用例&lt;/li&gt;
&lt;li&gt;自动化测试：管理回归测试唯一可行的方法，就是将其变成一个自动化的过程&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1-3-3-保留测试记录&quot;&gt;&lt;a href=&quot;#1-3-3-保留测试记录&quot; class=&quot;headerlink&quot; title=&quot;1.3.3 保留测试记录&quot;&gt;&lt;/a&gt;1.3.3 保留测试记录&lt;/h3&gt;&lt;p&gt;为了确定所做的修改对整个项目的影响，通常可以收集这些数据以供参考：缺陷的管理方面描述（报告日期、人员、描述、修正错误日期等等），问题的完整描述，复现错误所需要的步骤，绕过该问题的建议，相关的缺陷，问题的严重程度，缺陷根源（需求、设计、编码还是测试），对编码缺陷的分类，修正错误所改变的类和子程序，缺陷所影响的代码行数，查找该错误所花的小时数，修正错误所花费的小时数等等。&lt;/p&gt;
&lt;h1 id=&quot;2-重构&quot;&gt;&lt;a href=&quot;#2-重构&quot; class=&quot;headerlink&quot; title=&quot;2. 重构&quot;&gt;&lt;/a&gt;2. 重构&lt;/h1&gt;&lt;h2 id=&quot;2-1-软件的演化与重构&quot;&gt;&lt;a href=&quot;#2-1-软件的演化与重构&quot; class=&quot;headerlink&quot; title=&quot;2.1 软件的演化与重构&quot;&gt;&lt;/a&gt;2.1 软件的演化与重构&lt;/h2&gt;&lt;p&gt;软件演化就像生物进化一样，有些突变对物种是有益的，另外一些则是有害的。区分软件演化类型的关键，就是程序的质量在这一过程中是提高了还是降低了；第二个标准是演化是源于程序构建过程还是维护过程中的修改，毕竟构建时由最初开发人员完成，没有什么修正压力，而维护时的修改则需要面对已发布产品和用户的压力。&lt;/p&gt;
&lt;p&gt;软件演化是无法避免且具有重要意义的现象。&lt;strong&gt;当你有机会或迫不得已需要对代码进行改变时，就努力对代码进行改进（重构），这样未来在开发中调整就会更容易。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;重构的理由有许多，如代码重复，冗长的子程序，过长或嵌套过深的循环，内聚性太差的类等等。无论是哪种情况，代码都会有一些警告信号，这就是所谓的代码的“坏味道”。关于重构的更详尽的理由在专门讲重构的书都列得非常清楚，此处不再赘述。&lt;/p&gt;
&lt;h2 id=&quot;2-2-各层级的重构&quot;&gt;&lt;a href=&quot;#2-2-各层级的重构&quot; class=&quot;headerlink&quot; title=&quot;2.2 各层级的重构&quot;&gt;&lt;/a&gt;2.2 各层级的重构&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;数据级&lt;ul&gt;
&lt;li&gt;用具名常量替代神秘数值&lt;/li&gt;
&lt;li&gt;使变量的名字更为清晰且传递更多信息&lt;/li&gt;
&lt;li&gt;用函数来代替表达式&lt;/li&gt;
&lt;li&gt;用多个单一用途变量代替某个多用途变量&lt;/li&gt;
&lt;li&gt;将一组类型码转化为类或枚举类型&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;语句级&lt;ul&gt;
&lt;li&gt;将复杂布尔表达式转换成命名准确的布尔函数&lt;/li&gt;
&lt;li&gt;合并条件语句不同部分中的重复代码片段&lt;/li&gt;
&lt;li&gt;使用break或return而不是循环控制变量&lt;/li&gt;
&lt;li&gt;在嵌套的if-else语句中一旦知道答案就立即返回，而不是去赋一个返回值&lt;/li&gt;
&lt;li&gt;用多态来替代条件语句（尤其是重复的case语句）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;子程序级&lt;ul&gt;
&lt;li&gt;将冗长的子程序转换为类&lt;/li&gt;
&lt;li&gt;将查询操作从修改操作中独立出来&lt;/li&gt;
&lt;li&gt;合并相似的子程序，通过参数区分它们的功能&lt;/li&gt;
&lt;li&gt;简化或去除无用的参数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;类实现&lt;ul&gt;
&lt;li&gt;如果一组派生类的差别仅仅是虚函数返回的常量不同，应用数据初始化替代虚函数&lt;/li&gt;
&lt;li&gt;整理成员函数或成员数据的位置&lt;/li&gt;
&lt;li&gt;将特殊代码提取为派生类，将相似的代码结合起来放置到基类中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;类接口&lt;ul&gt;
&lt;li&gt;将包含多个不同功能的类进行拆分&lt;/li&gt;
&lt;li&gt;删除无所事事的类&lt;/li&gt;
&lt;li&gt;去除多余的中间者调用&lt;/li&gt;
&lt;li&gt;对暴露在外的成员变量进行封装&lt;/li&gt;
&lt;li&gt;对于不能修改的类成员，删除相关的Set()成员函数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;系统级&lt;ul&gt;
&lt;li&gt;为无法控制的数据创建明确的索引源：例如GUI控件中维护的数据无法方便或一致地访问，可以创建一个类来映射其中的数据，并将此类作为该数据的明确来源&lt;/li&gt;
&lt;li&gt;基于类型码创建对象时，用工厂模式而不是简单地实例化对象&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-3-安全重构的方法&quot;&gt;&lt;a href=&quot;#2-3-安全重构的方法&quot; class=&quot;headerlink&quot; title=&quot;2.3 安全重构的方法&quot;&gt;&lt;/a&gt;2.3 安全重构的方法&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;在开始重构之前，保存初始代码&lt;/li&gt;
&lt;li&gt;缩小重构的步伐，不要一次性大动干戈&lt;/li&gt;
&lt;li&gt;同一时间只做一项重构&lt;/li&gt;
&lt;li&gt;把要做的事情列出来，并记录下在重构过程中发现的需要进行的另外一项重构任务&lt;/li&gt;
&lt;li&gt;增加测试用例，重构完后重新测试&lt;/li&gt;
&lt;li&gt;根据重构风险级别来调整重构方法：如果是高风险的重构，务必做好测试工作，请其他人来检查重构工作甚至采用结对编程&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;重构是一剂良药，但也有被滥用的可能性，因此&lt;strong&gt;不要把重构当做先写后改的代名词&lt;/strong&gt;，也要&lt;strong&gt;避免用重构代替重写&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;关于重构的时机，如果拿捏不准，可以考虑这些建议：在增加子程序和类，在修补缺陷的时候进行重构；关注易于出错和高度复杂的模块；在维护环境下改善你手中正在处理的代码；定义清楚干净代码和拙劣代码之间的边界，然后尝试把代码一部分一部分移到理想的一边。&lt;/p&gt;
&lt;p&gt;参考文献：电子工业出版社《代码大全（第2版）》第22、24章&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;测试可以由开发人员或专门的测试人员进行。按层级分，测试可以分为单元测试、组件测试、继承测试、回归测试、系统测试；按是否了解对象内部工作机制分，测试可以分为黑盒测试和白盒测试。本文关注的是开发人员所进行的白盒测试。重构是“在不改变软件外部行为的前提下，对其内部结构进行改变，使之更容易理解并便于修改”的过程。本文将讲述软件演化以及重构的一些理念。&lt;/p&gt;
&lt;p&gt;测试和重构都是非常大的话题，大到足以各用一本经典著作来阐述，如&lt;a href=&quot;https://book.douban.com/subject/1801050/&quot;&gt;《软件测试》&lt;/a&gt;和&lt;a href=&quot;https://book.douban.com/subject/4262627/&quot;&gt;《重构：改善既有代码的设计》&lt;/a&gt;。因此本文也仅是记录一些要点，如果要深入了解，还是要阅读相关的书籍为好。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="综合" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/"/>
    
      <category term="软件工程" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="软件构建" scheme="http://raytaylorlin.com/tags/%E8%BD%AF%E4%BB%B6%E6%9E%84%E5%BB%BA/"/>
    
      <category term="软件工程" scheme="http://raytaylorlin.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="代码大全" scheme="http://raytaylorlin.com/tags/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>软件构建（九）——协同构建与调试</title>
    <link href="http://raytaylorlin.com/tech/complex/software/software-construction-9/"/>
    <id>http://raytaylorlin.com/tech/complex/software/software-construction-9/</id>
    <published>2016-04-26T04:59:05.000Z</published>
    <updated>2016-05-12T13:14:41.223Z</updated>
    
    <content type="html">&lt;p&gt;所有的协同构建技术都试图通过这样或那样的途径，将展示你工作的过程正式化，以便把错误暴露出来。软件构建不可避免地都会伴随着调试，在一些项目中，调试可能占到整个开发周期的50%。对很多程序员来说，调试是程序设计中最为困难的部分。本文的前半部分将介绍协同构建的一些实践方法，后半部分将介绍一些科学的调试手段以节省更多精力。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-协同构建&quot;&gt;&lt;a href=&quot;#1-协同构建&quot; class=&quot;headerlink&quot; title=&quot;1. 协同构建&quot;&gt;&lt;/a&gt;1. 协同构建&lt;/h1&gt;&lt;h2 id=&quot;1-1-协同开发实践概要&quot;&gt;&lt;a href=&quot;#1-1-协同开发实践概要&quot; class=&quot;headerlink&quot; title=&quot;1.1 协同开发实践概要&quot;&gt;&lt;/a&gt;1.1 协同开发实践概要&lt;/h2&gt;&lt;p&gt;“协同构建”包括结对编程、正式检查、非正式技术复查、文档阅读，以及其他让开发人员共同承担创建代码及其他工作产品责任的技术。各种协同构建技术之间尽管存在着一些差异，但它们都基于一个相同的思想，那就是在工作中开发人员总会对某些错误点视而不见，而其他人不会有相同的盲点，所以开发人员让其他人来检查自己的工作是很有好处的。&lt;/p&gt;
&lt;p&gt;大量研究和数据表明，协同开发在捕获错误方面比测试的效能更高，而且让人们意识到他们的工作会被复查，这样他们会小心谨慎地检查自己的工作。此外，协同构建有利于传授公司文化以及编程专业知识，复查是老人培养新人人以提高其代码质量的好方法。&lt;/p&gt;
&lt;h2 id=&quot;1-2-结对编程&quot;&gt;&lt;a href=&quot;#1-2-结对编程&quot; class=&quot;headerlink&quot; title=&quot;1.2 结对编程&quot;&gt;&lt;/a&gt;1.2 结对编程&lt;/h2&gt;&lt;p&gt;在进行结对编程的时候，一位程序员敲代码，另外一位注意有没有出现错误，并考虑某些策略性的问题，例如代码的编写是否正确，正在编写的代码是否所需等。全程采用结对编程的成本可能比单人开发要高大约10%~25%，但开发周期大概会缩短45%。结对编程与单独开发相比，能够使人们在压力之下保持更好的状态，能够改善代码质量，缩短进度时间表等等。要从结对编程中获益，需要遵守以下几条准则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用编码规范来支持结对编程：应提前制定标准，避免两个人把时间浪费在争论代码风格上&lt;/li&gt;
&lt;li&gt;不要让结对编程变成旁观：不掌握键盘的那个人应该主动参与到编程当中，例如分析代码，提前思考接下来的代码应该做些什么，对设计进行评估，并对如何测试代码做出计划&lt;/li&gt;
&lt;li&gt;不要强迫在简单的问题上使用结对编程&lt;/li&gt;
&lt;li&gt;有规律地对结对人员和分配的工作任务进行轮换&lt;/li&gt;
&lt;li&gt;鼓励双方跟上对方的步伐&lt;/li&gt;
&lt;li&gt;确认两个人都能够看清楚显示器中的代码&lt;/li&gt;
&lt;li&gt;不要强迫程序员与自己关系紧张的人结对&lt;/li&gt;
&lt;li&gt;避免新手组合&lt;/li&gt;
&lt;li&gt;指定一个协调工作分配的组长，其对结果和项目外其他人的联系负责&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-3-正式检查&quot;&gt;&lt;a href=&quot;#1-3-正式检查&quot; class=&quot;headerlink&quot; title=&quot;1.3 正式检查&quot;&gt;&lt;/a&gt;1.3 正式检查&lt;/h2&gt;&lt;p&gt;正式检查（详查）是一种特殊的复查，与普通复查的区别是：详查关注的是复查者过去所遇到的问题，专注于缺陷的检测而非修正；复查人员要为详查会议做好预先准备，并且带来一份他们所发现的己知问题的列表；详查的主持人不是被检查产品的作者，且应该已经接受过主持详查会议方面的培训；只有在参与者都做好充分准备之后才会召开详查会议，每个参与者都赋予了明确的角色（主持人、代码作者、详查评论员、记录员、只了解结果的经理）；每次详查所收集的数据都会被应用到以后的详查当中，以便对详查进行改进；高层管理人员不参加详查会议，除非你们正在详查一个项目的计划，或者其他管理方面的资料，但技术负责人可能参加。&lt;/p&gt;
&lt;p&gt;详查由以下几个阶段组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;计划：作者提交设计或代码，主持人决定参与的人员和时间地点&lt;/li&gt;
&lt;li&gt;概述：当评论员不熟悉他们所要详查的项目时，作者可以花大约一个小时来描述一下这些设计或代码的技术背景&lt;/li&gt;
&lt;li&gt;准备：每一个评论员独立地对设计或者代码进行详查，找出其中的错误。给评论员赋予特定视角或待详查场景，可以有效提高复查的效率&lt;/li&gt;
&lt;li&gt;详查会议：评论员阐述设计或阅读代码，记录员记录发现的错误。不要在开会的过程当中讨论解决方案，小组应该把注意力保持在识别缺陷上。详查速度，可以参考系统级代码每小时90行，应用级代码每小时500行&lt;/li&gt;
&lt;li&gt;详查报告：主持人总结报告，列出每个缺陷及其类型和严重级别&lt;/li&gt;
&lt;li&gt;返工：主持人将缺陷分配给作者修复&lt;/li&gt;
&lt;li&gt;跟进：主持人负责监督在详查过程中分配的返工任务&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于作者来说，详查的过程应该是正面的，所有参与者都是一个学习的过程。作者也应该预料到他会听到对某些缺陷的批评，不应该试图为正在被检查的工作辩护，在复查之后，作者可以独自对每一个问题进行思考，判断它是否真的是一个缺陷。&lt;/p&gt;
&lt;h2 id=&quot;1-4-走查&quot;&gt;&lt;a href=&quot;#1-4-走查&quot; class=&quot;headerlink&quot; title=&quot;1.4 走查&quot;&gt;&lt;/a&gt;1.4 走查&lt;/h2&gt;&lt;p&gt;走查是一种很流行的&lt;strong&gt;非正式&lt;/strong&gt;复查方式，同时也是一种宽松的定义。既然是一种较为“随意”的复查形式，其找出程序的错误概率也相对较低，而当项目的压力增加的时候，走查更是变得几乎不可能。与走查相比，详查在消除错误方面似乎更有效。但如果你有个很大的复查团队，或者由其他组织的评审员参与，或许走查会更适合。&lt;/p&gt;
&lt;h1 id=&quot;2-调试&quot;&gt;&lt;a href=&quot;#2-调试&quot; class=&quot;headerlink&quot; title=&quot;2. 调试&quot;&gt;&lt;/a&gt;2. 调试&lt;/h1&gt;&lt;p&gt;调试本身并不是改进代码质量的方法，而是诊断代码缺陷的一种方法。软件的质量必须从开始逐步建立：开发高质量软件产品的最佳途径是精确描述需求，完善设计，并使用高质量的代码编写规范。&lt;strong&gt;调试只是迫不得已时采用的手段。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;程序不可能没有缺陷，关键是掌握避免缺陷产生的方法，并从以往的缺陷中学习。程序员在调试过程中应该理解正在编写的程序，明确犯了哪种类型的错误，从代码阅读者的角度分析代码质量，审视自己解决问题和修正缺陷的方法。&lt;/p&gt;
&lt;h2 id=&quot;2-1-效率低下的调试万法&quot;&gt;&lt;a href=&quot;#2-1-效率低下的调试万法&quot; class=&quot;headerlink&quot; title=&quot;2.1 效率低下的调试万法&quot;&gt;&lt;/a&gt;2.1 效率低下的调试万法&lt;/h2&gt;&lt;p&gt;下面列举的是调试的魔鬼指南，注意这些是&lt;strong&gt;让程序员们受尽折磨的传统的调试方法，应该引以为戒&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;凭猜测找出缺陷：把print语句随机地散布在程序中，凭输出来确定缺陷到底在哪里。如果通过print语句还是不能找到缺陷，那就在程序中修改点什么，知道有些东西好像能干活了&lt;/li&gt;
&lt;li&gt;不要把时间浪费在理解问题上：要解决它们并不需要彻底弄懂程序，只要找出问题就行了&lt;/li&gt;
&lt;li&gt;用最唾手可得的方式修正错误&lt;/li&gt;
&lt;li&gt;迷信式调试：也许你会遇到这样一种程序员，他们经常碰到各种奇怪问题——不听话的机器，奇怪的编译器错误，月圆时才会出现的编程语言的隐藏缺陷，失效的数据……&lt;strong&gt;要知道，如果你写的程序出了问题，那就是你的原因，不是计算机的&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-2-科学的调试方法&quot;&gt;&lt;a href=&quot;#2-2-科学的调试方法&quot; class=&quot;headerlink&quot; title=&quot;2.2 科学的调试方法&quot;&gt;&lt;/a&gt;2.2 科学的调试方法&lt;/h2&gt;&lt;p&gt;下面给出一种寻找缺陷的有效方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将错误状态稳定下来&lt;/li&gt;
&lt;li&gt;确定错误的来源&lt;br&gt; a. 收集产生缺陷的相关数据&lt;br&gt; b. 分析所收集的数据，并构造对缺陷的假设&lt;br&gt; c. 确定怎样去证实或证伪这个假设，可以对程序进行测试或是通过检查代码&lt;br&gt; d. 按照2(c)确定的方法对假设做出最终结论&lt;/li&gt;
&lt;li&gt;修补缺陷&lt;/li&gt;
&lt;li&gt;对所修补的地方进行测试&lt;/li&gt;
&lt;li&gt;查找是否还有类似的错误&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果一个错误无法重现，这通常会是一个变量初始化错误，或者是一个同时间有关的问题，或者是悬空指针问题。要将一个错误的发生稳定下来，要构造一个尽可能简单的测试用例，并假定一些产生错误的因素，用测试用例一个一个排除掉无关的因素，不断缩小错误因素的范围。一些寻找错误的小建议：在构造假设时考虑所有的可用数据，提炼产生错误的测试用例，采用多种不同的方法重现错误，用更多的数据生成更多的假设，将代码分而治之缩小嫌疑代码的范围，对之前出现过缺陷的代码和最近修改过的代码保持警惕。&lt;/p&gt;
&lt;p&gt;在必要时，也可以采用蛮力调试。人们往往出于投机心理都宁愿去用一种有可能在五分钟内发现缺陷的高风险方法，也不愿意为某种保证能找出缺陷的方法花上半个小时。实际上当你被这种心理绕进去时，有可能几个小时甚至几天就这样浪费了。如果打算通过捷径摘取胜利果实，那么应该为尝试捷径的时间设置一个上限。&lt;strong&gt;如果耗时超过了上限，就应老老实实地承认问题比你最初想象的要更加难于分析，应该转到蛮力（彻查代码甚至重写）的路上重新开始。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于语法错误，虽然编译器现在做得越来越好，这个问题不应成为一个很大的障碍，但也应该注意一些编译器的坑，例如：不要过分信任编译器信息中的行号，有时问题可能出在那一行的前后；不要迷信编译器给出的错误信息；不要轻信编译器的第二条信息，如果无法迅速找出第二条或第三条错误信息的源头，先把第一条处理了再重新编译看看。&lt;/p&gt;
&lt;h2 id=&quot;2-3-修正缺陷&quot;&gt;&lt;a href=&quot;#2-3-修正缺陷&quot; class=&quot;headerlink&quot; title=&quot;2.3 修正缺陷&quot;&gt;&lt;/a&gt;2.3 修正缺陷&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;在动手之前先要真正理解问题&lt;/li&gt;
&lt;li&gt;理解程序本身，而不仅仅是问题&lt;/li&gt;
&lt;li&gt;花点时间编写测试用例，验证对错误的假设&lt;/li&gt;
&lt;li&gt;修改错误后不要急着提交，可以先放松一下，等到充分考虑了这样的修改完全无误后再提交&lt;/li&gt;
&lt;li&gt;保存最初的源代码，以方便对照&lt;/li&gt;
&lt;li&gt;治本，而不是治标，不要用特例去绕过程序的错误&lt;/li&gt;
&lt;li&gt;修改代码时一定要有恰当的理由&lt;/li&gt;
&lt;li&gt;一次只做一个改动&lt;/li&gt;
&lt;li&gt;检查自己的改动并增加能暴露问题的单元测试&lt;/li&gt;
&lt;li&gt;修正缺陷后，搜索类似的缺陷&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-4-调试工具简介&quot;&gt;&lt;a href=&quot;#2-4-调试工具简介&quot; class=&quot;headerlink&quot; title=&quot;2.4 调试工具简介&quot;&gt;&lt;/a&gt;2.4 调试工具简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;源代码比较工具：如&lt;a href=&quot;http://linux.die.net/man/1/diff&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;diff&lt;/a&gt;、&lt;a href=&quot;http://www.scootersoftware.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Beyond Compare&lt;/a&gt;等，常用于比较新旧代码的差异以唤醒记忆&lt;/li&gt;
&lt;li&gt;编译器&lt;ul&gt;
&lt;li&gt;将编译器的警告级别设置为最高级，尽可能不放过任何一个警告&lt;/li&gt;
&lt;li&gt;用对待错误的态度来处理警告：一些编译器允许将警告当做错误报告&lt;/li&gt;
&lt;li&gt;在项目组范围内使用统一的编译设置&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;增强的语法检查和逻辑检查：如各种语言的lint工具（一般许多高级的编辑器都有对应插件）&lt;/li&gt;
&lt;li&gt;性能分析器：有时花上几分钟来研究某个程序的性能分析结果，或许可以让你发现一些令人惊奇的隐藏错误&lt;/li&gt;
&lt;li&gt;测试框架/脚手架：各种语言都有对应的测试框架&lt;/li&gt;
&lt;li&gt;调试器：利用好编译器可能具有的以下功能：&lt;ul&gt;
&lt;li&gt;设置断点，某行代码执行n次或变量被赋予特定值时中断，监控变量，逐行运行代码，记录特定语句的执行&lt;/li&gt;
&lt;li&gt;检查结构化和动态分配的数据，智能地适应用户定义的数据类型，在运行过程中修改值并继续运行&lt;/li&gt;
&lt;li&gt;查看高级语言生成的汇编代码，查看调用链&lt;/li&gt;
&lt;li&gt;针对每个单独的程序保存调试参数（如断点、监视变量等）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考文献：电子工业出版社《代码大全（第2版）》第21、23章&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;所有的协同构建技术都试图通过这样或那样的途径，将展示你工作的过程正式化，以便把错误暴露出来。软件构建不可避免地都会伴随着调试，在一些项目中，调试可能占到整个开发周期的50%。对很多程序员来说，调试是程序设计中最为困难的部分。本文的前半部分将介绍协同构建的一些实践方法，后半部分将介绍一些科学的调试手段以节省更多精力。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="综合" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/"/>
    
      <category term="软件工程" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="软件构建" scheme="http://raytaylorlin.com/tags/%E8%BD%AF%E4%BB%B6%E6%9E%84%E5%BB%BA/"/>
    
      <category term="软件工程" scheme="http://raytaylorlin.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="代码大全" scheme="http://raytaylorlin.com/tags/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>软件构建（八）——表驱动法与一般控制问题</title>
    <link href="http://raytaylorlin.com/tech/complex/software/software-construction-8/"/>
    <id>http://raytaylorlin.com/tech/complex/software/software-construction-8/</id>
    <published>2016-04-24T14:24:03.000Z</published>
    <updated>2016-05-12T13:14:38.160Z</updated>
    
    <content type="html">&lt;p&gt;表驱动法是一种编程模式——从表里面查找信息而不使用逻辑语句（if和case）。事实上，凡是能通过逻辑语句来选择的事物，都可以通过查表来选择。本文将介绍直接访问表、索引访问表和阶梯访问表三种常见的表驱动法。最后，本文将记录一些控制问题（如布尔表达式的使用、空语句、深层嵌套问题等等）上的使用原则，这一部分内容比较简单而且与前面的章节有一些重叠，因此将快速带过。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-表驱动法&quot;&gt;&lt;a href=&quot;#1-表驱动法&quot; class=&quot;headerlink&quot; title=&quot;1. 表驱动法&quot;&gt;&lt;/a&gt;1. 表驱动法&lt;/h1&gt;&lt;p&gt;例如当使用复杂的if-elseif逻辑对字符分类时，可以用一个查询表（数组或字典）来代替查询，当然，查询表要事先创建好。&lt;/p&gt;
&lt;h2 id=&quot;1-1-直接访问表&quot;&gt;&lt;a href=&quot;#1-1-直接访问表&quot; class=&quot;headerlink&quot; title=&quot;1.1 直接访问表&quot;&gt;&lt;/a&gt;1.1 直接访问表&lt;/h2&gt;&lt;p&gt;使用直接访问法的例子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个月中的天数：建立含12个整数的数组，把月份当下标查询&lt;/li&gt;
&lt;li&gt;保险费率：费率随年龄、性别、婚姻状况等变化，可以以这几个维度建立多维数组，从外部读入数据&lt;/li&gt;
&lt;li&gt;灵活的消息格式：假定一份文件中有几百条消息，消息种类约20种，每种消息都有若干字段。可以把消息种类构造为查询表，并把每种字段对应的行为用多态实现，这样可以大幅简化对消息种类和字段进行判断&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用直接访问法查表时，关键是能直接得到查询的键值。有时像保险费率中的年龄，可能小于18岁，18-65岁，超过65岁是三种不一样的费率，这时可以使用以下这些方法将其转换为可查询的键值：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;复制信息：查询表填充18个18岁以下的费率，47个18-65岁的费率，以此类推，缺点是复制的冗余会浪费空间，而且表中存在错误的可能性也会增加&lt;/li&gt;
&lt;li&gt;转换键值：将一个区间通过某个函数转换为一个值，例如&lt;code&gt;max(min(66, age), 17)&lt;/code&gt;可以生成一个位于17到66之间的键值，这种方法要精心设计转换函数&lt;/li&gt;
&lt;li&gt;把键值转换提取成独立子程序：上面的转换键值方法其实不太适用于年龄转换这种复杂情况，编写一个&lt;code&gt;KeyFromAge()&lt;/code&gt;方法里面写几个if判断将年龄转换为键值更加清晰&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-2-索引访问表&quot;&gt;&lt;a href=&quot;#1-2-索引访问表&quot; class=&quot;headerlink&quot; title=&quot;1.2 索引访问表&quot;&gt;&lt;/a&gt;1.2 索引访问表&lt;/h2&gt;&lt;p&gt;使用索引的时候，先用一个基本类型的数据从一张索引表中查出一个键值，然后再用这一键值查出你感兴趣的主数据。下图解释了这种技术的具体原理：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7d9rl0.com1.z0.glb.clouddn.com/image/software/%E7%B4%A2%E5%BC%95%E8%AE%BF%E9%97%AE%E8%A1%A8%E7%9A%84%E5%8E%9F%E7%90%86.jpg&quot; alt=&quot;索引访问表的原理&quot;&gt;&lt;/p&gt;
&lt;p&gt;索引访问技术有几个主要优点：首先，如果主查询表中的每一条记录都很大，那么创建一个浪费了很多空间的&lt;strong&gt;索引数组&lt;/strong&gt;所用的空间，就要比创建一个浪费了很多空间的&lt;strong&gt;主查询表&lt;/strong&gt;所用的空间小得多；其次，即使用了索引以后没有节省内存空间，操作位于索引中的记录有时也要比操作位于主表中的记录更方便廉价；最后，索引访问技术在可维护性上所具有的普遍优点，编写到表里面的数据比嵌入代码中的数据更容易维护。&lt;/p&gt;
&lt;h2 id=&quot;1-3-阶梯访问表&quot;&gt;&lt;a href=&quot;#1-3-阶梯访问表&quot; class=&quot;headerlink&quot; title=&quot;1.3 阶梯访问表&quot;&gt;&lt;/a&gt;1.3 阶梯访问表&lt;/h2&gt;&lt;p&gt;阶梯结构的基本想法是，表中的记录对于不同的数据范围有效，而不是对不同的数据点有效。最常见的例子是按分数段（浮点数）评定ABCDF等级。由于是浮点数划分范围，用数据转换函数或索引都不适合。为了使用阶梯方法，要把每一区间的上限写入一张表里，然后写一个循环，按照各区间的上限来检查分数，当分数第一次超过某个区间的上限时，就知道相应的等级了。除此之外，还可以将这种方法应用在概率分布的统计（这在游戏中的抽奖相当常见），这种无规则分布的数据是不可能用一个函数把它们整齐地转换成表键值的。使用阶梯访问表需要注意一些细节：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;留心端点：充分考虑每一个阶梯区间的上界，不要把&amp;lt;误用为&amp;lt;=&lt;/li&gt;
&lt;li&gt;考虑用“准”二分查找取代顺序查找&lt;/li&gt;
&lt;li&gt;考虑用索引访问采取代阶梯技术：如果执行速度很重要，应考虑用空间换时间的索引表技术&lt;/li&gt;
&lt;li&gt;把阶梯表查询操作提取成单独的子程序&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;2-一般控制问题&quot;&gt;&lt;a href=&quot;#2-一般控制问题&quot; class=&quot;headerlink&quot; title=&quot;2. 一般控制问题&quot;&gt;&lt;/a&gt;2. 一般控制问题&lt;/h1&gt;&lt;h2 id=&quot;2-1-布尔表达式的使用&quot;&gt;&lt;a href=&quot;#2-1-布尔表达式的使用&quot; class=&quot;headerlink&quot; title=&quot;2.1 布尔表达式的使用&quot;&gt;&lt;/a&gt;2.1 布尔表达式的使用&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;用true和false做布尔判断，而不要用0和1等数值&lt;/li&gt;
&lt;li&gt;隐式地比较布尔值：即使用&lt;code&gt;while (!done)&lt;/code&gt;而不要写成&lt;code&gt;while (done == false)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;简化复杂的表达式：可以通过拆分复杂的判断并引入新的布尔变量，把复杂的表达式提取成布尔函数，用决策表代替复杂的条件等方法&lt;/li&gt;
&lt;li&gt;编写肯定形式的布尔表达式：在变量命名上尽量采用肯定形式，if语句的布尔表达式尽量&lt;strong&gt;不用not形式&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;用&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%BE%B7%E6%91%A9%E6%A0%B9%E5%AE%9A%E5%BE%8B&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;德摩根定理&lt;/a&gt;简化否定的布尔判断&lt;/li&gt;
&lt;li&gt;用括号便布尔表达式更清晰&lt;/li&gt;
&lt;li&gt;理解布尔表达式是如何求值的：主要是要充分理解所用编程语言中&lt;strong&gt;“短路求值”&lt;/strong&gt;的用法&lt;/li&gt;
&lt;li&gt;按照数轴的顺序编写数值比较表达式&lt;/li&gt;
&lt;li&gt;与0比较时应该：隐式地比较逻辑变量，显式地把数字和0相比较，显式地把指针与NULL相比较，在C语言中显示地比较字符和&lt;code&gt;\0&lt;/code&gt;终止符&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-2-空语句&quot;&gt;&lt;a href=&quot;#2-2-空语句&quot; class=&quot;headerlink&quot; title=&quot;2.2 空语句&quot;&gt;&lt;/a&gt;2.2 空语句&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;万非得以使用空语句时，要突出这种用法：空语句并不多见，应该让其独占一行，加以缩进，用成对的花括号括住空语句以表强调&lt;/li&gt;
&lt;li&gt;为主语句创建一个DoNothing()预处理宏或者内联函数&lt;/li&gt;
&lt;li&gt;考虑如果换用一个非空的循环体，是否会让代码更清晰&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-3-深层嵌套问题&quot;&gt;&lt;a href=&quot;#2-3-深层嵌套问题&quot; class=&quot;headerlink&quot; title=&quot;2.3 深层嵌套问题&quot;&gt;&lt;/a&gt;2.3 深层嵌套问题&lt;/h2&gt;&lt;p&gt;过分深层的缩进（嵌套）是产生混乱代码的罪魁祸首之一。有研究表明，应避免使用超过3到4层的嵌套。下面给出一些用于避免深层嵌套的方法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过重复检测条件中的某一部分来简化嵌套的if语句&lt;/li&gt;
&lt;li&gt;在循环中用break块来简化嵌套if&lt;/li&gt;
&lt;li&gt;把嵌套if转换成一组if-else-if语句或case语句&lt;/li&gt;
&lt;li&gt;把深层嵌套的代码抽取出来放进单独的子程序&lt;/li&gt;
&lt;li&gt;对于复杂的case语句，可以考虑面向对象的手段来简化&lt;/li&gt;
&lt;li&gt;重新设计深层嵌套的代码&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-4-控制结构与复杂度&quot;&gt;&lt;a href=&quot;#2-4-控制结构与复杂度&quot; class=&quot;headerlink&quot; title=&quot;2.4 控制结构与复杂度&quot;&gt;&lt;/a&gt;2.4 控制结构与复杂度&lt;/h2&gt;&lt;p&gt;降低软件复杂度首先要知道如何度量复杂度，其中最著名的方法是计算子程序中“决策点”的数量：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从1开始，一直往下筒骨哦程序&lt;/li&gt;
&lt;li&gt;一旦遇到&lt;code&gt;if&lt;/code&gt;、&lt;code&gt;while&lt;/code&gt;、&lt;code&gt;repeat&lt;/code&gt;、&lt;code&gt;for&lt;/code&gt;、&lt;code&gt;and&lt;/code&gt;、&lt;code&gt;or&lt;/code&gt;这些关键字或同类的词，就加1&lt;/li&gt;
&lt;li&gt;给case语句中每一种情况都加1&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过下面的评分来分析子程序的复杂度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0-5：子程序可能还不错&lt;/li&gt;
&lt;li&gt;6-10：得想办法简化子程序了&lt;/li&gt;
&lt;li&gt;10+：把子程序的某一部分拆分成另一个子程序并调用它&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;把子程序的一部分提取成另一个子程序，不会降低整个程序的复杂度，只是把决策点移到其他地方。但是这样做可以降低你在同一时间必须关注的复杂度水平。由于重点是要降低你需要在头脑中同时考虑的项目的数量，所以降低一个给定子程序的复杂度是有价值的。10个决策点的上限并不是绝对的。应该把决策点的数量当作一个警示，该警示说明某个子程序可能需要重新设计了，不要死守决策点上限这个规则。&lt;/p&gt;
&lt;p&gt;参考文献：电子工业出版社《代码大全（第2版）》第18、19章&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;表驱动法是一种编程模式——从表里面查找信息而不使用逻辑语句（if和case）。事实上，凡是能通过逻辑语句来选择的事物，都可以通过查表来选择。本文将介绍直接访问表、索引访问表和阶梯访问表三种常见的表驱动法。最后，本文将记录一些控制问题（如布尔表达式的使用、空语句、深层嵌套问题等等）上的使用原则，这一部分内容比较简单而且与前面的章节有一些重叠，因此将快速带过。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="综合" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/"/>
    
      <category term="软件工程" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="软件构建" scheme="http://raytaylorlin.com/tags/%E8%BD%AF%E4%BB%B6%E6%9E%84%E5%BB%BA/"/>
    
      <category term="软件工程" scheme="http://raytaylorlin.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="代码大全" scheme="http://raytaylorlin.com/tags/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>软件构建（七）——防御式编程</title>
    <link href="http://raytaylorlin.com/tech/complex/software/software-construction-7/"/>
    <id>http://raytaylorlin.com/tech/complex/software/software-construction-7/</id>
    <published>2016-04-20T09:28:57.000Z</published>
    <updated>2016-05-12T13:14:34.788Z</updated>
    
    <content type="html">&lt;p&gt;防御式编程这一概念来自防御式驾驶。在防御式驾驶中要建立这样一种思维，那就是你永远也不能确定另一位司机将要做什么。这样才能确保在其他人做出危险动作时你也不会受到伤害。你要承担起保护自己的责任，哪怕是其他司机犯的错误。本文将讲述如何面对严酷的非法数据的世界、在遇到“绝不会发生”的事件以及其他程序员犯下的错误时保护你自己。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-防御式编程&quot;&gt;&lt;a href=&quot;#1-防御式编程&quot; class=&quot;headerlink&quot; title=&quot;1. 防御式编程&quot;&gt;&lt;/a&gt;1. 防御式编程&lt;/h1&gt;&lt;p&gt;防御式编程的主要思想是：子程序应该不因传入错误数据而被破坏，哪怕是由其他子程序产生的错误数据。更一般地说，其核心想法是要承认程序都会有问题，都需要被修改。防御式编码的最佳方式就是在一开始不要在代码中引入错误。使用途代式设计、编码前先写伪代码、写代码前先写测试用例、低层设计检查等活动，都有助于防止引入错误。因此，要在防御式编程之前优先运用这些技术。&lt;/p&gt;
&lt;h2 id=&quot;1-1-保护程序免遭非法输入数据的破坏&quot;&gt;&lt;a href=&quot;#1-1-保护程序免遭非法输入数据的破坏&quot; class=&quot;headerlink&quot; title=&quot;1.1 保护程序免遭非法输入数据的破坏&quot;&gt;&lt;/a&gt;1.1 保护程序免遭非法输入数据的破坏&lt;/h2&gt;&lt;p&gt;对已形成产品的软件而言，应该做到“垃圾进，什么都不出”、“进来垃圾，出去是出错提示”或“不许垃圾进来”。通常有三种方法来处理进来垃圾的情况。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;检查所有来源于外部的数据的值：检查从文件、用户、网络或其他外部接口中获取的数据&lt;/li&gt;
&lt;li&gt;检查子程序所有输入参数的值&lt;/li&gt;
&lt;li&gt;决定如何处理错误的输入数据&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-2-使用断言（assert）&quot;&gt;&lt;a href=&quot;#1-2-使用断言（assert）&quot; class=&quot;headerlink&quot; title=&quot;1.2 使用断言（assert）&quot;&gt;&lt;/a&gt;1.2 使用断言（assert）&lt;/h2&gt;&lt;p&gt;断言可以用于在代码中说明各种假定，澄清各种不希望的情形。但通常断言只是在开发阶段用于帮助查清相互矛盾的假定、预料之外的情况以及传给子程序的错误数据等。在生成产品代码时，不要把断言编译进目标代码，以免降低性能和让用户看到断言报错信息。下面是关于使用断言的一些指导性建议。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用错误处理代码来处理预期会发生的状况，用断言来处理绝不应该发生的状况&lt;/li&gt;
&lt;li&gt;避免把需要执行的代码放到断言中：断言只检查变量的值，而不要在断言中&lt;strong&gt;运行&lt;/strong&gt;函数&lt;/li&gt;
&lt;li&gt;用断言来注解并验证前条件和后条件：所谓前条件是子程序或类的调用方代码在调用子程序或实例化对象之前要确保为真的属性，后条件是子程序或类在执行结束后要确保为真的属性&lt;/li&gt;
&lt;li&gt;对于高健壮性的代码，应该先使用断言再处理错误&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-3-错误处理技术&quot;&gt;&lt;a href=&quot;#1-3-错误处理技术&quot; class=&quot;headerlink&quot; title=&quot;1.3 错误处理技术&quot;&gt;&lt;/a&gt;1.3 错误处理技术&lt;/h2&gt;&lt;p&gt;有很多种解决方案用于处理那些预料中可能要发生的错误，下面列举一些可用的方案，实际中还经常把这些技术集合起来使用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;返回中立值：遇到错误时继续执行操作并简单地返回一个没有危害的数值。但对于关键领域（如医疗、航天），关闭程序也比显示错误的数据要好&lt;/li&gt;
&lt;li&gt;换用下一个正确的数据：如读数据库时发现一条损坏的记录，则继续读下去直到找到一条正确记录为止&lt;/li&gt;
&lt;li&gt;返回与前次相同的数据：在前后变化不会太大的场景使用，如游戏重绘使用上一帧的图像&lt;/li&gt;
&lt;li&gt;换用最接近的合法值：如小于0的值用0代替&lt;/li&gt;
&lt;li&gt;把警告信息记录到日志文件中&lt;/li&gt;
&lt;li&gt;返回一个错误码：简单地报告有错误发生，并信任调用链上游的某个子程序会处理该错误&lt;/li&gt;
&lt;li&gt;调用全局的错误处理子程序或对象&lt;/li&gt;
&lt;li&gt;当错误发生时显示出错消息以提高用户体验：采用这种做法时要考虑模块划分，多语言化，还要小心不要告诉系统的潜在攻击者太多东西&lt;/li&gt;
&lt;li&gt;用最妥当的方式在局部处理错误&lt;/li&gt;
&lt;li&gt;关闭程序：适用于人身安全攸关的应用程序&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-4-异常&quot;&gt;&lt;a href=&quot;#1-4-异常&quot; class=&quot;headerlink&quot; title=&quot;1.4 异常&quot;&gt;&lt;/a&gt;1.4 异常&lt;/h2&gt;&lt;p&gt;异常是把代码中的错误或异常事件传递给调用方代码的一种特殊手段。如果在一个子程序中遇到了预料之外的情况，但不知道该如何处理的话，它就可以抛出一个异常，就好比是举起双手说“我不知道该怎么处理它一一我真希望有谁知道该怎么办！” 一样。对出错的前因后果不甚了解的代码，可以把对控制权转交给系统中其他能更好地解释错误并采取措施的部分。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用异常通知程序的其他部分，发生了不可忽略的错误&lt;/li&gt;
&lt;li&gt;只在真正例外的情况下才抛出异常：仅在其他编码实践方法无法解决的情况下才使用异常&lt;/li&gt;
&lt;li&gt;不能用异常来推卸责任：如果某种的错误情况可以在局部处理，那就应该在局部处理掉它&lt;/li&gt;
&lt;li&gt;避免在构造函数和析构函数中抛出异常，除非你在同一地方把它们捕获&lt;/li&gt;
&lt;li&gt;在恰当的抽象层次抛出异常&lt;/li&gt;
&lt;li&gt;在异常消息中加入关于导致异常发生的全部信息&lt;/li&gt;
&lt;li&gt;避免使用空的catch语句：不要试图敷衍一个不知该如何处理的异常&lt;/li&gt;
&lt;li&gt;了解所所用函数库可能抛出的异常&lt;/li&gt;
&lt;li&gt;考虑创建一个集中的异常报告机制&lt;/li&gt;
&lt;li&gt;把项目中对异常的使用标准化&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-5-在架构上设置隔栏来隔离错误&quot;&gt;&lt;a href=&quot;#1-5-在架构上设置隔栏来隔离错误&quot; class=&quot;headerlink&quot; title=&quot;1.5 在架构上设置隔栏来隔离错误&quot;&gt;&lt;/a&gt;1.5 在架构上设置隔栏来隔离错误&lt;/h2&gt;&lt;p&gt;隔栏是一种容损策略，这与与船体外壳上装备隔离舱或者建筑物中的防火墙是类似的。以防御式编程为目的而进行隔离的一种方法，是把某些接口选定为“安全”区域的边界。对穿越安全区域边界的数据进行合法性校验，并当数据非法时做出敏锐的反映。可以把这种方法看做是手术室里使用的一种技术——任何东西在允许进入手术室之前都要经过消毒处理。因此手术室内的任何东西都可以认为是安全的。这其中最核心的设计决策是规定什么可以进入手术室，什么不可以进入，还有把手术室的门设在哪里。&lt;/p&gt;
&lt;h2 id=&quot;1-6-编写辅助调试的代码&quot;&gt;&lt;a href=&quot;#1-6-编写辅助调试的代码&quot; class=&quot;headerlink&quot; title=&quot;1.6 编写辅助调试的代码&quot;&gt;&lt;/a&gt;1.6 编写辅助调试的代码&lt;/h2&gt;&lt;p&gt;防御式编程的另一重要方面是使用辅助调试的代码，可以用于帮助快速地检测错误。一般人除非被某个错误反复纠缠，否则是懒得花精力去写这些辅助调试代码的，但如果越早引入辅助调试的代码，它能够提供的帮助也越大。还有一种“进攻时编程”的方式来处理异常情况：在开发阶段让错误显现出来，而在产品代码运行时能够自我修复——在开发时惨痛地失败，能让你在发布产品后不会败得太惨。&lt;/p&gt;
&lt;p&gt;如果使用了辅助调试的代码，那要做好清理的计划。例如使用类似ant或make这样的编译控制工具，或者使用内置的预处理器（如C/C++的&lt;code&gt;#define&lt;/code&gt;的，如果语言不支持预编译器就考虑用变通方法写自己的预处理器），在发布的产品代码中剔除掉调试代码。&lt;/p&gt;
&lt;p&gt;说了这么多防御式编程的手段，但是过度地防御也会引起问题，例如引入的额外代码增加了软件的复杂度，引入的代码也可能引入其他bug。因此，要考虑好什么地方你需要进行防御，然后因地制宜地调整你进行防御式编程的优先级。&lt;/p&gt;
&lt;p&gt;参考文献：电子工业出版社《代码大全（第2版）》第8章&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;防御式编程这一概念来自防御式驾驶。在防御式驾驶中要建立这样一种思维，那就是你永远也不能确定另一位司机将要做什么。这样才能确保在其他人做出危险动作时你也不会受到伤害。你要承担起保护自己的责任，哪怕是其他司机犯的错误。本文将讲述如何面对严酷的非法数据的世界、在遇到“绝不会发生”的事件以及其他程序员犯下的错误时保护你自己。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="综合" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/"/>
    
      <category term="软件工程" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="软件构建" scheme="http://raytaylorlin.com/tags/%E8%BD%AF%E4%BB%B6%E6%9E%84%E5%BB%BA/"/>
    
      <category term="软件工程" scheme="http://raytaylorlin.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="代码大全" scheme="http://raytaylorlin.com/tags/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>软件构建（六）——语句</title>
    <link href="http://raytaylorlin.com/tech/complex/software/software-construction-6/"/>
    <id>http://raytaylorlin.com/tech/complex/software/software-construction-6/</id>
    <published>2016-04-16T13:54:28.000Z</published>
    <updated>2016-05-12T13:14:31.519Z</updated>
    
    <content type="html">&lt;p&gt;本文开始从以数据为中心的编程观点转到以语句为中心的观点上。常用的编程语句有顺序、控制和循环三种基本结构，本文将依次介绍这三种基本结构的使用原则。最后，还总结了一些不太常见的控制结构，如子程序多处返回、递归、关于goto语句的讨论。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-顺序语句&quot;&gt;&lt;a href=&quot;#1-顺序语句&quot; class=&quot;headerlink&quot; title=&quot;1. 顺序语句&quot;&gt;&lt;/a&gt;1. 顺序语句&lt;/h1&gt;&lt;p&gt;下面分别举了一个有前后明确的运行顺序的没有明显顺序的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 有前后依赖关系的语句
data = ReadData();
results = CalculateResultsFromData(data);
PrintResults(results);

// 不太明显的前后依赖关系的语句
revenue.ComputeMonthly();
revenue.ComputeQuarterly();
revenue.ComputeAnnual();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果语句之间存在依赖关系，并且这些关系要求你把语句按照一定的顺序加以排列，那么应设法使得这些依赖关系变得明显。下面是一些用于组织语句的简单原则。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设法组织代码，使依赖关系变得非常明显&lt;/li&gt;
&lt;li&gt;使子程序名能突显依赖关系&lt;/li&gt;
&lt;li&gt;利用子程序参数明确显示依赖关系&lt;/li&gt;
&lt;li&gt;用注释对不清晰的依赖关系进行说明：首先要尽力写没有顺序依赖关系的代码&lt;/li&gt;
&lt;li&gt;用断言或者错误处理代码来检查依赖关系&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果语句没有明显依赖关系，那也应该按一定原则来排列语句，使得其可读性更好，其中的指导原则就是就近原则：把相关的操作放在一起。&lt;strong&gt;要让程序易于自上而下阅读，而不是让读者的目光跳来跳去。&lt;/strong&gt; 此外，还要把相关的语句组织在一起，一种检验的方法是，打印出要检验的程序代码（可以输出图片），然后把相关的语句画上框，如果方框彼此&lt;strong&gt;不交叠&lt;/strong&gt;则相关语句组织得好。&lt;/p&gt;
&lt;h1 id=&quot;2-条件语句&quot;&gt;&lt;a href=&quot;#2-条件语句&quot; class=&quot;headerlink&quot; title=&quot;2. 条件语句&quot;&gt;&lt;/a&gt;2. 条件语句&lt;/h1&gt;&lt;h2 id=&quot;2-1-if-else语句&quot;&gt;&lt;a href=&quot;#2-1-if-else语句&quot; class=&quot;headerlink&quot; title=&quot;2.1 if-else语句&quot;&gt;&lt;/a&gt;2.1 if-else语句&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;首先写正常代码路径，再处理不常见情况&lt;/li&gt;
&lt;li&gt;确保对于等量的分支是正确的：仔细考虑“&amp;gt;”“&amp;lt;”和“&amp;gt;=”“&amp;lt;=”的逻辑&lt;/li&gt;
&lt;li&gt;把正常情况的处理放在if后面而不要放在else后面&lt;/li&gt;
&lt;li&gt;不要在if分支执行空语句&lt;/li&gt;
&lt;li&gt;考虑else分支：考虑是否真的仅仅只需要一个if分支就可满足，除非原因显而易见，否则也应考虑用注释来解释空else分支是没有必要的&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-2-switch-case语句&quot;&gt;&lt;a href=&quot;#2-2-switch-case语句&quot; class=&quot;headerlink&quot; title=&quot;2.2 switch-case语句&quot;&gt;&lt;/a&gt;2.2 switch-case语句&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;为case选择最有效的排列方式：按字母数字顺序，或者把正常的情况撞在前面，或者按执行频率高低&lt;/li&gt;
&lt;li&gt;简化每种情况对应的操作：不要在case中堆一堆操作&lt;/li&gt;
&lt;li&gt;不要为了使用case语句而刻意制造一个变量&lt;/li&gt;
&lt;li&gt;把default子句用于检查真正的默认情况或检查错误&lt;/li&gt;
&lt;li&gt;在case末尾明确无误地标明需要穿越执行的程序流程&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;3-循环语句&quot;&gt;&lt;a href=&quot;#3-循环语句&quot; class=&quot;headerlink&quot; title=&quot;3. 循环语句&quot;&gt;&lt;/a&gt;3. 循环语句&lt;/h1&gt;&lt;h2 id=&quot;3-1-循环的种类&quot;&gt;&lt;a href=&quot;#3-1-循环的种类&quot; class=&quot;headerlink&quot; title=&quot;3.1 循环的种类&quot;&gt;&lt;/a&gt;3.1 循环的种类&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;计数循环：执行次数一定，如for循环。&lt;strong&gt;不要在for循环中去修改下标值或中途退出。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;连续求值的循环：预先不知道循环次数，如while循环&lt;/li&gt;
&lt;li&gt;无限循环：一旦启动就一直执行，除非在循环中间退出，如while循环带break中断&lt;/li&gt;
&lt;li&gt;迭代器循环：容器类的常见操作，如foreach循环&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;3-2-循环的原则&quot;&gt;&lt;a href=&quot;#3-2-循环的原则&quot; class=&quot;headerlink&quot; title=&quot;3.2 循环的原则&quot;&gt;&lt;/a&gt;3.2 循环的原则&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;进入循环&lt;ul&gt;
&lt;li&gt;只从一个位置进入循环&lt;/li&gt;
&lt;li&gt;把初始化代码紧放在循环前面&lt;/li&gt;
&lt;li&gt;用&lt;code&gt;while(true)&lt;/code&gt;表示无限循环&lt;/li&gt;
&lt;li&gt;在适当的情况下多使用for循环；但如果while循环更适用的话，不要使用for循环：因为while循环需要在循环之前初始化条件，循环最后变更条件，容易出错和可读性较差&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;处理循环体&lt;ul&gt;
&lt;li&gt;避免空循环&lt;/li&gt;
&lt;li&gt;循环内务操作（循环变量的变更）要么放在循环的开始，要么放在循环的末尾&lt;/li&gt;
&lt;li&gt;一个循环只做一件事：应该把循环体当做黑盒或子程序看待，读者只需要关心其循环条件是什么，而不需关心其内容&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;退出循环&lt;ul&gt;
&lt;li&gt;设法确认循环能够终止：要考虑正常的情况、端点，及每一种异常情况&lt;/li&gt;
&lt;li&gt;使循环终止条件看起来很明显&lt;/li&gt;
&lt;li&gt;不要为了终止循环而胡乱改动for循环的下标&lt;/li&gt;
&lt;li&gt;避免出现依赖于循环下标&lt;strong&gt;最终取值&lt;/strong&gt;的代码：更具自我描述性的做法是，在循环体内某个适当的地方把这一最终取值赋给某个变量&lt;/li&gt;
&lt;li&gt;考虑使用安全计数器：安全计数器是一个特殊变量，在每次循环之后都递增它，以便判断该循环的执行次数是不是过多&lt;/li&gt;
&lt;li&gt;考虑在while循环中使用break语句而不用布尔标记&lt;/li&gt;
&lt;li&gt;小心那些有很多break散布在循环各处&lt;/li&gt;
&lt;li&gt;在循环开始处用continue进行判断：可以避免用一个让整个循环体的缩进的if块&lt;/li&gt;
&lt;li&gt;除非你已经考虑过各种替换方案，否则不要使用break：使用break消除了把循环看做黑盒子的可能性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;检查端点：既要在脑海中模拟，也要手工检查一遍&lt;/li&gt;
&lt;li&gt;循环变量&lt;ul&gt;
&lt;li&gt;用整数或者枚举类型表示数组和循环的边界&lt;/li&gt;
&lt;li&gt;在嵌套循环中使用有意义的变量名来提高其可读性：避免i、j、k及下标串话误用&lt;/li&gt;
&lt;li&gt;把循环下标变量的作用域限制在本循环内&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;循环的长度&lt;ul&gt;
&lt;li&gt;循环要尽可能地短，以便能够一目了然：建议限制在一屏之内&lt;/li&gt;
&lt;li&gt;把嵌套限制在3层以内&lt;/li&gt;
&lt;li&gt;把长循环的内容移到子程序里&lt;/li&gt;
&lt;li&gt;要让长循环格外清晰&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;4-不太常见的控制结构&quot;&gt;&lt;a href=&quot;#4-不太常见的控制结构&quot; class=&quot;headerlink&quot; title=&quot;4. 不太常见的控制结构&quot;&gt;&lt;/a&gt;4. 不太常见的控制结构&lt;/h1&gt;&lt;h2 id=&quot;4-1-子程序多处返回&quot;&gt;&lt;a href=&quot;#4-1-子程序多处返回&quot; class=&quot;headerlink&quot; title=&quot;4.1 子程序多处返回&quot;&gt;&lt;/a&gt;4.1 子程序多处返回&lt;/h2&gt;&lt;p&gt;子程序的多处返回是指一个子程序中有多处地方出现return。通常来说，应该用防卫子句（早返回或早退出）来简化复杂的错误处理，不要使用过多的缩进嵌套，并且减少每个子程序中return的数量。下面的例子很好地体现了这些原则。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (!file.validName()) {
    errorStatus = FileError.InvalidFileName;
    return;
}
if (!file.Open()) {
    errorStatus = FileError.CantOpenFile;
    return;
}
if (!encryptionKey.valid()) {
    errorStatus = FileError.InvalidEncryptionKey;
    return;
}
// 此处为处理正常情况的代码
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;4-2-递归&quot;&gt;&lt;a href=&quot;#4-2-递归&quot; class=&quot;headerlink&quot; title=&quot;4.2 递归&quot;&gt;&lt;/a&gt;4.2 递归&lt;/h2&gt;&lt;p&gt;递归并不常用，但如果使用得谨慎，一些小范围内的问题还是可以得到非常优雅的解。对于大多数问题，它所带来的解将会是极其复杂的——在那些情况下，使用简单的迭代通常会比较容易理解。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;确认递归能够停止&lt;/li&gt;
&lt;li&gt;使用安全计数器防止出现无穷递归：安全计数器必须是一个不随每次子程序调用而重新创建的变量&lt;/li&gt;
&lt;li&gt;把递归限制在一个子程序内：循环边归（A调用B, B调用C, C调用A）非常危险&lt;/li&gt;
&lt;li&gt;留心栈空间：给安全计数器设置上限时考虑给递归子程序分配多少栈空间，并观察递归函数中局部变量的分配情况&lt;/li&gt;
&lt;li&gt;不要用递归去计算阶乘或者斐波纳契数列：最重要的，在用递归之前你应该考虑它的替换方案&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;4-3-关于goto语句&quot;&gt;&lt;a href=&quot;#4-3-关于goto语句&quot; class=&quot;headerlink&quot; title=&quot;4.3 关于goto语句&quot;&gt;&lt;/a&gt;4.3 关于goto语句&lt;/h2&gt;&lt;p&gt;入们反对使用goto的普遍理由是：含有goto的代码很难安排好格式；使用goto也会破坏编译器的优化特性。关于goto的讨论非常多，而且其现代版本仍在以各种各样的形式出现。用不用goto是一个&lt;strong&gt;信仰问题&lt;/strong&gt;。《代码大全》作者的信条是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在现代语言里，你可以很容易地把九成的goto替换成与之等价的顺序结构。对于这些简单的情况，你应该把goto替换掉并把这当成习惯。对于复杂的情况，你仍有九成不用goto的可能：你可以把代码拆分成小的子程序，使用try-finally，使用嵌套if，检测并重新检测某个状态变量，或者重新设置条件结构。对于这些情况，想消除goto相对来说比较难，但这是一种很好的智力训练……&lt;br&gt;对于剩下的那1%的情况，即当使用goto是解决问题的合理办法的时候，请在使用的同时予以详细的说明。如果你穿着雨鞋，那么就没有必要绕开泥潭走路了。不过也要虚心参考别的程序员提出的不用goto的方法。也许他们发现了一些被你忽视的东西。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;在那些不直接支持结构化控制语句的语言里，用goto去模拟那些控制结构。在做这些的时候，应该准确地模拟，不要滥用goto所带来的灵活性&lt;/li&gt;
&lt;li&gt;如果语言内置了等价的控制结构，那么就不要用goto&lt;/li&gt;
&lt;li&gt;如果是为提高代码效率而使用goto，请衡量此举实际带来的性能提升&lt;/li&gt;
&lt;li&gt;除非你要模拟结构化语句，否则尽量在每个子程序内只使用一个goto标号&lt;/li&gt;
&lt;li&gt;除非你要模拟结构化语句，否则尽量让goto向前跳转而不要向后跳转&lt;/li&gt;
&lt;li&gt;确认所布的goto标号都被用到了。没用到的goto标号表明缺少了代码，即缺少了跳向该标号的代码。如果某些标号没有用，那么就删掉它们&lt;/li&gt;
&lt;li&gt;确认goto不会产生某些执行不到的代码&lt;/li&gt;
&lt;li&gt;如果你是一位经理，那么就应该持这样的观点：对某一个goto用法所展开的争论并不是事关全局的。如果程序员知道存在替换方案，并且也愿意为使用goto辩解，那么用goto也无妨&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考文献：电子工业出版社《代码大全（第2版）》第14-17章&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;本文开始从以数据为中心的编程观点转到以语句为中心的观点上。常用的编程语句有顺序、控制和循环三种基本结构，本文将依次介绍这三种基本结构的使用原则。最后，还总结了一些不太常见的控制结构，如子程序多处返回、递归、关于goto语句的讨论。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="综合" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/"/>
    
      <category term="软件工程" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="软件构建" scheme="http://raytaylorlin.com/tags/%E8%BD%AF%E4%BB%B6%E6%9E%84%E5%BB%BA/"/>
    
      <category term="软件工程" scheme="http://raytaylorlin.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="代码大全" scheme="http://raytaylorlin.com/tags/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>软件构建（五）——各种数据类型的使用原则</title>
    <link href="http://raytaylorlin.com/tech/complex/software/software-construction-5/"/>
    <id>http://raytaylorlin.com/tech/complex/software/software-construction-5/</id>
    <published>2016-04-11T06:58:29.000Z</published>
    <updated>2016-05-12T13:14:24.685Z</updated>
    
    <content type="html">&lt;p&gt;几乎所有的常见编程语言，都包含了整数、浮点数、字符串、布尔等等数据类型，而通过基本的数据类型又可以复合出各种数据结构。本文总结了常用的数据类型（整数、浮点数、字符、字符串、布尔、枚举、数组等等）以及一些不常见的数据类型（结构体、指针等等）的使用原则。最后总结了关于全局数据的一些风险和使用原则。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-常用的数据类型使用原则&quot;&gt;&lt;a href=&quot;#1-常用的数据类型使用原则&quot; class=&quot;headerlink&quot; title=&quot;1. 常用的数据类型使用原则&quot;&gt;&lt;/a&gt;1. 常用的数据类型使用原则&lt;/h1&gt;&lt;h2 id=&quot;1-1-使用数值的原则&quot;&gt;&lt;a href=&quot;#1-1-使用数值的原则&quot; class=&quot;headerlink&quot; title=&quot;1.1 使用数值的原则&quot;&gt;&lt;/a&gt;1.1 使用数值的原则&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;普遍原则&lt;ul&gt;
&lt;li&gt;避免使用“神秘数值”，即硬编码数字：这是为了使修改变得可靠容易，并更有可读性&lt;/li&gt;
&lt;li&gt;如果需要，可以使用硬编码的0和1：通常用于增减量或循环的第一个元素&lt;/li&gt;
&lt;li&gt;预防除零错误&lt;/li&gt;
&lt;li&gt;使类型转换变得明显：不要依赖隐式类型转换&lt;/li&gt;
&lt;li&gt;避免混合类型的比较：同样不要依赖隐式类型转换，确保比较的两个数是同种类型的&lt;/li&gt;
&lt;li&gt;注意编译器的警告&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;整数&lt;ul&gt;
&lt;li&gt;检查整数除法：小心&lt;strong&gt;整数除&lt;/strong&gt;和现实除法的差异&lt;/li&gt;
&lt;li&gt;检查整数溢出和中间结果溢出&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;浮点数&lt;ul&gt;
&lt;li&gt;避免数量级相差巨大的数之间的加减运算：由于精度问题，对于32位浮点数，小心1000000.00 + 0.1得到的结果和期望不同。如果要把一系列差异巨大的数相加，解决方法是先排序，再从最小值开始加起，这样可以把影响减少到最低限度&lt;/li&gt;
&lt;li&gt;避免直接进行等量比较：应自己编写equals函数判断两者之差是否小于某阈值&lt;/li&gt;
&lt;li&gt;处理舍入误差问题：考虑换用更高精度的类型，或者把浮点数放大n倍用整型类型做计算&lt;/li&gt;
&lt;li&gt;使用语言和函数库对特定数据类型的支持&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-2-字符和字符串&quot;&gt;&lt;a href=&quot;#1-2-字符和字符串&quot; class=&quot;headerlink&quot; title=&quot;1.2 字符和字符串&quot;&gt;&lt;/a&gt;1.2 字符和字符串&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;避免使用神秘字符和字符串：除了数值所提到的理由之外，还有这些理由：分离字符串到字符串资源文件更容易实现i18n，字符串字面量会占用较多的存储空间&lt;/li&gt;
&lt;li&gt;了解你的语言和开发环境是如何支持Unicode的&lt;/li&gt;
&lt;li&gt;在程序生命期中尽早决定国际化/本地化策略&lt;/li&gt;
&lt;li&gt;如果你知道只需要支持一种文字的语言，考虑使用ISO8859字符集，否则使用Unicode&lt;/li&gt;
&lt;li&gt;采用某种一致的字符串类型转换策略&lt;/li&gt;
&lt;li&gt;针对C语言字符串的建议：&lt;ul&gt;
&lt;li&gt;注意字符串指针和字符数组之间的差异：警惕任何包含字符串和等号的表达式；通过命名规则区分变量是字符数组还是字符串指针&lt;/li&gt;
&lt;li&gt;把C-style字符串的长度声明为&lt;code&gt;STRING_LENGTH + 1&lt;/code&gt;：统一约定这条规则，有助于减少脑力消耗以及编程失误&lt;/li&gt;
&lt;li&gt;用null初始化字符串以避免没有终端的字符串&lt;/li&gt;
&lt;li&gt;如果内存不是限制性的因素，就用字符数组取代C中的指针&lt;/li&gt;
&lt;li&gt;用strncpy()取代strcpy()以避免无终端的字符串&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-3-布尔变量&quot;&gt;&lt;a href=&quot;#1-3-布尔变量&quot; class=&quot;headerlink&quot; title=&quot;1.3 布尔变量&quot;&gt;&lt;/a&gt;1.3 布尔变量&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;用布尔变量对程序加以文档说明，并用来简化复杂的判断。&lt;/strong&gt;通过下面的例子来了解布尔变量的正确用法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 目的不明确的布尔判断，咋一看根本不知道要判断什么
if ( (elementindex &amp;lt; 0 ) || (MAX_ELEMENTS &amp;lt; elementIndex) || (elementIndex == lastElementIndex) ) { ... }

// 目的明确的布尔判断
bool finished = (elementindex &amp;lt; 0 ) || (MAX_ELEMENTS &amp;lt; elementIndex);
bool repeatedEntry = (elementIndex == lastElementIndex);
if (finished || repeatedEntry) { ... }
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;1-4-枚举类型&quot;&gt;&lt;a href=&quot;#1-4-枚举类型&quot; class=&quot;headerlink&quot; title=&quot;1.4 枚举类型&quot;&gt;&lt;/a&gt;1.4 枚举类型&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;用枚举类型来提高可读性和可靠性：如果仅使用具名常量，编译器无法知道是否使用了非法的数值&lt;/li&gt;
&lt;li&gt;将枚举类型作为布尔变量的替换方案：有时布尔变量无法充分表达它所需要表达的含义（比如出错信息），那么用枚举&lt;/li&gt;
&lt;li&gt;定义出枚举的第一项和最后一项，以使用于循环边界，把枚举类型的第一个元素留做非法值：如&lt;code&gt;enum Country {InvalidFirst = 0, First = 1, China = 1, England = 2, Usa = 3, Last = 4}&lt;/code&gt;，但是这样做也可能造成混乱，一定要&lt;strong&gt;明确定义项目代码编写标准，并在使用时保持一致，否则就不要用&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;警惕给枚举元素明确赋值而带来的失误：当定义0，1，2，4，8这样的枚举值时，不要去遍历&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-5-数组&quot;&gt;&lt;a href=&quot;#1-5-数组&quot; class=&quot;headerlink&quot; title=&quot;1.5 数组&quot;&gt;&lt;/a&gt;1.5 数组&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;确认所有的数组下标都没有超出数组的边界&lt;/li&gt;
&lt;li&gt;考虑用合适的容器（栈、队列、集合、列表等等）来取代数组&lt;/li&gt;
&lt;li&gt;检查数组的边界点&lt;/li&gt;
&lt;li&gt;如果数组是多维的，确认下标的&lt;strong&gt;使用顺序&lt;/strong&gt;是正确的：如很容易把&lt;code&gt;array[i][j]&lt;/code&gt;搞混成&lt;code&gt;array[j][i]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;提防下标串话：如把&lt;code&gt;array[i]&lt;/code&gt;写成&lt;code&gt;array[j]&lt;/code&gt;，和上一条一样，如果使用比i和j更有意义的下标名，这种错误就很难发生&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;2-不常见的数据类型&quot;&gt;&lt;a href=&quot;#2-不常见的数据类型&quot; class=&quot;headerlink&quot; title=&quot;2. 不常见的数据类型&quot;&gt;&lt;/a&gt;2. 不常见的数据类型&lt;/h1&gt;&lt;h2 id=&quot;2-1-结构体&quot;&gt;&lt;a href=&quot;#2-1-结构体&quot; class=&quot;headerlink&quot; title=&quot;2.1 结构体&quot;&gt;&lt;/a&gt;2.1 结构体&lt;/h2&gt;&lt;p&gt;在Java和C++里面，类有时表现得也像结构体一样（当类完全由公用的数据成员组成，而不包含公用子程序的时候）。通常情况下，你会希望创建类而非结构体，下面列出了一些使用结构体的理由：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用结构体来明确数据关系&lt;/li&gt;
&lt;li&gt;用结构体简化对数据块的操作&lt;/li&gt;
&lt;li&gt;用结构体来简化参数列表&lt;/li&gt;
&lt;li&gt;用结构体来减少维护&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-2-指针&quot;&gt;&lt;a href=&quot;#2-2-指针&quot; class=&quot;headerlink&quot; title=&quot;2.2 指针&quot;&gt;&lt;/a&gt;2.2 指针&lt;/h2&gt;&lt;p&gt;指针的使用是现代编程中最容易出错的领域之一，即便你的语言不要求你使用指针，很好地理解指针也会有助于你理解你的编程语言是如何工作的。从概念上看，每一个指针都包含两个部分：内存中的某处位置（实质是一个整数值，常用16进制表示），以及如何解释指针所指的内容（由指针的基类型决定）。&lt;/p&gt;
&lt;p&gt;通常，指针错误都产生于指针指向了它不应该指向的位置。因此，更正指针错误的大部分工作量便是找出它的位置。正确地使用指针要求程序员采用一种双向策略，首先要避免造成指针错误，其次在编写代码之后尽快地检测出指针错误来。下面说明如何实现这些目标。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;把指针操作限制在子程序或者类里面&lt;/li&gt;
&lt;li&gt;同时声明和定义指针&lt;/li&gt;
&lt;li&gt;在与指针分配相同的作用域中删除指针&lt;/li&gt;
&lt;li&gt;在使用指针之前确保指针所指向的内存位置是合理的&lt;/li&gt;
&lt;li&gt;先检查指针所引用的变量内容再使用它&lt;/li&gt;
&lt;li&gt;用标记字段来检测损毁的内存：分配内存时多分配4个字节，将前4个字节设为标记字段，返回这4个字节后的内存的指针，到了需要删除该指针的时候，检查这个标记，如果标记的值是正确的，就把它设为NULL，最后删除该指针&lt;/li&gt;
&lt;li&gt;增加明显的冗余：将某些特定字段重复两次，以此替代标记字段的方案，但是这样会带来很高的成本&lt;/li&gt;
&lt;li&gt;用额外的指针变量来提高代码清晰度：如不要写绕口的诸如&lt;code&gt;pointer-&amp;gt;next-&amp;gt;last-&amp;gt;next&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;画一个图理清指针之间的结构关系&lt;/li&gt;
&lt;li&gt;按照正确的顺序删除链表中的指针&lt;/li&gt;
&lt;li&gt;分配一片保留的内存后备区域：如果使用动态内存，最好预先分配一片内存后备，防止程序忽然用尽内存&lt;/li&gt;
&lt;li&gt;在删除或者释放指针之后把它们设为空值&lt;/li&gt;
&lt;li&gt;在删除变量之前检查非法指针&lt;/li&gt;
&lt;li&gt;跟踪指针分配情况：维护一份你已经分配的指针的列表&lt;/li&gt;
&lt;li&gt;编写覆盖子程序，集中实现避免指针问题的策略：如编写&lt;code&gt;SAFE_NEW&lt;/code&gt;和&lt;code&gt;SAFE_DELETE&lt;/code&gt;宏来统一包装指针的操作&lt;/li&gt;
&lt;li&gt;采用非指针的技术&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;还有一些特定的针对C++和C语言的指针使用技巧，此处不赘述。&lt;/p&gt;
&lt;h1 id=&quot;3-全局数据&quot;&gt;&lt;a href=&quot;#3-全局数据&quot; class=&quot;headerlink&quot; title=&quot;3. 全局数据&quot;&gt;&lt;/a&gt;3. 全局数据&lt;/h1&gt;&lt;p&gt;全局数据可以在程序中任意一个位置访问，这一概念有时被延伸到作用域比局部变量更广的变量，例如可以在一个包或一个命名空间内任意位置访问。一般来说，使用全局数据的风险比使用局部数据大，只有在万不得已时才使用，如果要用也应该遵循一些使用原则来降低风险。&lt;/p&gt;
&lt;h2 id=&quot;3-1-使用全局数据的风险&quot;&gt;&lt;a href=&quot;#3-1-使用全局数据的风险&quot; class=&quot;headerlink&quot; title=&quot;3.1 使用全局数据的风险&quot;&gt;&lt;/a&gt;3.1 使用全局数据的风险&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;无意间修改了全局数据&lt;/li&gt;
&lt;li&gt;与全局数据有关的别名问题：当一个全局变量被传递给一个子程序，然后该子程序将它既用作全局变量又用作参数使用的情况下会出现这种问题&lt;/li&gt;
&lt;li&gt;多线程下风险很大&lt;/li&gt;
&lt;li&gt;全局数据阻碍代码重用&lt;/li&gt;
&lt;li&gt;与全局数据有关的非确定的初始化顺序事直&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;全局数据破坏了模块化和智力上的可管理性&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;3-2-全局数据的使用原则&quot;&gt;&lt;a href=&quot;#3-2-全局数据的使用原则&quot; class=&quot;headerlink&quot; title=&quot;3.2 全局数据的使用原则&quot;&gt;&lt;/a&gt;3.2 全局数据的使用原则&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;创建一种命名规则来突出全局变量：例如使用g_前缀&lt;/li&gt;
&lt;li&gt;为全部的全局变量创建一份注释良好的清单&lt;/li&gt;
&lt;li&gt;不要用全局变量来存放中间结果&lt;/li&gt;
&lt;li&gt;不要把所有的数据都放在一个大对象中并到处传递，以说明你没有使用全局变量：这纯粹是一种负担，如果要用全局数据，就大胆公开地用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考文献：电子工业出版社《代码大全（第2版）》第12、13章&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;几乎所有的常见编程语言，都包含了整数、浮点数、字符串、布尔等等数据类型，而通过基本的数据类型又可以复合出各种数据结构。本文总结了常用的数据类型（整数、浮点数、字符、字符串、布尔、枚举、数组等等）以及一些不常见的数据类型（结构体、指针等等）的使用原则。最后总结了关于全局数据的一些风险和使用原则。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="综合" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/"/>
    
      <category term="软件工程" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="软件构建" scheme="http://raytaylorlin.com/tags/%E8%BD%AF%E4%BB%B6%E6%9E%84%E5%BB%BA/"/>
    
      <category term="软件工程" scheme="http://raytaylorlin.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="代码大全" scheme="http://raytaylorlin.com/tags/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/"/>
    
  </entry>
  
</feed>
