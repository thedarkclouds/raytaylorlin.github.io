<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ray Taylor Lin&#39;s world</title>
  <subtitle>林寿山的技术博客 Ray Taylor Lin&#39;s world</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://raytaylorlin.com/"/>
  <updated>2017-08-25T15:24:04.017Z</updated>
  <id>http://raytaylorlin.com/</id>
  
  <author>
    <name>Ray Taylor Lin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>NGUI源码学习——UIScrollView</title>
    <link href="http://raytaylorlin.com/tech/game/unity/ngui-code-uiscrollview/"/>
    <id>http://raytaylorlin.com/tech/game/unity/ngui-code-uiscrollview/</id>
    <published>2017-05-01T13:42:55.000Z</published>
    <updated>2017-08-25T15:24:04.017Z</updated>
    
    <content type="html">&lt;p&gt;UIScrollView是NGUI支持滚动和拖拽的内容容器，可以和scroll bar联动。本文主要记录其相对滚动原理和核心方法，以及如何利用UIWrapContent优化滚动。了解了UIWrapContent的实现原理之后，可以在其上扩展和封装游戏UI中常见的数据展示控件。&lt;/p&gt;
&lt;p&gt;【参考版本：NGUI 3.6.9】&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-基础要点&quot;&gt;&lt;a href=&quot;#1-基础要点&quot; class=&quot;headerlink&quot; title=&quot;1. 基础要点&quot;&gt;&lt;/a&gt;1. 基础要点&lt;/h1&gt;&lt;p&gt;UIScrollView依赖于UIPanel，必须和UIPanel绑在同一个go上。注意scrollView的内容物需要挂UIDragScrollView脚本，该脚本主要是接收OnPress和OnDrag事件，并转到UIScrollView中处理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;相对滚动原理（&lt;code&gt;MoveRelative&lt;/code&gt;为核心方法，所有的内容滚动最终都会调用到这里）：scrollView自身transform位置加偏移，同时panel的clipOffset减去相等的偏移量&lt;/strong&gt;（见下方代码）。这是因为一正一负的抵消可以让panel的位置保持不动，但由于panel offset的变化导致裁剪之后看上去物体好像被移动了一样。Panel的clipOffset属性使得在滚动的时候不用重建geometry，极大地提升滚动的效率。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public virtual void MoveRelative (Vector3 relative)
{
    mTrans.localPosition += relative;
    Vector2 co = mPanel.clipOffset;
    co.x -= relative.x;
    co.y -= relative.y;
    mPanel.clipOffset = co;

    // Update the scroll bars
    UpdateScrollbars(false);
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;1-1-核心方法&quot;&gt;&lt;a href=&quot;#1-1-核心方法&quot; class=&quot;headerlink&quot; title=&quot;1.1 核心方法&quot;&gt;&lt;/a&gt;1.1 核心方法&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;LateUpdate&lt;/code&gt;：更新scrollBar（如果有）的一些透明度数值；&lt;strong&gt;若没有press&lt;/strong&gt;（即执行一些惯性动画的过程），则计算动量mMomentum（用于缓动）并插值出mScroll和offset值，利用&lt;code&gt;MoveAbsolute(offset)&lt;/code&gt;来逐帧执行spring动画。最后根据restrictWithinPanel属性检测内容有没有超出边界，若有则调用&lt;code&gt;RestrictWithinBounds&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Press&lt;/code&gt;：由挂了UIDragScrollView的go接收&lt;code&gt;OnPress&lt;/code&gt;事件后通知UIScrollView，主要用于设置一些状态。按下时，mMomentum和mScroll清零，禁用Spring脚本，截掉tranform位置和panel offset的小数点（保持pixel-perfect），创建一个平面供drag投射用；松开时，限制bounds并触发一些回调。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Drag&lt;/code&gt;：根据当前按下的点对上面的平面做投射，若有交点则计算拖拽产生的偏移，并使用&lt;code&gt;MoveAbsolute&lt;/code&gt;和&lt;code&gt;RestrictWithinBounds&lt;/code&gt;【见下方】方法来移动内容。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Awake时做一些属性自动调整。例如若panel的clipping为None会改为ConstrainButDontClip（即必须给panel限定一个范围）；自动调整Movement类型等等。&lt;/p&gt;
&lt;p&gt;该类除了上面这些方法之外，主要就剩下一些和Scrollbar联动相关的代码，此处不赘述。&lt;/p&gt;
&lt;h2 id=&quot;1-2-工具方法&quot;&gt;&lt;a href=&quot;#1-2-工具方法&quot; class=&quot;headerlink&quot; title=&quot;1.2 工具方法&quot;&gt;&lt;/a&gt;1.2 工具方法&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;RestrictWithinBounds&lt;/code&gt;：将内容限制到scrollView的边界内。该方法会根据所有widget的内容包围盒以及panel的finalClipRegion，调用&lt;code&gt;NGUIMath.ConstrainRect(minRect, maxRect, minArea, maxArea)&lt;/code&gt;计算出将内容rect限制到视口area所需的偏移。&lt;ul&gt;
&lt;li&gt;若用了&lt;code&gt;DragEffect.MomentumAndSpring&lt;/code&gt;，则调用&lt;code&gt;SpringPanel.Begin&lt;/code&gt;设置要移动的目标位置并启用动画&lt;/li&gt;
&lt;li&gt;否则直接MoveRelative移动内容&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;2-使用UIWrapContent优化滚动效率&quot;&gt;&lt;a href=&quot;#2-使用UIWrapContent优化滚动效率&quot; class=&quot;headerlink&quot; title=&quot;2. 使用UIWrapContent优化滚动效率&quot;&gt;&lt;/a&gt;2. 使用UIWrapContent优化滚动效率&lt;/h1&gt;&lt;p&gt;NGUI 3.7.x以上版本，有个新组件UIWrapContent，当列表内容很多时（甚至内容有无限多，或者循环滚动），可以用它来优化。用法很简单，和UIGrid或UITable等挂在同一层级下，包裹住内容即可。&lt;/p&gt;
&lt;p&gt;注册&lt;code&gt;panel.onClipMove&lt;/code&gt;事件（clipOffset改变时，基本上就是在滚动时触发）为&lt;code&gt;WrapContent&lt;/code&gt;这个核心方法，其主要完成以下工作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;根据UIScrollView的方向分为水平和垂直两种处理方式，两者原理一模一样，下面以水平为例。&lt;/li&gt;
&lt;li&gt;获取panel的本地corner坐标，令min=左下角-itemSize，max=右上角+itemSize，遍历每个孩子t进行如下处理：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;// max和min是panel尺寸加减一个物体尺寸的上下限
float min = corners[0].x - itemSize;
float max = corners[2].x + itemSize;
Vector3 center = Vector3.Lerp(corners[0], corners[2], 0.5f);
Transform t = mChildren[i];
float distance = t.localPosition.x - center.x;

// extents为所有内容bounds的半长，ext2即为尺寸
if (distance &amp;lt; -extents)
{
    Vector3 pos = t.localPosition;
    // 加上尺寸长度，移动到另一端【我们将这种操作称为item的跳转】
    pos.x += ext2;
    distance = pos.x - center.x;
    int realIndex = Mathf.RoundToInt(pos.x / itemSize);

    // 在设置面板中，min和max决定了滚动的上下限（可以为负，代表向左滚动的下限），两者相等则无限滚动
    if (minIndex == maxIndex || (minIndex &amp;lt;= realIndex &amp;amp;&amp;amp; realIndex &amp;lt;= maxIndex))
    {
        t.localPosition = pos;
        UpdateItem(t, i);
        t.name = realIndex.ToString();
    }
    else allWithinRange = false;
}
/* 省略向右的情况...... */
// 该选项决定是否剔除物体（实际上就是将超出范围的物体隐藏，将范围内的物体显示）以提高性能
if (cullContent)
{
    distance += mPanel.clipOffset.x - mTrans.localPosition.x;
    if (!UICamera.IsPressed(t.gameObject))
        NGUITools.SetActive(t.gameObject, (distance &amp;gt; min &amp;amp;&amp;amp; distance &amp;lt; max), false);
}

protected virtual void UpdateItem (Transform item, int index)
{
    if (onInitializeItem != null)
    {
        int realIndex = (mScroll.movement == UIScrollView.Movement.Vertical) ?
            Mathf.RoundToInt(item.localPosition.y / itemSize) :
            Mathf.RoundToInt(item.localPosition.x / itemSize);
        // 调用回调，其中index为物体在孩子列表中的索引，realIndex是物体最终位置所在的索引
        onInitializeItem(item.gameObject, index, realIndex);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下图是以1-9个数字方格为例的UIWrapContent滚动原理&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://raytaylorlin-blog.qiniudn.com/image/Unity/UIWrapContent%E5%90%91%E5%B7%A6%E6%BB%9A%E5%8A%A8%E5%8E%9F%E7%90%86.jpg&quot; alt=&quot;UIWrapContent向左滚动原理&quot;&gt;&lt;/p&gt;
&lt;p&gt;当滑动列表，每次有item跳转的时候，就会调用&lt;code&gt;onInitializeItem&lt;/code&gt;回调（绑定你自定义的设置数据方法），此时就可以根据realIndex从你的数据列表中取得对应的数据，再将数据设置到go上（例如获取go的UILabel并设置其text等等）。&lt;/p&gt;
&lt;h2 id=&quot;2-1-需要注意的点&quot;&gt;&lt;a href=&quot;#2-1-需要注意的点&quot; class=&quot;headerlink&quot; title=&quot;2.1 需要注意的点&quot;&gt;&lt;/a&gt;2.1 需要注意的点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;如果列表是vertical的，由于坐标轴是上正下负，计算出来的realIndex从上到下是对应0到负数。&lt;strong&gt;所以纵向列表取数据时，要将realIndex取绝对值再取数据。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;以vertical为例，要确保wrapContent的孩子个数为&lt;code&gt;panelHeight / itemHeight + 1&lt;/code&gt;个，滚动设置自定义数据的行为才是正确的&lt;/li&gt;
&lt;li&gt;参考设置：横向滚动时，&lt;code&gt;minIndex = 0, maxIndex = m_Data.Count&lt;/code&gt;；纵向滚动时，&lt;code&gt;minIndex = 1 - m_Data.Count, maxIndex = 0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;UIScrollView是NGUI支持滚动和拖拽的内容容器，可以和scroll bar联动。本文主要记录其相对滚动原理和核心方法，以及如何利用UIWrapContent优化滚动。了解了UIWrapContent的实现原理之后，可以在其上扩展和封装游戏UI中常见的数据展示控件。&lt;/p&gt;
&lt;p&gt;【参考版本：NGUI 3.6.9】&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="游戏开发" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
      <category term="Unity" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/Unity/"/>
    
      <category term="NGUI" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/Unity/NGUI/"/>
    
    
      <category term="NGUI" scheme="http://raytaylorlin.com/tags/NGUI/"/>
    
      <category term="Unity" scheme="http://raytaylorlin.com/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>NGUI源码学习——UILabel</title>
    <link href="http://raytaylorlin.com/tech/game/unity/ngui-code-uilabel/"/>
    <id>http://raytaylorlin.com/tech/game/unity/ngui-code-uilabel/</id>
    <published>2017-04-05T14:02:07.000Z</published>
    <updated>2017-08-08T16:09:21.477Z</updated>
    
    <content type="html">&lt;p&gt;UILabel是NGUI中用于显示文字的控件。其核心思想是遍历每个字符，将其转化为字体贴图的数据。本篇会抛开BBCode解析，表情符symbol解析，特殊效果（阴影、描边等）等细节，只记录几个渲染字体的核心方法。NGUI有独立的一套BMFont管理工具和类，等以后再另开篇章讲解。&lt;/p&gt;
&lt;p&gt;【参考版本：NGUI 3.6.9】&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-基础要点&quot;&gt;&lt;a href=&quot;#1-基础要点&quot; class=&quot;headerlink&quot; title=&quot;1. 基础要点&quot;&gt;&lt;/a&gt;1. 基础要点&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;基本上只要设置了某个属性，都会使shouldBeProcessed变成true。在必要的时候，例如设置text、fontSize、fontStyle、alignment、OnValidate()，或者在获取父类UIWidget的一些属性，如localSize、drawingDimensions、worldCorners等等，才会根据shouldBeProcessed去调用&lt;code&gt;ProcessText&lt;/code&gt;重绘字体。&lt;/li&gt;
&lt;li&gt;NGUIText作为中转处理的静态类，包含了大量的公共静态属性供缓存&lt;/li&gt;
&lt;li&gt;字体方案有两种：Unity自带的动态字体（TTF）和NGUI的BitmapFont（即图字&lt;a href=&quot;http://www.angelcode.com/products/bmfont/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;BMFont&lt;/a&gt;）。后者在获取glyph信息时会多考虑当前字符与上一个字符的字距。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;2-核心方法&quot;&gt;&lt;a href=&quot;#2-核心方法&quot; class=&quot;headerlink&quot; title=&quot;2. 核心方法&quot;&gt;&lt;/a&gt;2. 核心方法&lt;/h1&gt;&lt;h2 id=&quot;2-1-ProcessText-bool-legacyMode-bool-full&quot;&gt;&lt;a href=&quot;#2-1-ProcessText-bool-legacyMode-bool-full&quot; class=&quot;headerlink&quot; title=&quot;2.1 ProcessText(bool legacyMode, bool full)&quot;&gt;&lt;/a&gt;2.1 ProcessText(bool legacyMode, bool full)&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;NGUIText.Update(false)&lt;/code&gt;：计算最终字体尺寸、space大小、行高&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NGUIText.WrapText&lt;/code&gt;：根据rectHeight、maxLines、finalLineHeight算出在widget最多可以容纳多少行。遍历每个字符，依旧获取glyph信息，并维护剩余宽度remainingWidth来决定是否截断显示字符串。该方法还会对空格和换行做一些特殊处理。最后输出fits表示rect是否能容纳得下应该显示的字符串，finalText表示最终显示的字符串&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NGUIText.CalculatePrintedSize(mProcessedText)&lt;/code&gt;：计算最终字符显示的区域大小，结果可从printedSize属性获取（小于等于rect大小）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;几种Overflow模式的基本原理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ShrinkContent缩放原理：循环从ps = mPrintedSize = defaultFontSize开始往下递减，直到ps可以满足在当前rect里容纳显示所有字符。例如当一个240×30的label不能一行显示字号为60的“New\nlabel”，则ps可能会递减到30左右，&lt;code&gt;NGUIText.WrapText&lt;/code&gt;计算出可以fit整个rect了，才停止循环。&lt;/li&gt;
&lt;li&gt;ClampContent裁切原理：实际上这种方式没有做任何处理，因为在&lt;code&gt;NGUIText.WrapText&lt;/code&gt;的时候就已经按rect大小做截断了&lt;/li&gt;
&lt;li&gt;ResizeFreely自适应原理：一开始先把rect和region设得足够大，WrapText之后再重算printedSize&lt;/li&gt;
&lt;li&gt;ResizeHeight：同ResizeFreely，但只会重设高度，不会重设宽度&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-2-OnFill-BetterList-verts-BetterList-uvs-BetterList-cols&quot;&gt;&lt;a href=&quot;#2-2-OnFill-BetterList-verts-BetterList-uvs-BetterList-cols&quot; class=&quot;headerlink&quot; title=&quot;2.2 OnFill(BetterList verts, BetterList uvs, BetterList cols)&quot;&gt;&lt;/a&gt;2.2 OnFill(BetterList&lt;vector3&gt; verts, BetterList&lt;vector2&gt; uvs, BetterList&lt;color32&gt; cols)&lt;/color32&gt;&lt;/vector2&gt;&lt;/vector3&gt;&lt;/h2&gt;&lt;p&gt;在UIWidget调用UpdateGeometry时用到。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;UpdateNGUIText&lt;/code&gt;：将label的各种属性复制到NGUIText的公共静态属性中&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NGUIText.Print(text, verts, uvs, cols)&lt;/code&gt;将文本内容输出到列表中。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ApplyOffset&lt;/code&gt;用偏移值变换顶点：原理是根据pivotOffset（锚点相对偏移，右上角为(1,1)）和label的宽高插值出offset，然后应用到顶点列表的每个顶点，最后返回offset&lt;/li&gt;
&lt;li&gt;如果有开启阴影，则调用一次ApplyShadow【增加一些顶点】；如果开启描边，则再调用3次ApplyShadow，实质上就是用四个方向的阴影包围来模拟描边&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-3-NGUIText-Print-text-verts-uvs-cols&quot;&gt;&lt;a href=&quot;#2-3-NGUIText-Print-text-verts-uvs-cols&quot; class=&quot;headerlink&quot; title=&quot;2.3 NGUIText.Print(text, verts, uvs, cols)&quot;&gt;&lt;/a&gt;2.3 NGUIText.Print(text, verts, uvs, cols)&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Prepare(text)&lt;/code&gt;：当使用动态字体时，调用Unity API &lt;code&gt;Font.RequestCharactersInTexture&lt;/code&gt;刷新所需字符的纹理&lt;/li&gt;
&lt;li&gt;遍历text的每个字符 =&amp;gt;&lt;/li&gt;
&lt;li&gt;处理换行符号，略过非法字符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ParseSymbol&lt;/code&gt;解析BBCode，该函数有很多ref参数，用于存放解析结果（如加粗、斜体、下划线等等）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GetSymbol(text, i, textLength)&lt;/code&gt;获取有没有图字符号（新版本NGUI label支持表情符解析），有符号走符号分支，否则进入普通字符分支。【下面只讲解普通字符分支】&lt;/li&gt;
&lt;li&gt;处理alignment为居中或右侧的情况&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;普通字符处理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;GetGlyph(ch, prev)&lt;/code&gt;：根据当前字符ch和上一个字符prev，会根据使用的是位图字体还是动态字体，计算出对应的UV坐标。【得到的GlyphInfo数据结构见下方解释】&lt;/li&gt;
&lt;li&gt;计算subscriptMode不为0（即上标或下标）的情况，算法：glyph.v0和glyph.v1乘以sizeShrinkage常量，然后根据上下标情况，上下偏移y坐标&lt;/li&gt;
&lt;li&gt;若x + w &amp;gt; regionWidth，则将字符换行&lt;/li&gt;
&lt;li&gt;若字符为空格：若BBCode对应是下划线，则替换为“下划线”；若对应中划线，则替换为“减号”；都不对应，则continue&lt;/li&gt;
&lt;li&gt;处理纹理坐标&lt;/li&gt;
&lt;li&gt;根据glyph.channel以不同方式计算顶点颜色&lt;/li&gt;
&lt;li&gt;处理粗体和斜体的情况&lt;/li&gt;
&lt;li&gt;处理下划线或中划线的情况&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;该方法最终会为每个字符，在uvs、cols、verts添加4个顶点数据，顺序为左下、左上、右上、右下&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;public class GlyphInfo
{
    public Vector2 v0;          // 字形在生成的text mesh中左下角屏幕坐标
    public Vector2 v1;          // 字形在生成的text mesh中的右上角屏幕坐标
    public Vector2 u0;          // UV左下角坐标
    public Vector2 u1;          // UV右上角坐标
    public float advance = 0f;  // 从本字符到下个字符的步进宽度
    public int channel = 0;     // RGBA通道值，通常为15（1+2+4+8）
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意在输出顶点数据前，已经调用&lt;code&gt;UpdateNGUIText&lt;/code&gt;确保NGUIText中已保存所需的数据。&lt;/p&gt;
&lt;h1 id=&quot;3-一些要注意的点&quot;&gt;&lt;a href=&quot;#3-一些要注意的点&quot; class=&quot;headerlink&quot; title=&quot;3. 一些要注意的点&quot;&gt;&lt;/a&gt;3. 一些要注意的点&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;使用动态字体时，Unity会生成要用到的字符的纹理，可能一开始是128×128的FontTexture就够了。若后面纹理不够用会重新生成一张新的更大的，触发&lt;a href=&quot;https://docs.unity3d.com/460/Documentation/ScriptReference/Font-textureRebuildCallback.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;textureRebuildCallback&lt;/a&gt;，对应到&lt;code&gt;UILabel.OnFontTextureChanged&lt;/code&gt;。这个方法会将所有引用到的label的字符，通过font.&lt;a href=&quot;https://docs.unity3d.com/460/Documentation/ScriptReference/Font.RequestCharactersInTexture.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;RequestCharactersInTexture&lt;/a&gt;这个API去把所有字符都推到新的字体纹理中。接着再把所有label从panel移除再添加回去。【字体破碎现象很可能就是因为字体纹理重建引起的）&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;UILabel是NGUI中用于显示文字的控件。其核心思想是遍历每个字符，将其转化为字体贴图的数据。本篇会抛开BBCode解析，表情符symbol解析，特殊效果（阴影、描边等）等细节，只记录几个渲染字体的核心方法。NGUI有独立的一套BMFont管理工具和类，等以后再另开篇章讲解。&lt;/p&gt;
&lt;p&gt;【参考版本：NGUI 3.6.9】&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="游戏开发" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
      <category term="Unity" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/Unity/"/>
    
      <category term="NGUI" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/Unity/NGUI/"/>
    
    
      <category term="NGUI" scheme="http://raytaylorlin.com/tags/NGUI/"/>
    
      <category term="Unity" scheme="http://raytaylorlin.com/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>NGUI源码学习——UICamera</title>
    <link href="http://raytaylorlin.com/tech/game/unity/ngui-code-uicamera/"/>
    <id>http://raytaylorlin.com/tech/game/unity/ngui-code-uicamera/</id>
    <published>2017-03-10T14:02:07.000Z</published>
    <updated>2017-08-05T06:16:03.747Z</updated>
    
    <content type="html">&lt;p&gt;UICamera是NGUI中专门用于捕获和分发交互事件的脚本，和UI渲染无关，需要挂在UI摄像机上。其核心思想是在Update中检测Input的各种输入情况，并对屏幕做raycast投射，以决定是哪个go的collider触发事件，最终将事件分发出去。&lt;/p&gt;
&lt;p&gt;【参考版本：NGUI 3.8.1】&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-核心数据结构或类型&quot;&gt;&lt;a href=&quot;#1-核心数据结构或类型&quot; class=&quot;headerlink&quot; title=&quot;1. 核心数据结构或类型&quot;&gt;&lt;/a&gt;1. 核心数据结构或类型&lt;/h1&gt;&lt;p&gt;有许多公共静态属性，如currentXXX，用于存放当前触发事件的摄像机、ray等等。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;EventType：分World_3D、UI_3D、World_2D、UI_2D，其中3D用&lt;code&gt;Physics.Raycast&lt;/code&gt;实现，2D用&lt;code&gt;Physics.OverlapPoint&lt;/code&gt;实现；World会根据触发点的世界距离排序（常用于游戏摄像机），UI会根据widget depth排序（常用于UI界面）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;enum ControlScheme&lt;/code&gt;：有鼠标、触摸、手柄三种类型，触发事件时会根据这个类型做相应的调整（如hover或selected事件的分发在不同设备是不一样的）&lt;/li&gt;
&lt;li&gt;MouseOrTouch数据结构：在事件触发之前会设置一些鼠标或触摸信息&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;public class MouseOrTouch
{
    public Vector2 pos;               // 当前鼠标或触摸的位置
    public Vector2 lastPos;           // 上一次鼠标或触摸的位置
    public Vector2 delta;             // 当前帧与上一帧的偏移
    public Vector2 totalDelta;        // delta的累积，通常用于drag事件

    public Camera pressedCam;         // OnPress(true)触发时对应的捕获事件的摄像机

    public GameObject last;           // 上一个触发触摸或鼠标事件的go
    public GameObject current;        // 当前触发触摸或鼠标事件的go
    public GameObject pressed;        // 上一个接收OnPress的go
    public GameObject dragged;        // 正在被拖拽的go

    public float clickTime = 0f;      // 上一次click事件的时间（通常用于判断doubleClick）

    public ClickNotification clickNotification = ClickNotification.Always;  // OnClick的触发条件，None为不触发，Always为总是触发，BasedOnDelta为根据位置移动的偏移量来决定是否发生（偏移量和Thresholds参数有关）
    public bool touchBegan = true;    // Touch模式下标识一个触摸是否为开始
    public bool pressStarted = false; // 标识是否开始按住
    public bool dragStarted = false;  // 标识是否开始拖拽
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下图为UICamera脚本的配置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://raytaylorlin-blog.qiniudn.com/image/unity/UICamera%E8%84%9A%E6%9C%AC%E7%9A%84%E9%85%8D%E7%BD%AE.jpg&quot; alt=&quot;UICamera脚本的配置&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;2-核心方法&quot;&gt;&lt;a href=&quot;#2-核心方法&quot; class=&quot;headerlink&quot; title=&quot;2. 核心方法&quot;&gt;&lt;/a&gt;2. 核心方法&lt;/h1&gt;&lt;h2 id=&quot;2-1-Notify-GameObject-go-string-funcName-object-obj&quot;&gt;&lt;a href=&quot;#2-1-Notify-GameObject-go-string-funcName-object-obj&quot; class=&quot;headerlink&quot; title=&quot;2.1 Notify(GameObject go, string funcName, object obj)&quot;&gt;&lt;/a&gt;2.1 Notify(GameObject go, string funcName, object obj)&lt;/h2&gt;&lt;p&gt;本质上是调用&lt;code&gt;go.SendMessage(funcName, obj)&lt;/code&gt;，这样就能&lt;strong&gt;触发到具体的UI控件中与funcName同名的方法&lt;/strong&gt;（正因为是通过这种特殊方式来调用，所以控件源码中一部分方法会查找不到引用，和反射的道理类似）。&lt;/p&gt;
&lt;p&gt;同时也会发一份消息到genericEventHandler这个用户自己设置的全局go，相当于一个全局的事件接收器。&lt;/p&gt;
&lt;h2 id=&quot;2-2-Update&quot;&gt;&lt;a href=&quot;#2-2-Update&quot; class=&quot;headerlink&quot; title=&quot;2.2 Update&quot;&gt;&lt;/a&gt;2.2 Update&lt;/h2&gt;&lt;p&gt;本质上是对UnityEngine.Input的封装和处理。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;根据useTouch或useMouse标记（在Awake中根据当前平台设置，如手机只有touch），选择执行&lt;code&gt;ProcessTouches&lt;/code&gt;或&lt;code&gt;ProcessMouse&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;调用用户自定义的委托&lt;code&gt;onCustomInput&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ProcessOthers&lt;/code&gt;处理键盘和手柄&lt;/li&gt;
&lt;li&gt;处理tooltip相关逻辑&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以&lt;code&gt;ProcessTouches&lt;/code&gt;为例，该方法中用&lt;code&gt;Input.GetTouch&lt;/code&gt;获取每个touch分别做如下处理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建MouseOrTouch结构并设置数据&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;ProcessTouch&lt;/code&gt;分发事件&lt;/li&gt;
&lt;li&gt;若touch数目为0，则转为&lt;code&gt;ProcessMouse&lt;/code&gt;或&lt;code&gt;ProcessFakeTouches&lt;/code&gt;（用于编辑器用鼠标模拟触摸）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ProcessTouch&lt;/code&gt;：根据传入的pressed，向&lt;code&gt;currentTouch.pressed&lt;/code&gt;分发OnPress事件；根据&lt;code&gt;currentTouch.delta&lt;/code&gt;或touch前后go是否不同，向&lt;code&gt;currentTouch.dragged&lt;/code&gt;和&lt;code&gt;currentTouch.last&lt;/code&gt;分发OnDragStart和OnDragOver事件；后续还有一段处理各种drag start、over、out的逻辑。根据传入的unpressed，分发OnClick、OnSelect、OnHover等事件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ProcessOthers&lt;/code&gt;：处理submit（如回车和手柄的按键）、方向键、返回键、tab键的情况，并对mCurrentSelection分发OnKey事件&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-3-RayCast（Vector3-inPos）&quot;&gt;&lt;a href=&quot;#2-3-RayCast（Vector3-inPos）&quot; class=&quot;headerlink&quot; title=&quot;2.3 RayCast（Vector3 inPos）&quot;&gt;&lt;/a&gt;2.3 RayCast（Vector3 inPos）&lt;/h2&gt;&lt;p&gt;给定位置判断有没有与控件产生交互，最终要得到hoveredObject这个结果。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;currentCamera.ScreenToViewportPoint(inPos)&lt;/code&gt;算出viewport的坐标，并排除一些异常情况&lt;ul&gt;
&lt;li&gt;【注：屏幕坐标左下角是(0,0)，右上角是(pixelWidth,pixelHeight)】，viewport坐标右上角是(1,1)】&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;currentCamera.ScreenPointToRay(inPos)&lt;/code&gt;将屏幕坐标转换为ray。UICamera有个表示射线长度的参数rangeDistance，默认为摄像机远近裁剪面的距离；eventReceiverMask表示摄像机投射ray时哪些层可以响应&lt;/li&gt;
&lt;li&gt;接下来根据EventType采用不同的算法来算ray射到的物体，以两种3D模式为例：&lt;ul&gt;
&lt;li&gt;World_3D：&lt;code&gt;if (Physics.Raycast(ray, out lastHit, dist, mask)) hoveredObject = lastHit.collider.gameObject&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;UI_3D：&lt;code&gt;Physics.RaycastAll(ray, dist, mask)&lt;/code&gt;获取射线穿到的所有hit，取每个hit对应的collider的go，计算其raycastDepth，并按从大到小排序&lt;/li&gt;
&lt;li&gt;hoveredObject = 上述最大的，且对应panel可见的hit对应的go&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;【定义：UIWidget.raycastDepth = 自身depth + 所属panel.depth * 1000】&lt;br&gt;【定义：&lt;code&gt;NGUITools.CalculateRaycastDepth(go)&lt;/code&gt;计算go下所有可用widget的raycastDepth的最小值】&lt;/p&gt;
&lt;p&gt;参考文献：&lt;a href=&quot;http://www.yarpee.com/?p=150&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Yarpee的博文《UICamera》&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;UICamera是NGUI中专门用于捕获和分发交互事件的脚本，和UI渲染无关，需要挂在UI摄像机上。其核心思想是在Update中检测Input的各种输入情况，并对屏幕做raycast投射，以决定是哪个go的collider触发事件，最终将事件分发出去。&lt;/p&gt;
&lt;p&gt;【参考版本：NGUI 3.8.1】&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="游戏开发" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
      <category term="Unity" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/Unity/"/>
    
      <category term="NGUI" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/Unity/NGUI/"/>
    
    
      <category term="NGUI" scheme="http://raytaylorlin.com/tags/NGUI/"/>
    
      <category term="Unity" scheme="http://raytaylorlin.com/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>状态模式与状态机</title>
    <link href="http://raytaylorlin.com/tech/complex/DP/fsm-and-state-pattern/"/>
    <id>http://raytaylorlin.com/tech/complex/DP/fsm-and-state-pattern/</id>
    <published>2017-01-30T13:42:47.000Z</published>
    <updated>2017-04-29T03:03:59.249Z</updated>
    
    <content type="html">&lt;p&gt;状态管理是几乎所有游戏开发都会做的一个事情——大到场景管理，小到角色的逻辑状态和动画切换。如果你面对日益增长的复杂的状态分支判断代码而不知所措，状态模式和状态机可能就是救星。状态模式是一个非常简单实用的模式，本文将介绍其基本用法，并结合游戏中的有限状态机（FSM）介绍其各种实际应用和特殊状态机。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-有限状态机&quot;&gt;&lt;a href=&quot;#1-有限状态机&quot; class=&quot;headerlink&quot; title=&quot;1. 有限状态机&quot;&gt;&lt;/a&gt;1. 有限状态机&lt;/h1&gt;&lt;p&gt;状态在游戏里面非常常见。想象一个横版过关游戏的主角有如下图状态转换。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://raytaylorlin-blog.qiniudn.com/image/engine/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E7%8A%B6%E6%80%81%E4%BE%8B%E5%AD%90.jpg&quot; alt=&quot;一个简单的游戏角色状态例子&quot; title=&quot;avatar&quot;&gt;&lt;/p&gt;
&lt;p&gt;FSM有以下特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;拥有一组状态，它们之间可以互相切换&lt;/li&gt;
&lt;li&gt;状态机同一时刻只能处于一种状态（事实上防止同时存在两个状态正是使用FSM的原因）&lt;/li&gt;
&lt;li&gt;状态机会接收一组输入或事件&lt;/li&gt;
&lt;li&gt;每个状态有一组转换，每一个转换都关联一个输入并指向另一个状态&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最普通（也是不可取）的做法，是&lt;em&gt;先用if/else分支来判断输入，再用各种bool变量来标记当前是否处于某种状态&lt;/em&gt;。随着功能和状态的增加，会不经意破坏已有代码的功能，并引入更多的标记变量使逻辑更加复杂。&lt;/p&gt;
&lt;p&gt;更进一步的做法是将每种状态定义为枚举，颠倒一下上面的处理顺序，&lt;em&gt;先用switch/case判断状态，再在状态中判断输入并做状态切换&lt;/em&gt;。如果状态非常少而且不太可能扩展，这是实现状态机最简单有效的做法。&lt;/p&gt;
&lt;p&gt;当问题满足以下几点要求时，FSM将会非常有用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个实体的行为基于它内部状态而改变&lt;/li&gt;
&lt;li&gt;这些状态被严格划分为数量较少的小集合&lt;/li&gt;
&lt;li&gt;实体随着时间变化会响应用户输入或一些特殊事件&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;2-状态模式&quot;&gt;&lt;a href=&quot;#2-状态模式&quot; class=&quot;headerlink&quot; title=&quot;2. 状态模式&quot;&gt;&lt;/a&gt;2. 状态模式&lt;/h1&gt;&lt;p&gt;状态模式实际上就是&lt;strong&gt;将复杂的各个分支判断分离出来成为一个个单独的状态类（继承同个状态基类），然后在业务类中维护状态基类指针m_state，通过多态来分发和切换&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;为了修改一个状态，之前的做法是给m_state赋值新的枚举值（或常量数字），而将状态抽象为类之后，有两种做法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;静态状态：如果一个状态对象没有数据成员，可以在状态基类（或其他地方）定义static状态对象。【进一步的，若状态仅包含一个虚函数方法，可以用状态函数来替代状态类，这样m_state就编程函数指针】&lt;/li&gt;
&lt;li&gt;实例化状态：若同类的状态会被多个对象维护，就不能使用静态状态了，只能在状态切换时动态创建实例（要留意清理老的状态实例）。此外，在状态类的处理虚函数中，可以返回一个新的状态实例表示下一个要切换的状态（返回null则状态不变），这样业务类就能根据返回的结果修改m_state的值。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;3-特殊种类的状态机&quot;&gt;&lt;a href=&quot;#3-特殊种类的状态机&quot; class=&quot;headerlink&quot; title=&quot;3. 特殊种类的状态机&quot;&gt;&lt;/a&gt;3. 特殊种类的状态机&lt;/h1&gt;&lt;h2 id=&quot;3-1-并发状态机&quot;&gt;&lt;a href=&quot;#3-1-并发状态机&quot; class=&quot;headerlink&quot; title=&quot;3.1 并发状态机&quot;&gt;&lt;/a&gt;3.1 并发状态机&lt;/h2&gt;&lt;p&gt;设想一个角色有跑、跳、躲避等状态，现在要添加持枪功能（包括不开火和开火两种状态）。如果执着于传统的FSM，则可能需要跑动和跑动开火等n*m种状态。如果使用并行的两个状态机，则只需要n+m种状态。&lt;/p&gt;
&lt;p&gt;具体实现上，只需要定义多一个状态成员变量，在响应事件多派发一次即可。这种实现适用于两个状态互相独立。若两个状态有依赖，例如不能在跳跃过程中开火，则可能需要在特定的状态中做一些简单的if判断，必要时还需要引用另一个状态。&lt;/p&gt;
&lt;h2 id=&quot;3-2-层次状态机&quot;&gt;&lt;a href=&quot;#3-2-层次状态机&quot; class=&quot;headerlink&quot; title=&quot;3.2 层次状态机&quot;&gt;&lt;/a&gt;3.2 层次状态机&lt;/h2&gt;&lt;p&gt;假设一个角色无论处于站立、走路、跑动、滑动哪个状态，按下B时都要跳跃，按下↓方向键都要躲避。若只用简单的FSM，则会重复不少代码（比如这个例子需要处理4*2个状态转换）。可以在状态模式的基础上，采用继承的方式来复用代码，例如定义OnGroundState来处理跳跃和躲避的状态，四种状态从OnGroundState继承。当有一个事件进来时，如果子状态不处理，则将事件传递给父状态处理。&lt;/p&gt;
&lt;p&gt;不过要注意，这种方法&lt;strong&gt;仅仅只是为了复用代码而去继承，并不符合继承的语义&lt;/strong&gt;，像上例中WalkState“是”（is-a）一种OnGroundState吗？因此选用这种“继承层次”的状态机要慎重。&lt;/p&gt;
&lt;h2 id=&quot;3-3-下推自动机&quot;&gt;&lt;a href=&quot;#3-3-下推自动机&quot; class=&quot;headerlink&quot; title=&quot;3.3 下推自动机&quot;&gt;&lt;/a&gt;3.3 下推自动机&lt;/h2&gt;&lt;p&gt;这种状态机使用一个状态&lt;strong&gt;栈&lt;/strong&gt;，来解决FSM没有历史记录的问题。举个例子，角色可以从任一状态切换到开火状态，该状态会播放动画，发射子弹并显示一些特效，合理来说开火完成之后应该回到之前的状态。若只用简单的FSM，则需要为每个状态定义一个反向的转换。而使用状态栈时，通过push和pop来记录新状态和恢复历史状态。记住当前状态永远在栈顶，如果不需要历史记录，则切换状态时，总把栈顶的状态修改为最新的状态即可。&lt;/p&gt;
&lt;p&gt;参考文献：《游戏编程模式》第7章&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;状态管理是几乎所有游戏开发都会做的一个事情——大到场景管理，小到角色的逻辑状态和动画切换。如果你面对日益增长的复杂的状态分支判断代码而不知所措，状态模式和状态机可能就是救星。状态模式是一个非常简单实用的模式，本文将介绍其基本用法，并结合游戏中的有限状态机（FSM）介绍其各种实际应用和特殊状态机。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="综合" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/"/>
    
      <category term="设计模式" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://raytaylorlin.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="状态模式" scheme="http://raytaylorlin.com/tags/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="状态机" scheme="http://raytaylorlin.com/tags/%E7%8A%B6%E6%80%81%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>游戏开发中单例模式的一些思考</title>
    <link href="http://raytaylorlin.com/tech/complex/DP/singleton-thinking/"/>
    <id>http://raytaylorlin.com/tech/complex/DP/singleton-thinking/</id>
    <published>2017-01-29T13:27:31.000Z</published>
    <updated>2017-01-29T13:28:53.581Z</updated>
    
    <content type="html">&lt;p&gt;往往设计模式的书都是教人如何使用模式，唯独单例模式需要谨慎对待，甚至避免使用。像其他设计决策一样，一旦将一些不必要的单例进行了硬编码，就会带来麻烦。本文描述了单例模式的一些常见问题，以及一些参考解决方案。虽然单例模式存在一些问题，但只要不滥用并仔细思考设计，还是可以享受它带来的好处的。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-单例模式的基础&quot;&gt;&lt;a href=&quot;#1-单例模式的基础&quot; class=&quot;headerlink&quot; title=&quot;1. 单例模式的基础&quot;&gt;&lt;/a&gt;1. 单例模式的基础&lt;/h1&gt;&lt;h2 id=&quot;1-1-使用方法&quot;&gt;&lt;a href=&quot;#1-1-使用方法&quot; class=&quot;headerlink&quot; title=&quot;1.1 使用方法&quot;&gt;&lt;/a&gt;1.1 使用方法&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;单例模式确保一个类只有一个实例，并为其提供一个全局访问入口。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;该模式用于一个类如果有多个实例就不能正常运作的情形。最常见的是，这个类与一个&lt;strong&gt;维持着自身全局状态的&lt;/strong&gt;外部系统进行交互的情况。像封装底层文件操作API的类，必须知道之前的每一步操作，才能对创建文件和删除文件这些互斥的操作做出正确的反应。&lt;/p&gt;
&lt;p&gt;具体实现上，一个单例类一般会遵循这些规则：private构造方法使得对象只能在类的内部实例化，通过public静态属性来访问这个对象，如以下C++代码所示（以封装文件操作API类为例）。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class FileSystem
{
public:
    static FileSystem&amp;amp; Instance()
    {
        // C++11保证一个局部静态变量初始化只进行一次，因此是线程安全的
        static FileSystem* instance = new FileSytem();
        return *instance;
    }
private:
    FileSystem() {}
};
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;1-2-模式的特性&quot;&gt;&lt;a href=&quot;#1-2-模式的特性&quot; class=&quot;headerlink&quot; title=&quot;1.2 模式的特性&quot;&gt;&lt;/a&gt;1.2 模式的特性&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;如果不使用这个类，就不会创建实例&lt;/li&gt;
&lt;li&gt;在运行时初始化：若是单纯使用静态类而不是单例，则编译器在main函数调用前就自动初始化静态数据了。这意味着&lt;strong&gt;不能使用运行时才知道的信息&lt;/strong&gt;（如从文件中加载的配置），也&lt;strong&gt;不能在单例间互相依赖&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;继承单例是一个强大但经常被忽视的特性：参见下面文件封装类跨平台的例子。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;class FileSystem
{
public:
    virtual ~FileSystem() {}
    virtual char* Read(char* path) = 0;
protected:
    FileSystem() {}
};

class PS3FileSystem : public FileSystem
{
public:
    virtual char* Read(char* path) { // 调用PS3的文件API }
}

class WiiFileSystem : public FileSystem
{
public:
    virtual char* Read(char* path) { // 调用Wii的文件API }
}

// 关键的跨平台实现
FileSystem&amp;amp; FileSystem::Instance()
{
#if PLATFORM == PLAYSTATION3
    static FileSystem *instance = new PS3FileSystem();
#elif PLATFORM == WII
    static FileSystem *instance = new WiiFileSystem();
#endif
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;2-单例的劣势&quot;&gt;&lt;a href=&quot;#2-单例的劣势&quot; class=&quot;headerlink&quot; title=&quot;2. 单例的劣势&quot;&gt;&lt;/a&gt;2. 单例的劣势&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;单例本质是封装到类中的全局变量&lt;ul&gt;
&lt;li&gt;令代码晦涩难懂&lt;/li&gt;
&lt;li&gt;全局变量促进了耦合：例如全局音频单例类AudioPlayer穿插在各种业务代码中用于播放声音&lt;/li&gt;
&lt;li&gt;对并发不友好：多个线程都能访问和修改全局变量，很容易导致死锁，条件竞争或其他难以发现的线程同步的bug&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;单例是个画蛇添足的解决方案：“提供一个全局访问入口”，是使用单例模式的主要原因。像日志类Logger，系统各模块的日志都通过这个单例汇集到一个文件。但这样做的限制是不能创建多个日志器，不能将日志分割为不同的文件。如果后期要修改设计支持多个实例，还需要找出像&lt;code&gt;Logger.Instance.Write&lt;/code&gt;这样的调用并逐个修改&lt;/li&gt;
&lt;li&gt;延迟初始化剥离了控制：有的系统初始化时需要耗费一定时间，若在第一次使用时才初始化则可能会引起性能问题。因此在一些对性能有要求的单例中，一般不依赖延迟初始化，即直接像&lt;code&gt;static Singleton m_instance&lt;/code&gt;这样定义静态变量，在编译时初始化；或者在恰当的时机（如加载界面）去“假调用”令其初始化&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;备注：选择单例还是静态类，取决于后来是否需要将静态类转换为非静态，前者可以传递实例，而后者需要修改每处调用的代码&lt;/p&gt;
&lt;h1 id=&quot;3-一些参考解决方案&quot;&gt;&lt;a href=&quot;#3-一些参考解决方案&quot; class=&quot;headerlink&quot; title=&quot;3. 一些参考解决方案&quot;&gt;&lt;/a&gt;3. 一些参考解决方案&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;首先考虑究竟是否需要类：游戏中有许多类都是“管理器”，像SoundManager、ParticleManager，包括其他命名如“XXSystem”、“XXEngine”也类似。在设计这样的功能时，要仔细思考一下究竟是否需要类，是否需要单例模式。&lt;/li&gt;
&lt;li&gt;传递对象到函数中，而不是在函数中调用单例函数：像一些渲染物体的函数需要访问代表图形设备的对象并维护渲染状态，则可能会传递一个context对象到渲染函数中。但另一方面，也要考虑对象是否真的属于某个函数的签名的一部分，像处理AI的函数可能需要写日志，但传递一个Logger对象进去就不合适。&lt;/li&gt;
&lt;li&gt;将单例的获取限制在继承树中：为了进一步减小单例的“全局影响”，可以考虑在基类（如GameObject）中设置单例，并提供一个protected方法供子类获取示例。&lt;/li&gt;
&lt;li&gt;通过其他全局对象访问：可能存在代表整个游戏状态的全局Game或World对象，可以考虑将各种全局对象类包装到这种全局类里面，像&lt;code&gt;Game::Instance.GetAudioPlayer().Play&lt;/code&gt;这样调用。这种做法的好处是如果后续要支持多个Game实例（如用于流处理或测试），则几乎不需要修改其他单例类，副作用就是更多的代码耦合到了Game中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考文献：《游戏编程模式》第6章&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;往往设计模式的书都是教人如何使用模式，唯独单例模式需要谨慎对待，甚至避免使用。像其他设计决策一样，一旦将一些不必要的单例进行了硬编码，就会带来麻烦。本文描述了单例模式的一些常见问题，以及一些参考解决方案。虽然单例模式存在一些问题，但只要不滥用并仔细思考设计，还是可以享受它带来的好处的。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="综合" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/"/>
    
      <category term="设计模式" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://raytaylorlin.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="单例模式" scheme="http://raytaylorlin.com/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>游戏引擎的事件系统</title>
    <link href="http://raytaylorlin.com/tech/game/engine/event-system/"/>
    <id>http://raytaylorlin.com/tech/game/engine/event-system/</id>
    <published>2017-01-18T12:03:09.000Z</published>
    <updated>2017-01-18T12:06:32.858Z</updated>
    
    <content type="html">&lt;p&gt;游戏本质上是事件驱动的。事件是游戏过程中发生、希望关注的事情，例如发生爆炸、玩家被敌人看见、拾取补血包等等。游戏通常需要一些方法做两件事——当事件发生时通知关注该事件的对象，以及让那些对象回应所关注的事件。事件系统采用的设计模式便是知名的观察者模式，本文将介绍事件系统的一些基本原理，以及事件排队的扩展机制。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;为了通知游戏对象一个事件己发生，最简单的方法是调用该对象的方法，更进一步的是调用欲通知对象的虚函数。虚函数的后期绑定在某种程度上降低了实现的弹性，实际上，使用静态类型的虚函数作为事件处理程序，会导致GameObject基类需要声明游戏中所有可能出现的事件！这样会令创建新事件变得困难，也阻止了以数据驱动方式产生事件，也违背了让某些类仅注册自己希望关注的事件的初衷。&lt;/p&gt;
&lt;h1 id=&quot;1-事件系统的原理&quot;&gt;&lt;a href=&quot;#1-事件系统的原理&quot; class=&quot;headerlink&quot; title=&quot;1 事件系统的原理&quot;&gt;&lt;/a&gt;1 事件系统的原理&lt;/h1&gt;&lt;h2 id=&quot;1-1-把事件封装成对象&quot;&gt;&lt;a href=&quot;#1-1-把事件封装成对象&quot; class=&quot;headerlink&quot; title=&quot;1.1 把事件封装成对象&quot;&gt;&lt;/a&gt;1.1 把事件封装成对象&lt;/h2&gt;&lt;p&gt;事件实质上由两个部分组成：类型及参数，其中参数为事件提供细节。因此可以把这两个部分封装成事件对象，伪代码如下所示。有些游戏引擎称这种事件结构为消息（message）或命令（command），这些名称强调了本质上，把事件通知对象等于向对象发送消息或命令。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct Event
{
    const U32 MAX_ARGS= 8;
    EventType m_type;
    U32 m_numArgs;
    EventArg m_aArgs[MAX_ARGS];
};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;把事件封装为对象有这些好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;仅需单个事件处理函数：任何数量的事件类型都可以表示为单个类的实例，仅需要单个虚函数处理所有事件类型（如&lt;code&gt;virtual void OnEvent(Event&amp;amp; event)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;持久性：事件对象把其类型及参数储存为数据，因此具有持久性，可用于储存队列稍后处理，或者复制及广播至多个接收者等&lt;/li&gt;
&lt;li&gt;盲目地转发事件：对象可以转发事件至另一对象，而不需要知道事件的内容&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-2-事件类型&quot;&gt;&lt;a href=&quot;#1-2-事件类型&quot; class=&quot;headerlink&quot; title=&quot;1.2 事件类型&quot;&gt;&lt;/a&gt;1.2 事件类型&lt;/h2&gt;&lt;p&gt;最简单的方法是使用一个全局的枚举，把每个事件类型映射至一个唯一整数。此方法的优点在于简单及高效，缺点是游戏中所有事件类型都要集中在一起（有点破坏封装的意味，见仁见智）；事件类型是硬编码的，意味着新的事件类型不可通过数据驱动的方式来定义；枚举是索引，有时在中间插入新类型可能会引起一些次序相关的问题。&lt;/p&gt;
&lt;p&gt;另一个事件类型编码方法是使用字符串。此方法是完全自由形式，但问题是有较大机会产生事件名称冲突，也有机会因拼错字而导致不能正常运作，字符串所消耗的内存也较多。不过可以做一些辅助工具来规避字符串带来的风险。在实际项目中，以上两种方法都有被使用，关键还是要权衡其利弊及项目的实际情况。&lt;/p&gt;
&lt;h2 id=&quot;1-3-事件参数&quot;&gt;&lt;a href=&quot;#1-3-事件参数&quot; class=&quot;headerlink&quot; title=&quot;1.3 事件参数&quot;&gt;&lt;/a&gt;1.3 事件参数&lt;/h2&gt;&lt;p&gt;事件的参数通常与函数的参数很相似，而且理论上可以支持任意种类和任意数量的参数。像1.1中代码的&lt;code&gt;EventArg&lt;/code&gt;，如果是在C#/Java中，可以将任意类型参数封箱为object发送。但如果是在C/C++中，则只能使用&lt;code&gt;void*&lt;/code&gt;指针来模拟，或者使用C++的template模拟。书中还描述了一种用C/C++ union实现的可以容纳多种类型的Variant数据结构，但通用性较弱，此处不赘述。&lt;/p&gt;
&lt;p&gt;事件参数采用以索引为基础的集合，有个问题是参数的意义取决于储存的次序，发送方及接受方都必须理解事件以什么次序储存参数，这可能会导致混淆及bug。可以采用键值对的数据结构来封装一系列事件参数，并通过有实际意义命名的key来提取参数。&lt;/p&gt;
&lt;h2 id=&quot;1-4-注册事件与事件处理器&quot;&gt;&lt;a href=&quot;#1-4-注册事件与事件处理器&quot; class=&quot;headerlink&quot; title=&quot;1.4 注册事件与事件处理器&quot;&gt;&lt;/a&gt;1.4 注册事件与事件处理器&lt;/h2&gt;&lt;p&gt;大部分游戏对象只会关注很小的事件集合，每次都多播或广播事件是很低效的事情。为了提高事件处理的效率，可以让对象注册它们所关注的事件。例如，每个事件类型维护一个链表，内含关注该事件类型的对象，当特定事件触发时只需遍历列表逐个通知即可。&lt;/p&gt;
&lt;p&gt;当游戏对象接收到一个事件，需要以某种方式做出回应，此过程称为事件处理，并通常实现成称为事件处理器（event handler）的函数。在一些高级语言中，可以通过存储函数指针（C/C++）或委托（C#）来注册回调函数，并在收到特定事件时调用。随后，取出&lt;code&gt;EventArg&lt;/code&gt;并拆箱还原为原来的参数类型，对其进行处理。&lt;/p&gt;
&lt;p&gt;游戏对象之间经常有依赖性，事件有时需要沿着依赖链传递下去。通常，事件传递的次序是预先由开发者决定的，在事件处理器中通过返回一个布尔值以表示该对象是否处理了该事件，以及是否继续往下转发。支持职责链的事件处理器大概如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;virtual bool SomeObject::OnEvent(Event&amp;amp; event)
{
    // 先调用基类的处理器
    if (BaseClass::OnEvent(event))
        return true;  // 基类处理器已处理了事件，返回true表示不再转发
    switch (event.GetType())
    {
        case EVENT_ATTACK:
            ResponseToAttack(event.GetAttackinfo());
            return false; // 可以转发事件给其他对象
        case EVENT_HEALTH_PACK:
            AddHealth(event.GetHealthPack().GetHealth());
            return true; // 消化了事件，不再转发
        // ......
        default:
            return false;  // 无法识别该事件，转发给其他对象
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;即时事件处理器可能导致非常深的调用堆栈，例如对象A向对象B发送一个事件，然后B的事件处理器又发出另一个事件，如此反复。在逻辑有误或使用不当的情况下，极深的调用堆栈有可能会用尽堆栈空间（尤其是造成无限循环的事件发送）。关键还是要遵循一些编码原则，并把事件处理器实现为完全可重入函数，即以递归方式调用事件处理器并不会有任何不良副作用。&lt;/p&gt;
&lt;h1 id=&quot;2-事件排队机制&quot;&gt;&lt;a href=&quot;#2-事件排队机制&quot; class=&quot;headerlink&quot; title=&quot;2. 事件排队机制&quot;&gt;&lt;/a&gt;2. 事件排队机制&lt;/h1&gt;&lt;p&gt;上述的事件机制都是在发送事件时便马上被处理，有的引擎也会容许把事件排队留待未来某刻才进行处理。事件排队有以下好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;控制事件处理的时机：让开发者多一道措施确保事件在安全及合适的时机获得处理&lt;/li&gt;
&lt;li&gt;往未来投递事件的能力：可以设置事件的触发时间（例如下一帧、数秒后），这样就相当于实现了一个定时器。具体实现方式：把队列中的事件按送达时间排序，在每帧中先检查队列中首个事件的送达时间，若还未到送达时间，就可立即终止处理（排序保证了之后的事件也是未到时间的）&lt;/li&gt;
&lt;li&gt;处理同时刻事件的优先次序：事件的送达时间通常会量化为整数帧，因此存在同一帧处理多个事件而无法确定顺序的问题。解决方法是为事件设置优先次序（根据需要用整型或若干档枚举表示），当同帧多事件触发时按优先级排序。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用事件队列需要考虑的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;增加事件系统的复杂度：给系统加上此功能会增加开发时间和维护成本&lt;/li&gt;
&lt;li&gt;深度复制事件及其参数：若事件是触发后即时处理的，事件参数所占用堆栈内存在事件消费完即销毁。但如果使用事件队列，则需要将整个事件对象（包括参数）深度复制到队列，这样才能&lt;strong&gt;确保没有仅对发送者作用域数据的悬垂引用，并且容许事件无限期储存&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;为队列中的事件做动态内存分配：要注意考虑深度复制导致的&lt;strong&gt;动态内存分配开销&lt;/strong&gt;，可以考虑快速且不会造成碎片的池分配器或其他小型内存分配器&lt;/li&gt;
&lt;li&gt;调试困难：不能在调试器的调用堆栈看出事件从何而来，以及检查发送者的状态和发送时的环境情况。调试延时事件会变得棘手，若事件会被对象转发的话调试会更加困难&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考文献：电子工业出版社《游戏引擎架构》第14.7节&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;游戏本质上是事件驱动的。事件是游戏过程中发生、希望关注的事情，例如发生爆炸、玩家被敌人看见、拾取补血包等等。游戏通常需要一些方法做两件事——当事件发生时通知关注该事件的对象，以及让那些对象回应所关注的事件。事件系统采用的设计模式便是知名的观察者模式，本文将介绍事件系统的一些基本原理，以及事件排队的扩展机制。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="游戏开发" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
      <category term="游戏引擎" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    
      <category term="游戏引擎" scheme="http://raytaylorlin.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
      <category term="事件" scheme="http://raytaylorlin.com/tags/%E4%BA%8B%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>运行时游戏对象模型（下）——实时更新游戏对象</title>
    <link href="http://raytaylorlin.com/tech/game/engine/realtime-update-gameobject/"/>
    <id>http://raytaylorlin.com/tech/game/engine/realtime-update-gameobject/</id>
    <published>2017-01-13T13:33:32.000Z</published>
    <updated>2017-01-13T13:38:40.379Z</updated>
    
    <content type="html">&lt;p&gt;大多数低阶引擎子系统，以及游戏对象，都需要周期性更新。差不多所有游戏引擎都在主游戏循环里更新游戏对象的状态，换句话说，它们把游戏对象模型当作另一个需要周期性运行的引擎子系统。本文将简要介绍关于实时更新游戏对象的设计方式及常见问题。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-实时更新对象的方式&quot;&gt;&lt;a href=&quot;#1-实时更新对象的方式&quot; class=&quot;headerlink&quot; title=&quot;1. 实时更新对象的方式&quot;&gt;&lt;/a&gt;1. 实时更新对象的方式&lt;/h1&gt;&lt;p&gt;一种最简单但&lt;strong&gt;不可行&lt;/strong&gt;的实现方式是，每个游戏对象都有一个虚函数&lt;code&gt;virtual void Update(float dt)&lt;/code&gt;，游戏主循环在每一帧遍历全体游戏对象集合并逐一调用Update。每个Update所做的事情大致是更新对象自身的逻辑数据，然后逐个更新其组件（如动画、渲染、粒子、声音组件）。&lt;/p&gt;
&lt;h2 id=&quot;1-1-性能限制与批次式更新&quot;&gt;&lt;a href=&quot;#1-1-性能限制与批次式更新&quot; class=&quot;headerlink&quot; title=&quot;1.1 性能限制与批次式更新&quot;&gt;&lt;/a&gt;1.1 性能限制与批次式更新&lt;/h2&gt;&lt;p&gt;低阶引擎系统都有极严竣的性能限制，&lt;strong&gt;把多个游戏对象的同个子系统更新组合起来批次处理&lt;/strong&gt;，要比上述&lt;em&gt;多个游戏对象交错更新子系统&lt;/em&gt;更高效，如下图所示。像渲染引擎就是使用批次式更新的典型例子。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://raytaylorlin-blog.qiniudn.com/image/engine/%E4%BA%A4%E9%94%99%E5%BC%8F%E6%9B%B4%E6%96%B0%E4%B8%8E%E6%89%B9%E6%AC%A1%E5%BC%8F%E6%9B%B4%E6%96%B0%E7%9A%84%E5%8C%BA%E5%88%AB.jpg&quot; alt=&quot;交错式更新与批次式更新的区别&quot;&gt;&lt;/p&gt;
&lt;p&gt;批次式更新带来很多性能效益，包括但不限于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最高的缓存一致性：子系统能把各对象的所需数据分配到一个连续的内存区里&lt;/li&gt;
&lt;li&gt;最少的重复运算：可以先执行整体的运算，之后在各对象更新中重用，无须每次在对象中重新计算&lt;/li&gt;
&lt;li&gt;减少资源再分配：交错式更新处理每个对象时须释放及再分配资源，批次式更新则只需每批次一次&lt;/li&gt;
&lt;li&gt;高效的流水线：在某些硬件上可以做一些优化，利用硬件特设的资源并行计算&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;性能优势并不是使用批次式更新的唯一原因，&lt;strong&gt;一些引擎子系统从根本上不能以对象单位进行更新&lt;/strong&gt;。例如，若一个动力学系统里有多个刚体进行碰撞决议时，孤立地逐一考虑对象，一般不能找到满意的解。&lt;/p&gt;
&lt;h2 id=&quot;1-2-对象及子系统的相互依赖&quot;&gt;&lt;a href=&quot;#1-2-对象及子系统的相互依赖&quot; class=&quot;headerlink&quot; title=&quot;1.2 对象及子系统的相互依赖&quot;&gt;&lt;/a&gt;1.2 对象及子系统的相互依赖&lt;/h2&gt;&lt;p&gt;要正确运行游戏，游戏对象更新的次序是重要的（例如计算某物体的局部坐标需要先计算其父节点的世界坐标）。除了对象之间有依赖关系，各子系统也有依赖关系，而且不是简单的先后关系，例如布娃娃物理模拟系统须与动画系统协同更新。可以在主循环中明确编写各个子系统的更新顺序。&lt;/p&gt;
&lt;p&gt;主循环通常不能简化成每帧每对象调用一次Update，游戏对象可能需要使用多个引擎子系统的中间结果。很多游戏引擎容许游戏对象在1帧中的多个时机编写对应的虚函数“挂钩”进行更新，像Unity GameObject的Update、FixedUpdate、LateUpdate等。游戏对象可按需增加更多更新阶段，但要小心带来多余的调用空的虚函数开销可能很高。&lt;/p&gt;
&lt;h2 id=&quot;1-3-桶式更新&quot;&gt;&lt;a href=&quot;#1-3-桶式更新&quot; class=&quot;headerlink&quot; title=&quot;1.3 桶式更新&quot;&gt;&lt;/a&gt;1.3 桶式更新&lt;/h2&gt;&lt;p&gt;当存在对象间的依赖时，可能会抵触更新次序的规则，有时要轻微调整上述的批次式更新技巧。即不要一次性批处理所有游戏对象，而是把对象按依赖关系分为若干群组（或称为桶bucket），即没有任何依赖关系的对象（依赖树的根）放到第1个桶，依赖树第2层的所有对象放到第2个桶……然后按依赖次序更新每个桶，桶中使用批次式更新，如下图所示。游戏引擎可以明确为依赖树林的深度设限，这样就可以使用固定数目的桶以提高性能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://raytaylorlin-blog.qiniudn.com/image/engine/%E6%8C%89%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BE%9D%E8%B5%96%E6%80%A7%E5%88%86%E6%A1%B6%E6%9B%B4%E6%96%B0.jpg&quot; alt=&quot;按对象的依赖性分桶更新&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;2-对象状态及“差一帧”延迟&quot;&gt;&lt;a href=&quot;#2-对象状态及“差一帧”延迟&quot; class=&quot;headerlink&quot; title=&quot;2. 对象状态及“差一帧”延迟&quot;&gt;&lt;/a&gt;2. 对象状态及“差一帧”延迟&lt;/h1&gt;&lt;p&gt;更新游戏对象可视为这样一个过程：每个对象根据$t_1$时刻的状态决定$t_2$（$t_2=t_1+\Delta t$）时刻的状态。理论上，所有游戏对象的状态是瞬间及并行地从时刻$t_1$更新至$t_2$的。但实际上主循环会逐个更新对象，在一轮循环中间中断时则有一些对象处于部分更新的状态（例如某个对象可能已执行姿势动画混合，却未计算物理及碰撞决议）。&lt;/p&gt;
&lt;p&gt;游戏对象在两帧之间状态不一致是混淆和bug的主要来源。当有对象依赖时（如对象B需要根据对象A的速度来决定当前帧自身的速度），程序员必须弄清楚需要的是对象A的之前的状态还是新状态。若需要新状态，而对象A却未更新，就会产生一个更新次序问题，会导致一类称为“差一帧”延迟的bug。解决这个问题通常有以下做法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;桶式更新：上节已描述，但是必须保证同一个桶内的对象不会互相查询状态&lt;/li&gt;
&lt;li&gt;对象状态缓存：更新时不要就地覆写新的状态，而是保留之前的状态变量，并把新的状态写到另一个变量。这样任何对象都可安全地查询其他对象的之前状态；而且就算是在更新的过程中，它保证永远有一个完全一致的状态；还能通过线性地向前后两个状态插值。这种方法的缺点是多耗一倍内存，而且只能保证在$t_1$状态一致，而$t_2$状态不一定一致&lt;/li&gt;
&lt;li&gt;加上时戳：给每个对象加时戳可轻易分辨对象的状态是在之前还是当前时间&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考文献：电子工业出版社《游戏引擎架构》第14.6节&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;大多数低阶引擎子系统，以及游戏对象，都需要周期性更新。差不多所有游戏引擎都在主游戏循环里更新游戏对象的状态，换句话说，它们把游戏对象模型当作另一个需要周期性运行的引擎子系统。本文将简要介绍关于实时更新游戏对象的设计方式及常见问题。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="游戏开发" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
      <category term="游戏引擎" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    
      <category term="游戏引擎" scheme="http://raytaylorlin.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
      <category term="游戏对象模型" scheme="http://raytaylorlin.com/tags/%E6%B8%B8%E6%88%8F%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>运行时游戏对象模型（上）——模型架构</title>
    <link href="http://raytaylorlin.com/tech/game/engine/runtime-gameobject-model/"/>
    <id>http://raytaylorlin.com/tech/game/engine/runtime-gameobject-model/</id>
    <published>2016-12-31T14:37:32.000Z</published>
    <updated>2016-12-31T14:52:35.540Z</updated>
    
    <content type="html">&lt;p&gt;在游戏性基础系统的各种组件中，运行时对象模型可能是最复杂的，通常它会提供这些核心功能：动态产生（spawn）和销毁（destroy）游戏对象，联系底层引擎系统，实时模拟对象行为，对象查询和引用，存档及对象持久性等等。本文将从对象模型架构开始，阐述“以对象为中心”和“以属性为中心”的两种基本架构，接着介绍几种游戏对象引用和查询的方法。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-各种运行时对象模型架构&quot;&gt;&lt;a href=&quot;#1-各种运行时对象模型架构&quot; class=&quot;headerlink&quot; title=&quot;1. 各种运行时对象模型架构&quot;&gt;&lt;/a&gt;1. 各种运行时对象模型架构&lt;/h1&gt;&lt;h2 id=&quot;1-1-以对象为中心的架构&quot;&gt;&lt;a href=&quot;#1-1-以对象为中心的架构&quot; class=&quot;headerlink&quot; title=&quot;1.1 以对象为中心的架构&quot;&gt;&lt;/a&gt;1.1 以对象为中心的架构&lt;/h2&gt;&lt;p&gt;这种架构中每个逻辑游戏对象会实现为类的实例，或一组互相连接的实例。然而单纯使用继承和多态会导致一系列类层次结构的问题。&lt;/p&gt;
&lt;h3 id=&quot;1-1-1-使用面向对象架构的问题&quot;&gt;&lt;a href=&quot;#1-1-1-使用面向对象架构的问题&quot; class=&quot;headerlink&quot; title=&quot;1.1.1 使用面向对象架构的问题&quot;&gt;&lt;/a&gt;1.1.1 使用面向对象架构的问题&lt;/h3&gt;&lt;p&gt;类层次结构逐渐变得单一庞大。如下图①实现《吃豆人》（PacMan）的一种简单类结构，随着功能增长，该结构会同时往纵、横方向发展，并出现以下问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类难以理解、维护及修改：要理解一个类，就要理解其所有父类（例如在派生类中修改一个看似无害的虚函数，就可能会违背了众基类中某个基类的假设），参考下图②复杂的单一类树节选&lt;/li&gt;
&lt;li&gt;不能表达多维分类：继承有着“是一个”的语义，导致在分类对象时只能从一个维度去设计。如下图③，各类载具的分类看似合乎逻辑，但如果再加入一种“水陆两用载具”则无从下手&lt;/li&gt;
&lt;li&gt;多重继承的弊端：解决“水陆两用载具”的解决方法之一就是使用C++的多重继承，如下图④。然而多重继承有其严重弊端，此处不再赘述&lt;/li&gt;
&lt;li&gt;使用接口：像C#或Java类只能继承一个类，但可以实现多个接口，这样共用的功能就能抽出来（也称为mix-in类）。如下图⑤，任何继承MHealth的类会有血量信息，并可以被杀&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;冒泡效应&lt;/strong&gt;：当游戏加入越来越多的功能，程序员很容易不断把若干个类中&lt;strong&gt;公用但与基类无关&lt;/strong&gt;的代码上升到基类中（即为了所谓的复用利用了继承的便利），这种趋势会令功能代码沿层次结构上移到基类（冒泡），从而违背类职责应该保持单一的原则&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://raytaylorlin-blog.qiniudn.com/image/engine/%E4%BD%BF%E7%94%A8%E5%8D%95%E4%B8%80%E5%BA%9E%E5%A4%A7%E7%9A%84%E7%B1%BB%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E7%9A%84%E5%90%84%E7%A7%8D%E9%97%AE%E9%A2%98.jpg&quot; alt=&quot;使用单一庞大的类层次结构的各种问题&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;1-1-2-使用“合成”来简化层次结构&quot;&gt;&lt;a href=&quot;#1-1-2-使用“合成”来简化层次结构&quot; class=&quot;headerlink&quot; title=&quot;1.1.2 使用“合成”来简化层次结构&quot;&gt;&lt;/a&gt;1.1.2 使用“合成”来简化层次结构&lt;/h3&gt;&lt;p&gt;面向对象设计中过度使用“是一个（is-a）”关系，会限制了我们创造新游戏类型的设计选择，而且难以扩展现存类的功能。若像下图左边的继承结构，希望一个游戏对象类有碰撞功能，它必须要继承自CollidableObject ，即使它可能是隐形的而并不需要RenderableObject的功能。若把不同的功能分离为独立的“组件”类，它们互不相干，由一个轻量的GameObject采用“有一个（has-a）”关系持有并管理，如下图右边，则可以大大简化。Unity便是运用这种思想的例子。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://raytaylorlin-blog.qiniudn.com/image/engine/%E4%BD%BF%E7%94%A8%E7%BB%84%E4%BB%B6%E5%90%88%E6%88%90%E6%B8%B8%E6%88%8F%E5%AF%B9%E8%B1%A1.jpg&quot; alt=&quot;使用组件合成游戏对象&quot;&gt;&lt;/p&gt;
&lt;p&gt;对于GameObject管理其组件声明周期的具体实现，具体的做法是GameObject持有所有可能组件的指针并默认为空，而具体的游戏对象继承GameObject后，自行初始化所需的基本组件，并实现自己的特殊组件。但是当需要扩展新组件时，都要修改GameObject类，不符合开闭原则，因此更好的做法是以下这种GameObject持有Component列表的结构。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://raytaylorlin-blog.qiniudn.com/image/engine/%E4%BD%BF%E7%94%A8%E9%80%9A%E7%94%A8%E7%BB%84%E4%BB%B6%E7%9A%84%E8%AE%BE%E8%AE%A1.jpg&quot; alt=&quot;使用通用组件的设计&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-2-以属性为中心的架构&quot;&gt;&lt;a href=&quot;#1-2-以属性为中心的架构&quot; class=&quot;headerlink&quot; title=&quot;1.2 以属性为中心的架构&quot;&gt;&lt;/a&gt;1.2 以属性为中心的架构&lt;/h2&gt;&lt;p&gt;以对象为中心，会自然地关注对象属性和行为。以属性为中心，则是先定义所有属性，再为每个属性键表存储关联该属性的对象，&lt;em&gt;像数据库表就是这种设计&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;这种设计的优点是趋向更有效地使用内存，因为只需储存实际上用到的属性；也更容易使用数据驱动的方式来建模。最后是比以对象为中心的模型更加缓存友好，因为有些游戏硬件的内存存取成本远高于执行指令和运算。把数据连续储存于内存之中，能减少或消除缓存命中失败。这种数据布局方式称为&lt;strong&gt;数组的结构（struct of array）&lt;/strong&gt;。以下代码展示了与传统 &lt;em&gt;结构的数组（array of struct）&lt;/em&gt;的对比。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static const U32 MAX_GAME_OBJECTS = 1024;
// 传统结构的数组方式
struct GameObject
{
    U32 m_uniqueId;
    Vector m_pos;
    Quaternion m_rot;
};
GameObject g_AllGameObjects[MAX_GAME_OBJECTS];

// 对缓存更友好的数组的结构方式
struct AllGameObjects
{
    U32 m_UniqueId[MAX_GAME_OBJECTS];
    Vector m_Pos[MAX_GAME_OBJECTS];
    Quaternion m_Rot[MAX_GAME_OBJECTS];
}
AllGameObjects g_allGameObjects;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这种设计的缺点是单凭凑齐一些细粒度的属性去实现一个大规模的行为，并非易事。这种系统也可能更难以除错，因为程序员不能一次性地把游戏对象拉到监视视窗中检查它的属性。&lt;/p&gt;
&lt;h1 id=&quot;2-对象引用与世界查询&quot;&gt;&lt;a href=&quot;#2-对象引用与世界查询&quot; class=&quot;headerlink&quot; title=&quot;2. 对象引用与世界查询&quot;&gt;&lt;/a&gt;2. 对象引用与世界查询&lt;/h1&gt;&lt;h2 id=&quot;2-1-对象引用方法&quot;&gt;&lt;a href=&quot;#2-1-对象引用方法&quot; class=&quot;headerlink&quot; title=&quot;2.1 对象引用方法&quot;&gt;&lt;/a&gt;2.1 对象引用方法&lt;/h2&gt;&lt;h3 id=&quot;2-1-1-指针&quot;&gt;&lt;a href=&quot;#2-1-1-指针&quot; class=&quot;headerlink&quot; title=&quot;2.1.1 指针&quot;&gt;&lt;/a&gt;2.1.1 指针&lt;/h3&gt;&lt;p&gt;每个游戏对象通常需要某种唯一标识符以便互相区分，并且能在运行时或工具方（世界编辑器）找到所需的对象，也可用该标识符作为对象间通信的目标。当通过查询找到一个游戏对象时，需要以某种方式引用它。C/C++中最常见的做法就是使用指针，因为指针是实现对象引用最快、最高效并最容易使用的方式。但使用指针很容易出现孤立对象、过时指针、无效指针等问题，所以开发引擎的团队制定严格的编程惯例，或使用安全的约束方法如智能指针。&lt;/p&gt;
&lt;p&gt;智能指针是一个小型对象，行为与指针非常接近，但其扩展了规避原始C/C++指针所衍生的问题。关于智能指针可参考C++的一些高级书目，此处不赘述，仅建议&lt;strong&gt;尽量不要在项目中尝试自己实现恶心的智能指针&lt;/strong&gt;，如果必须使用，尽量选用像Boost这样的成熟实现。&lt;/p&gt;
&lt;h3 id=&quot;2-1-2-句柄&quot;&gt;&lt;a href=&quot;#2-1-2-句柄&quot; class=&quot;headerlink&quot; title=&quot;2.1.2 句柄&quot;&gt;&lt;/a&gt;2.1.2 句柄&lt;/h3&gt;&lt;p&gt;句柄就是某全局句柄表的整数索引，而句柄表则储存指向引用对象的指针。下图说明了此数据结构。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://raytaylorlin-blog.qiniudn.com/image/engine/%E5%8F%A5%E6%9F%84%E5%BC%95%E7%94%A8%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8.jpg&quot; alt=&quot;句柄引用对象的实现方式及常见应用&quot;&gt;&lt;/p&gt;
&lt;p&gt;虽然句柄可以实现为原始整数，但句柄表的索引通常会包装成一个简单类，以提供更方便创建句柄和解引用的接口。以下是一种简单实现（省略其他与句柄无关的实现）。注意在。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/* GameObject类储存了它的句柄索引，当要创建新句柄时就不用以地址搜寻句柄表了 */
class GameObject
{
private:
    GameObjectId m_uniqueId;  // 对象唯一标识符
    U32 m_handleIndex;  // 供更快地创建句柄
    friend class GameObjectHandle;  // 让它访问id及索引
public:
    GameObject()
    {
        m_uniqueId = AssignUniqueObjectId();
        m_handleIndex = FindFreeSlotInHandleTable();
    }
}

// 定义句柄表的大小，以及同时间的最大对象数目
static const U32 MAX_GAME_OBJECTS = ...;
// 全局句柄表，只是简单的数组，储存游戏对象指针
static GameObject* g_apGameObject[MAX_GAME_OBJECTS];

/* 句柄封装类 */
class GameObjectHandle
{
private：
    U32 m_handleIndex;
    GameObjectId m_uniqueId;
public:
    explicit GameObjectHandle(GameObject&amp;amp; object) :
        m_handleIndex(object.m_handleIndex),
        m_uniqueId(object.m_uniqueId) {}
    // 句柄解引用
    GameObject* ToObject() const
    {
        GameObject* pObject = g_apGameObject[m_handleIndex];
        if (pObject != NULL &amp;amp;&amp;amp; pObject-&amp;gt;m_uniqueId == m_uniqueId)
            return pObject;
        return NULL;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;2-2-对象查询方法&quot;&gt;&lt;a href=&quot;#2-2-对象查询方法&quot; class=&quot;headerlink&quot; title=&quot;2.2 对象查询方法&quot;&gt;&lt;/a&gt;2.2 对象查询方法&lt;/h2&gt;&lt;p&gt;取决于具体的游戏设计，开发者需要根据业务来查询不同种类的对象，例如找出玩家视线范围内的所有敌人角色，找出所有血量少于80%的可破坏游戏对象等等。游戏团队通常要判断，在游戏开发过程中哪些是可能最常用到的查询类型，并实现专用的数据结构加速查询。以下列举了一些可用于加速某类游戏对象查询的专门的数据结构。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以唯一标识符搜寻：游戏对象的指针或句柄可储存于以唯一标识符为键的散列表或二叉查找树&lt;/li&gt;
&lt;li&gt;对合乎某条件的所有对象进行迭代：可预先以某种条件排序，并把结果储存在某个列表（例如不断维护一个在玩家某半径范围内的所有对象的列表来加速查询实现范围内的敌人）&lt;/li&gt;
&lt;li&gt;搜寻抛射体路径或对某目标点视线内的所有对象：通常会利用碰撞系统实现，多数碰撞系统会提供一些极快的光线投射功能&lt;/li&gt;
&lt;li&gt;搜寻某区域或半径范围内的所有对象：用一些空间散列数据结构去储存游戏对象，如四叉树、八叉树、kd树等等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考文献：电子工业出版社《游戏引擎架构》第14.1、14.2、14.5节&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在游戏性基础系统的各种组件中，运行时对象模型可能是最复杂的，通常它会提供这些核心功能：动态产生（spawn）和销毁（destroy）游戏对象，联系底层引擎系统，实时模拟对象行为，对象查询和引用，存档及对象持久性等等。本文将从对象模型架构开始，阐述“以对象为中心”和“以属性为中心”的两种基本架构，接着介绍几种游戏对象引用和查询的方法。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="游戏开发" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
      <category term="游戏引擎" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    
      <category term="游戏引擎" scheme="http://raytaylorlin.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
      <category term="游戏对象模型" scheme="http://raytaylorlin.com/tags/%E6%B8%B8%E6%88%8F%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>游戏引擎的游戏性系统简介</title>
    <link href="http://raytaylorlin.com/tech/game/engine/gameplay-system-introduction/"/>
    <id>http://raytaylorlin.com/tech/game/engine/gameplay-system-introduction/</id>
    <published>2016-12-21T08:45:32.000Z</published>
    <updated>2016-12-25T13:21:42.410Z</updated>
    
    <content type="html">&lt;p&gt;游戏引擎是复杂的多层软件系统，而游戏的本质，并非在于其使用的引擎或技术，而是其游戏性（gameplay）。游戏机制（game mechanics）一词，可以把游戏性这个概念变得更为具体。游戏机制通常定义为一些规则，这些规则主宰了游戏中多个实体之间的互动，如定义玩家的目标、成败的准则、角色的各种能力、游戏体验的整体流程等等。本文将简单介绍用于定义及管理游戏机制的引擎系统及相关工具。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-剖析游戏世界&quot;&gt;&lt;a href=&quot;#1-剖析游戏世界&quot; class=&quot;headerlink&quot; title=&quot;1. 剖析游戏世界&quot;&gt;&lt;/a&gt;1. 剖析游戏世界&lt;/h1&gt;&lt;p&gt;游戏类型虽然五花八门，但大多数会有一种基本的结构模式，通常由以下部分组成：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;世界元素&lt;ul&gt;
&lt;li&gt;静态元素：地形、建筑等等几乎不会动或主动与游戏性交互的物体&lt;/li&gt;
&lt;li&gt;动态元素：角色、NPC、道具、粒子特效、动态光源、区域等等&lt;/li&gt;
&lt;li&gt;区分静态和动态元素，主要是用于优化性能——静态元素都可以预先计算或忽略，减少运行时游戏世界中动态元素的运算&lt;/li&gt;
&lt;li&gt;有一些游戏含有可破坏环境，算是模糊静态和动态元素分界的例子，说明元素是否静态并不是绝对的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;世界组块：庞大的游戏世界通常会被拆分成为独立可玩的区域，可以演化成关卡、地图、地区等等。分割关卡有几个原因，首先是内存限制；其次它也是一个控制游戏整体流程的方便机制；最后它可以作为分工的单位，方便开发团队分别构建及管理。&lt;/li&gt;
&lt;li&gt;高级游戏流程：指由玩家&lt;strong&gt;目标&lt;/strong&gt;所组成的序列、树或图，可演化成任务、关卡、波（如塔防波次）、胜利条件或失败惩罚。在故事驱动的游戏中，流程可能也包含多个游戏内置电影、过场动画。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;2-游戏世界编辑器&quot;&gt;&lt;a href=&quot;#2-游戏世界编辑器&quot; class=&quot;headerlink&quot; title=&quot;2. 游戏世界编辑器&quot;&gt;&lt;/a&gt;2. 游戏世界编辑器&lt;/h1&gt;&lt;h2 id=&quot;2-1-典型功能&quot;&gt;&lt;a href=&quot;#2-1-典型功能&quot; class=&quot;headerlink&quot; title=&quot;2.1 典型功能&quot;&gt;&lt;/a&gt;2.1 典型功能&lt;/h2&gt;&lt;p&gt;游戏性内容对应的创作工具便是游戏世界编辑器，其用于定义世界组块，并填入静态及动态元素。所有商用游戏引擎都有某种形式的世界编辑工具，大部分会提供以下列出的主要功能。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;世界组块创建及管理：除了组块管理基本功能外，还可以连接若干静态网格，以及AI用的导航地图、可攀抓边缘信息等等静态数据。有的还提供专门的地形编辑器用于编辑地形（或解析高度场地形）和水体。&lt;/li&gt;
&lt;li&gt;可视化游戏世界：可让开发者大幅提高开发效率，通常3D游戏提供顶、侧、正视图和三维透视视图4部分，2D游戏提供正射视角。有的编辑器直接整合自制的渲染引擎至工具中，有的把自身整合至第三方3D软件，有的会通过与实际的游戏引擎通信，利用游戏引擎来渲染三维视图，甚至整合至游戏引擎本身。&lt;/li&gt;
&lt;li&gt;导航：提供滚动、放大缩小、聚焦某个对象旋转、摄像机飞行模式、记录历史摄像机位置并跳转等等方便开发的功能。&lt;/li&gt;
&lt;li&gt;选取：在编辑器中可以选取个别或框选多个游戏对象，并对它们批量操作。使用光线投射方式选取三维对象时，编辑器可让用户循环选取与光线相交的所有对象，而不是总选取最近者。&lt;/li&gt;
&lt;li&gt;图层：把对象用预设或用户自定义的图层来分组，把游戏世界中的内容有条理地组织起来。图层也是分工的重要工具，多人可以在同个世界组块上的不同图层工作而不冲突。&lt;/li&gt;
&lt;li&gt;属性网格：如下图所示，可视化编辑游戏对象的属性（一般是键值对），不仅可以编辑常见的数值和字符串，还能支持下拉框、复选框、滑块、颜色选取器等控件编辑。&lt;ul&gt;
&lt;li&gt;选取多个对象后的编辑方式：此高级特性把选中的对象的共有属性混合在一起显示。在网格中编辑公共值时，会把新值更新至所有选取对象的属性中。&lt;/li&gt;
&lt;li&gt;自由格式属性：通常这种属性集会关联到某个用户自定义的对象，以形成新的“自由格式”属性，如光源属性集包含位置、方向、颜色、强度及光源类型属性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://raytaylorlin-blog.qiniudn.com/image/engine/%E5%B1%9E%E6%80%A7%E7%BD%91%E6%A0%BC%E7%A4%BA%E4%BE%8B.jpg&quot; alt=&quot;属性网格示例&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;安放对象及对齐辅助工具：除了基本的平移、旋转、缩放工具外，有的编辑器还提供对齐至网格，对齐至地形，对齐至对象，多个对象分布或对齐等功能。&lt;/li&gt;
&lt;li&gt;特殊对象类型&lt;ul&gt;
&lt;li&gt;光源：通常用特殊图标表示，因为光源没有网格。编辑器可能会尝试模拟光源对场景的照明效果，让设计师能实时调整并能看到场景的最终大致效果。&lt;/li&gt;
&lt;li&gt;粒子发射器：若编辑器是独立于渲染引擎之上，则可简单用图标表示，或尝试在编辑器中模拟效果；若编辑器是内置于游戏引擎，则可以实际模拟调整，达到“所见即所得”的效果。&lt;/li&gt;
&lt;li&gt;区域：即空间中的体积，供游戏侦测相关事件用（如Unity中的trigger）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;读/写世界组块：有的引擎把每个组块储存为单个文件，有的可以独立读/写个别的图层；有的引擎使用自定义的二进制文件格式，有的使用如XML的文本格式。&lt;/li&gt;
&lt;li&gt;快速迭代：优秀的编辑器会支持某程度的动态微调功能以供快速迭代。有的编辑器在游戏本身内执行，让用户即时看到改动的效果，有的连接至运行中的游戏，或完全脱机运行。具体的机制并不重要，最重要的是给用户足够短的往返迭代时间。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-2-集成资产管理工具&quot;&gt;&lt;a href=&quot;#2-2-集成资产管理工具&quot; class=&quot;headerlink&quot; title=&quot;2.2 集成资产管理工具&quot;&gt;&lt;/a&gt;2.2 集成资产管理工具&lt;/h2&gt;&lt;p&gt;有些引擎的编辑器会整合游戏资产数据库的其他方面功能，例如设定网格/材质的属性、设定动画/混合树/动画状态机、设置对象的碰撞/物理属性、管理材质资源等，著名的例子有UnrealEd和Unity。它们能对用户提供统一、实时、所见即所得的资产管理视图，促进快速高效的游戏开发过程。&lt;/p&gt;
&lt;p&gt;不同的工具对资产的优化时间点也不一样。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;UnrealEd在导入资产时就会对资产优化，这样在关卡设计上能缩短法代时间，但是改动网格、动画、音频等来源资产会变得更痛苦。&lt;/li&gt;
&lt;li&gt;Source及雷神之锤引擎，把资产优化延后至烘焙关卡、执行游戏之前。&lt;/li&gt;
&lt;li&gt;《光环（Halo）》给用户选择在任意时刻转换原始资源——这些资源在第一次载入至引擎前转换至优化格式并缓存，避免每次执行游戏时都要再做无意义的转换。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;3-游戏性基础系统的组件&quot;&gt;&lt;a href=&quot;#3-游戏性基础系统的组件&quot; class=&quot;headerlink&quot; title=&quot;3. 游戏性基础系统的组件&quot;&gt;&lt;/a&gt;3. 游戏性基础系统的组件&lt;/h1&gt;&lt;p&gt;如果可以合理地画出游戏与游戏引擎的分界线，那么游戏性基础系统就是刚刚位于该线之下。理论上，我们可以建立一个游戏性基础系统，其大部分是各个游戏皆通用的。实际上不同引擎之间有许多共有模式，以下列出一些常用组件，后续的文章就会逐渐记录这些组件的功能和设计方法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;运行时游戏对象（runtime game object）模型&lt;/li&gt;
&lt;li&gt;实时更新对象模型&lt;/li&gt;
&lt;li&gt;关卡管理及串流&lt;/li&gt;
&lt;li&gt;目标及游戏流程管理&lt;/li&gt;
&lt;li&gt;消息及事件处理&lt;/li&gt;
&lt;li&gt;脚本&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考文献：电子工业出版社《游戏引擎架构》第13章&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;游戏引擎是复杂的多层软件系统，而游戏的本质，并非在于其使用的引擎或技术，而是其游戏性（gameplay）。游戏机制（game mechanics）一词，可以把游戏性这个概念变得更为具体。游戏机制通常定义为一些规则，这些规则主宰了游戏中多个实体之间的互动，如定义玩家的目标、成败的准则、角色的各种能力、游戏体验的整体流程等等。本文将简单介绍用于定义及管理游戏机制的引擎系统及相关工具。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="游戏开发" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
      <category term="游戏引擎" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    
      <category term="游戏引擎" scheme="http://raytaylorlin.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
      <category term="游戏性系统" scheme="http://raytaylorlin.com/tags/%E6%B8%B8%E6%88%8F%E6%80%A7%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>人体学接口设备（HID）</title>
    <link href="http://raytaylorlin.com/tech/game/engine/human-interface-device/"/>
    <id>http://raytaylorlin.com/tech/game/engine/human-interface-device/</id>
    <published>2016-07-13T08:45:32.000Z</published>
    <updated>2016-07-13T08:54:40.612Z</updated>
    
    <content type="html">&lt;p&gt;游戏是有互动性的计算机模拟，为游戏而设的人体学接口设备（Human Interface Device，HID）种类繁多，包括摇杆、手柄、键盘、鼠标、Wii遥控器，以及方向盘、跳舞毯、电子吉他等等专用输入设备。本文探讨游戏引擎如何自入体学接口设备读取输入，处理输入，以及向玩家反馈输出。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-HID的接口技术&quot;&gt;&lt;a href=&quot;#1-HID的接口技术&quot; class=&quot;headerlink&quot; title=&quot;1. HID的接口技术&quot;&gt;&lt;/a&gt;1. HID的接口技术&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;轮询&lt;ul&gt;
&lt;li&gt;像手柄这样的简单设备，可通过定期轮询硬件来读取输入（通常在主游戏循环里每次迭代轮询一次）&lt;/li&gt;
&lt;li&gt;要明确查询（输出）设备的状态，可直接读取硬件寄存器；读取经内存映射的I/O端口，或通过较高级的软件接口间接读取&lt;/li&gt;
&lt;li&gt;微软为Xbox 360手柄而设的XInput API是简单轮询的好例子。游戏在每帧调用&lt;code&gt;XInputGetState()&lt;/code&gt;函数，它与硬件／驱动通信，适当地读取数据，并把所有结果包装成&lt;code&gt;XINPUT_STATE&lt;/code&gt;结构，此结构含有手柄设备上所有输入的当前状态&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;中断：像鼠标这样的设备没必要在静止时还不断发送数据。这类设备通常以硬件中断方式来通信。中断服务程序用来读取设备状态，把状态储存以供后续处理，然后交还CPU给主程序&lt;/li&gt;
&lt;li&gt;无线设备：对于蓝牙设备，软件必须以&lt;strong&gt;蓝牙协议&lt;/strong&gt;和它们通信。这种通信一般由引擎主线程以外的线程负责处理，或至少被封装为简单接口供主循环调用。从程序员的角度来说，蓝牙基本和其他传统轮询设备的状态一样&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;2-HID的输入输出类型&quot;&gt;&lt;a href=&quot;#2-HID的输入输出类型&quot; class=&quot;headerlink&quot; title=&quot;2. HID的输入输出类型&quot;&gt;&lt;/a&gt;2. HID的输入输出类型&lt;/h1&gt;&lt;h2 id=&quot;2-1-输入类型&quot;&gt;&lt;a href=&quot;#2-1-输入类型&quot; class=&quot;headerlink&quot; title=&quot;2.1 输入类型&quot;&gt;&lt;/a&gt;2.1 输入类型&lt;/h2&gt;&lt;h3 id=&quot;2-1-1-数字式按钮&quot;&gt;&lt;a href=&quot;#2-1-1-数字式按钮&quot; class=&quot;headerlink&quot; title=&quot;2.1.1 数字式按钮&quot;&gt;&lt;/a&gt;2.1.1 数字式按钮&lt;/h3&gt;&lt;p&gt;数字式按钮只有两个状态——按下（down或press）或释放（up或release），软件中则以1或0表示。有时设备上所有按钮的状态会结合为一个无符号整数值，如XBox 360手柄的状态是以&lt;code&gt;XINPUT_GAMEPAD&lt;/code&gt;结构传回。这个结构体第一个字段是一个16位无符号整数变量wButtons，存放所有按钮的状态。每个按钮都会定义一个掩码，实际使用时将wButtons和掩码做&amp;amp;运算来判断是否被按下。&lt;/p&gt;
&lt;h3 id=&quot;2-1-2-模拟式轴和相对性轴&quot;&gt;&lt;a href=&quot;#2-1-2-模拟式轴和相对性轴&quot; class=&quot;headerlink&quot; title=&quot;2.1.2 模拟式轴和相对性轴&quot;&gt;&lt;/a&gt;2.1.2 模拟式轴和相对性轴&lt;/h3&gt;&lt;p&gt;模拟式输入是指可获取一个范围以内的数值。此类输入通常用来代表摇杆的二维位置（使用两个模拟输入， 一个x轴一个y轴）。模拟式输入信号通常都要被数字化，表示为软件中的整数，再送入引擎处理。像Xbox 360手柄拇指摇杆的偏转量（sThumbLX/sThumbLY/sThumbRX/sThumbRY）取值范围是-32768~32767，而左右扳机（bLeftTrigger/bRightTrigger）取值范围是0（没扣压）~255（完全扣压）。&lt;/p&gt;
&lt;p&gt;上述模拟式轴的位置都是&lt;strong&gt;绝对&lt;/strong&gt;的，而有些输入是&lt;strong&gt;相对&lt;/strong&gt;性的。这类设备不能界定在哪个位置的输入值为0，相反，输入为0代表设备的位置没变动，非零值代表自上次读取输入至今的增量，如鼠标、鼠标滚轮和轨迹球等等。&lt;/p&gt;
&lt;h3 id=&quot;2-1-3-加速计及三维定向&quot;&gt;&lt;a href=&quot;#2-1-3-加速计及三维定向&quot; class=&quot;headerlink&quot; title=&quot;2.1.3 加速计及三维定向&quot;&gt;&lt;/a&gt;2.1.3 加速计及三维定向&lt;/h3&gt;&lt;p&gt;Wii遥控器、PS3的Sixaxis及智能手机都包含加速传感器，能感应xyz三个主轴的加速度。Wii的一些游戏会利用3个加速计去估算控制器在玩家手上的定向。其原理是基于我们在地球表面上玩这些游戏，而地球的1g引力能对物体产生固定的向下加速度。&lt;/p&gt;
&lt;p&gt;若把控制器完美地水平放置，并指向电视方向，那么垂直方向（z）的加速计应量度到大约-1g。若垂直握着控制器，使其指向上方，则可以预期z应为0，而y应为1g（ 因为y传感器会感受到完整的引力效果）。当我们校准加速计得知每个轴的零点，就可以使用逆正弦和逆余弦，轻松求得偏航角、俯仰角和滚动角。&lt;/p&gt;
&lt;h2 id=&quot;2-2-输出类型&quot;&gt;&lt;a href=&quot;#2-2-输出类型&quot; class=&quot;headerlink&quot; title=&quot;2.2 输出类型&quot;&gt;&lt;/a&gt;2.2 输出类型&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;震动反馈：模拟游戏角色在游戏中受到扰动或撞击等感觉。震动通常由若干个马达驱动，每个马达带有稍不平衡的负重，以不同速度旋转。游戏可开关这些马达，并通过调节其旋转速度来向玩家双手产生不同的触觉效果&lt;/li&gt;
&lt;li&gt;力反馈：通过由马达驱动的制动器，以其产生的力对抗玩家施于HID上的力。常见于街机赛车游戏——当玩家尝试转方向盘时，方向盘会产生阻力，其输出原理同震动反馈&lt;/li&gt;
&lt;li&gt;其他输入/输出：有些HID设备含扬声器、麦克风等音频接口；较老的像Dreamcast的手柄支持插入记忆卡；Xbox 360手柄和Wii遥控器带有4个软件控制的LED灯；乐器、跳舞毯等特殊设备有其专门的输入／输出类型；近年发展的姿势界面（如Kinect）和VR设备，也是非常独特的HID&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;3-游戏引擎的HID系统&quot;&gt;&lt;a href=&quot;#3-游戏引擎的HID系统&quot; class=&quot;headerlink&quot; title=&quot;3. 游戏引擎的HID系统&quot;&gt;&lt;/a&gt;3. 游戏引擎的HID系统&lt;/h1&gt;&lt;p&gt;多数游戏引擎不会直接使用HID的原始输入数据，而是引入至少一个在HID和游戏之间的间接层，将输入以多种形式抽象化。下面会介绍一些HID系统的典型需求。&lt;/p&gt;
&lt;h2 id=&quot;3-1-死区&quot;&gt;&lt;a href=&quot;#3-1-死区&quot; class=&quot;headerlink&quot; title=&quot;3.1 死区&quot;&gt;&lt;/a&gt;3.1 死区&lt;/h2&gt;&lt;p&gt;假定模拟轴的输入值范围是$I_{min}$到$I_m$，未触碰模拟轴时，稳定及清晰的“未扰动”输入值为$I_0$。&lt;/p&gt;
&lt;p&gt;HID本质上是模拟设备，其产生的电压含有噪声，以致实际上量度到的输入会轻微$I_0$附近浮动。解决办法是引入一个围绕$I_0$的死区。对于摇杆，死区可以定义为$[I_0-\sigma, I_0+\sigma]$；对于扳机，则定义为$[I_0, I_0+\sigma]$。任何位于死区的输入值都可以简单地被钳制为$I_0$。死区必须足够大以容纳未扰动控制的最大噪声，同时也必须足够小以免影响玩家对HID的反应手感。&lt;/p&gt;
&lt;h2 id=&quot;3-2-模拟信号过滤&quot;&gt;&lt;a href=&quot;#3-2-模拟信号过滤&quot; class=&quot;headerlink&quot; title=&quot;3.2 模拟信号过滤&quot;&gt;&lt;/a&gt;3.2 模拟信号过滤&lt;/h2&gt;&lt;p&gt;即使控制器不在死区范围，其输入仍会有信号噪声问题，这些噪声有时候会导致游戏中的行为显得抖动或不自然。由于噪声信号的频率通常比玩家产生的要高。所以，解决办法之一是，先利用低通滤波器过滤原始输入，再把结果传送至游戏中使用。&lt;/p&gt;
&lt;p&gt;结合未过滤输入的时变函数$u(t)$，己过滤输入为$f(t)=(1-a)f(t-\Delta t)+au(t)$，其中参数$a$由帧持续时间$\Delta t$和过滤常数$RC$所确定，即$a=\frac{\Delta t}{RC+\Delta t}$。公式转换C++代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;F32 lowPassFilter(F32 unfilteredInput, F32 lastFramesFilteredInput, F32 rc, F32 dt) {
    F32 a = dt / (rc + dt);
    return (1 - a) * lastFramesFilteredInput + a * unfilteredInput;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;另一个过滤HID输入的方法是计算移动平均。例如，若要计算3帧时间范围内的输入数据平均，只需把原始输入数据简单地储存于3个元素大小的循环缓冲区里，把此数组的值求和除3，就是过滤后的输入值。因为初始时该数组并未填满有效数据，要注意处理前两帧的输入。&lt;/p&gt;
&lt;h2 id=&quot;3-3-输入事件检测&quot;&gt;&lt;a href=&quot;#3-3-输入事件检测&quot; class=&quot;headerlink&quot; title=&quot;3.3 输入事件检测&quot;&gt;&lt;/a&gt;3.3 输入事件检测&lt;/h2&gt;&lt;h3 id=&quot;3-3-1-按下和释放按钮&quot;&gt;&lt;a href=&quot;#3-3-1-按下和释放按钮&quot; class=&quot;headerlink&quot; title=&quot;3.3.1 按下和释放按钮&quot;&gt;&lt;/a&gt;3.3.1 按下和释放按钮&lt;/h3&gt;&lt;p&gt;假设按钮的输入位在释放时为0，按下时为1。可以记录上一帧的状态（32位位整型），和本帧的状态位异或，为1的位表示状态发生变化。再审视每个按钮的当前状态，若某按钮的状态有改变，而当前的状态是按下，则产生按下事件，否则产生释放事件。&lt;/p&gt;
&lt;h3 id=&quot;3-3-2-弦（chord）&quot;&gt;&lt;a href=&quot;#3-3-2-弦（chord）&quot; class=&quot;headerlink&quot; title=&quot;3.3.2 弦（chord）&quot;&gt;&lt;/a&gt;3.3.2 弦（chord）&lt;/h3&gt;&lt;p&gt;弦是指一组按钮，当同时被按下时，会在游戏中产生一个独特行为。一般通过检测两个或以上的按钮状态，当该组按钮全部同时被按下才执行操作。但弦有许多细节值得注意：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;小心避免同时产生个别按钮的动作和弦的动作。要在检测个别按钮的时候，同时检查弦里的&lt;strong&gt;其他按键并没有被按下&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;弦的检测代码必须健壮，防止人们按下弦中的某一按钮稍早于其他按钮。有几种方法可以处理这些情况&lt;ul&gt;
&lt;li&gt;从策划的角度，将按钮输入设计为，弦总是作用于某个按钮的动作再加上额外的动作。例如，若按L1是主武器开火，按L2投射手榴弹，可能L1+L2的弦是令主要武器开火、投射手榴弹，并发送能量波使这些武器的伤害力加倍。这样从玩家的角度来说游戏表现出的行为没有不同&lt;/li&gt;
&lt;li&gt;在个别按钮按下后，加入一段延迟时间，然后才算作是一个有效的游戏事件。在延迟期间（如2或3帧），若检测到一个弦，那么那个弦就会凌驾个别按钮产生事件&lt;/li&gt;
&lt;li&gt;按下单个按钮时立即执行动作，但容许这些动作被之后弦的动作抢占&lt;/li&gt;
&lt;li&gt;按下按钮时检测弦，但之后释放按钮时才产生效果&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;3-3-3-序列检测&quot;&gt;&lt;a href=&quot;#3-3-3-序列检测&quot; class=&quot;headerlink&quot; title=&quot;3.3.3 序列检测&quot;&gt;&lt;/a&gt;3.3.3 序列检测&lt;/h3&gt;&lt;p&gt;序列指玩家通过HID，在一段时间内完成一串动作，最常用于格斗游戏，如在0.5-1秒内连续按下“左右左ABA”。序列检测的基本原理是：保留HID输入的动作短期记录，当检测到序列第一个成分，就会把该成分及其时间戳记录在历史缓冲区中。之后，检测到每个后续成分时，需要检查距上一个成分所经过的时间，若时间仍在容许范围内，就把该成分加入缓冲区中。若整个序列于限定时间内完成，就会产生对应的事件。若在过程中检测到无效输入，或超过规定事件，那么整个历史缓冲区会被重置。&lt;/p&gt;
&lt;p&gt;要检测连打按钮频率，只须记录该按钮上一次被按下事件的时间Tlast和两次按下按钮的时间间隔。若该间隔超过了给定的阈值，则不更新Tlast。那么，在有一对新的够迅速的按钮按下事件产生之前，序列会一直判定为无效。&lt;/p&gt;
&lt;p&gt;要检测诸如“在1s内连续按下ABA的序列”，可以参照下面的伪代码。其中&lt;code&gt;ButtonsJustWentDown()&lt;/code&gt;函数来检查若干个按钮的按下事件。当成功检测到序列，就会广播指定事件，令整个游戏都能接收到。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class ButtonSequenceDetector {
    U32 m_aButtonIds; // 检测的序列
    U32 m_buttonCount; // 序列中的按钮数目
    F32 m_dtMax; // 整个序列的最大时限
    EventId m_eventId ; // 完成序列的事件
    U32 m_iButton; // 要检测的下一个按钮
    F32 m_tStart; // 序列的开始时间，以秒为单位

public:
    void Update() {
        ASSERT(m_iButton &amp;lt; m_buttonCount);
        // 计算下个预期的按钮，以位掩码表示（把1左移至正确的位索引）
        U32 buttonMask = (1U &amp;lt;&amp;lt; m_aButtonid[m_iButton]);
        // 若玩家按下预期以外的按钮，废止现时的序列（使用位取反运算检测所有其他按钮）
        if (ButtonsJustWentDown(~buttonMask)) {
            m_iButton = 0; // 重置
        }
        // 否则，若预期按钮刚被按下，检查dt及适当更新状态
        else if (ButtonsJustWentDown(buttonMask)) {
            // 序列中第一个按钮
            if (m_iButton == 0) {
                m_tStart = CurrentTime();
                ++m_iButton;
            } else {
                F32 dt = CurrentTime() - m_tStart;
                // 时间间隔符合要求，序列仍然有效
                if (dt &amp;lt; m_dtMax) {
                    ++m_iButton;
                    // 判断序列是否完成
                    if (m_iButton == m_buttonCount) {
                        // 广播事件并重置
                        BroadcastEvent(m_eventId);
                        m_iButton = 0;
                    }
                }
                // 按得不够快，重置
                else {
                    m_iButton = 0;
                }
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;再复杂的序列包含了摇杆方向，例如检测左拇指摇杆沿顺时针方向旋转一周。可以把遥杆位置的二维范围分割成4个象限。顺时针方向旋转时，经过的象限顺序是左上，右上，右下，左下。只要把象限检测当作按钮处理，就可稍修改上文按钮序列检测代码来完成任务。&lt;/p&gt;
&lt;h2 id=&quot;3-4-跨平台HID系统&quot;&gt;&lt;a href=&quot;#3-4-跨平台HID系统&quot; class=&quot;headerlink&quot; title=&quot;3.4 跨平台HID系统&quot;&gt;&lt;/a&gt;3.4 跨平台HID系统&lt;/h2&gt;&lt;p&gt;引擎处理多平台的HID数据时，应该提供某形式的硬件抽象层，使游戏代码和硬件相关细节隔离。此抽象层能把目标硬件的原始控制标识符转化为抽象的控制索引。例如Xbox 360及PS3的两款手柄的控制布局几乎相同，所以可以设立一套抽象标识符来屏蔽它们的差异。&lt;/p&gt;
&lt;h2 id=&quot;3-5-输入的重映射&quot;&gt;&lt;a href=&quot;#3-5-输入的重映射&quot; class=&quot;headerlink&quot; title=&quot;3.5 输入的重映射&quot;&gt;&lt;/a&gt;3.5 输入的重映射&lt;/h2&gt;&lt;p&gt;许多游戏提供给玩家修改键位的选项，这就需要把原始输入映射到最终的游戏功能上。可以给每个游戏功能一个唯一标识符，然后加一个简单的表，把每个抽象的控制索引映射至游戏中的逻辑功能。要改变映射，可以更换整个表，或是让玩家设置该表中的个别条目。&lt;/p&gt;
&lt;p&gt;但要小心不同的输入种类和取值范围，像某个游戏逻辑需要轴，就不能改用按钮操控。为了允许合理的输入映射，可以把所有输入分类并归一化：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数字式按钮：按钮状态打包成32位字，每一位代表一个按钮的状态&lt;/li&gt;
&lt;li&gt;单向绝对轴（如扳机、模拟式按钮）：产生[O, 1]的浮点数&lt;/li&gt;
&lt;li&gt;双向绝对轴（如摇杆）：产生[-1, 1]的浮点数&lt;/li&gt;
&lt;li&gt;相对轴（如鼠标滚轮、轨迹球）：产生[-1, 1]的浮点数，其中±1代表单帧内最大的相对偏移值&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;3-6-上下文相关控制&quot;&gt;&lt;a href=&quot;#3-6-上下文相关控制&quot; class=&quot;headerlink&quot; title=&quot;3.6 上下文相关控制&quot;&gt;&lt;/a&gt;3.6 上下文相关控制&lt;/h2&gt;&lt;p&gt;许多游戏里一个物理控制会根据上下文有着不同功能，例如若角色站在门前，按“使用”按钮会开门，若角色附近有一个物体，按“使用”按钮会拾起该物体。上下文相关控制可简单地采用状态机来实现，即根据当前状态个别HID控制可能有不同用途。要注意有时还需要实现优先系统，为不同物体赋予权值，来决定同等条件下优先让哪个物体（状态）生效。&lt;/p&gt;
&lt;h2 id=&quot;3-7-禁用输入&quot;&gt;&lt;a href=&quot;#3-7-禁用输入&quot; class=&quot;headerlink&quot; title=&quot;3.7 禁用输入&quot;&gt;&lt;/a&gt;3.7 禁用输入&lt;/h2&gt;&lt;p&gt;在某些场合可能需要禁用玩家的输入，例如过场动画禁用所有输入，玩家经过窄巷暂停自由旋转摄像机。一个较差的方法是使用位掩码来禁用设备上的某些控制，这种方法缺陷是如果忘记重置掩码，很可能使玩家持续失去控制。所以应该小心处理游戏逻辑，并加入一些防故障机制。&lt;/p&gt;
&lt;p&gt;另一个更好的做法是，把禁用某玩家动作及行为的逻辑写进玩家或摄像机的代码里。这样，若摄像机某时刻决定要忽略右拇指轴的输入，游戏引擎内其他系统仍然能自由读取该输入做其他用途。&lt;/p&gt;
&lt;p&gt;参考文献：电子工业出版社《游戏引擎架构》第8章&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;游戏是有互动性的计算机模拟，为游戏而设的人体学接口设备（Human Interface Device，HID）种类繁多，包括摇杆、手柄、键盘、鼠标、Wii遥控器，以及方向盘、跳舞毯、电子吉他等等专用输入设备。本文探讨游戏引擎如何自入体学接口设备读取输入，处理输入，以及向玩家反馈输出。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="游戏开发" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
      <category term="游戏引擎" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    
      <category term="游戏引擎" scheme="http://raytaylorlin.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
      <category term="架构" scheme="http://raytaylorlin.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>实时游戏的时间模拟</title>
    <link href="http://raytaylorlin.com/tech/game/engine/real-time-simulation/"/>
    <id>http://raytaylorlin.com/tech/game/engine/real-time-simulation/</id>
    <published>2016-06-28T08:29:02.000Z</published>
    <updated>2016-06-28T08:30:05.929Z</updated>
    
    <content type="html">&lt;p&gt;游戏是实时的、动态的、互动的计算机模拟，所以&lt;strong&gt;时间&lt;/strong&gt;在电子游戏中担当非常重要的角色。游戏中有不同种类的时间——实时、游戏时间、动画的本地时间线、某函数实际消耗的CPU周期等。本文谈及实时、动态模拟软件如何运作，并探讨这类模拟中运用时间的常见方法。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-抽象时间线&quot;&gt;&lt;a href=&quot;#1-抽象时间线&quot; class=&quot;headerlink&quot; title=&quot;1. 抽象时间线&quot;&gt;&lt;/a&gt;1. 抽象时间线&lt;/h1&gt;&lt;p&gt;时间线是连续的一维轴，其原点（t=0）可以设置为系统中其他时间线的任何相对位置。时间线可以用简单的时钟变量实现，以整数或浮点数格式储存绝对时间值。时间线可能存在如下几种形式。&lt;/p&gt;
&lt;h2 id=&quot;1-1-真实时间线&quot;&gt;&lt;a href=&quot;#1-1-真实时间线&quot; class=&quot;headerlink&quot; title=&quot;1.1 真实时间线&quot;&gt;&lt;/a&gt;1.1 真实时间线&lt;/h2&gt;&lt;p&gt;可以直接使用CPU的高分辨率计时寄存器来量度时间。此时间线的原点定义为计算机上次启动或重置之时。这种时间的度量单位是CPU周期（或其倍数），但其实只要简单地乘以CPU的高分辨率计时器频率，此单位便可以转换为秒数。&lt;/p&gt;
&lt;h2 id=&quot;1-2-游戏时间线&quot;&gt;&lt;a href=&quot;#1-2-游戏时间线&quot; class=&quot;headerlink&quot; title=&quot;1.2 游戏时间线&quot;&gt;&lt;/a&gt;1.2 游戏时间线&lt;/h2&gt;&lt;p&gt;在正常情况下，游戏时间和真实时间是一致的。但若希望暂停游戏，就可以简单地临时停止对游戏时间的更新，若要把游戏变成慢动作，可以把游戏时钟更新得慢于实时时钟。&lt;/p&gt;
&lt;p&gt;控制游戏时间是很有用的调试工具。例如在追查不正常的渲染时，可以暂停游戏时间，冻结所有动作，然后使用另外时钟的渲染引擎及调试用飞行摄像机继续运作，就能以任意角度观察问题所在。也可以在暂停模式下，手动“逐步更新”推前帧率来调试。要注意这种调试方法暂停游戏时，游戏循环是持续进行的，仅仅是游戏时钟停止，而通过对暂停的时钟加上1/30s去实现单步更新。&lt;/p&gt;
&lt;h2 id=&quot;1-3-局部与全局时间线&quot;&gt;&lt;a href=&quot;#1-3-局部与全局时间线&quot; class=&quot;headerlink&quot; title=&quot;1.3 局部与全局时间线&quot;&gt;&lt;/a&gt;1.3 局部与全局时间线&lt;/h2&gt;&lt;p&gt;可以想象每个动画或音频片段都含有一个局部时间线，其原点定义为片段的开始。在游戏中播放片段时，正常播放、加速、减速、反转等效果可以视觉化为局部到全局时间线的映射。下图给出了几种映射的情况，其中在做缩放播放时，播放速率记为R。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://raytaylorlin-blog.qiniudn.com/image/engine/%E5%B1%80%E9%83%A8%E5%88%B0%E5%85%A8%E5%B1%80%E6%97%B6%E9%97%B4%E7%BA%BF%E6%98%A0%E5%B0%84%E7%9A%84%E5%90%84%E7%A7%8D%E6%83%85%E5%86%B5.jpg&quot; alt=&quot;局部到全局时间线映射的各种情况&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;2-测量及处理时间&quot;&gt;&lt;a href=&quot;#2-测量及处理时间&quot; class=&quot;headerlink&quot; title=&quot;2. 测量及处理时间&quot;&gt;&lt;/a&gt;2. 测量及处理时间&lt;/h1&gt;&lt;h2 id=&quot;2-1-帧率与时间增量&quot;&gt;&lt;a href=&quot;#2-1-帧率与时间增量&quot; class=&quot;headerlink&quot; title=&quot;2.1 帧率与时间增量&quot;&gt;&lt;/a&gt;2.1 帧率与时间增量&lt;/h2&gt;&lt;p&gt;时间增量Δt（delta time）在游戏中非常重要，其值为FPS的倒数（若为60FPS则Δt=16.6ms/f）。假设一个游戏物体以恒定速率v（单位m/s）运行，乘以一帧的时间增量（单位s/f），就能得出该物体每帧的位置变化Δx=vΔt（单位m/f）。&lt;strong&gt;游戏中物体的感知速度依赖于帧时间Δt，因此计算Δt的值是游戏编程的核心问题之一。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-1-1-受CPU速度影响&quot;&gt;&lt;a href=&quot;#2-1-1-受CPU速度影响&quot; class=&quot;headerlink&quot; title=&quot;2.1.1 受CPU速度影响&quot;&gt;&lt;/a&gt;2.1.1 受CPU速度影响&lt;/h3&gt;&lt;p&gt;早期的游戏中，程序员不会尝试在游戏循环中准确量度真实经过的时间，即忽略Δt，以Δx=v计算位置变化。这样的后果是，游戏中物体看上去的速度完全依赖于CPU的速度所产生的帧率。若在较快的CPU上运行这类游戏，游戏看上去就会像快速进带一样。&lt;/p&gt;
&lt;h3 id=&quot;2-1-2-基于经过时间的更新&quot;&gt;&lt;a href=&quot;#2-1-2-基于经过时间的更新&quot; class=&quot;headerlink&quot; title=&quot;2.1.2 基于经过时间的更新&quot;&gt;&lt;/a&gt;2.1.2 基于经过时间的更新&lt;/h3&gt;&lt;p&gt;要开发和CPU速度脱钩的游戏，就要以某种方法度量Δt，只需&lt;em&gt;将CPU的高分辨率计时器取值两次——一次于帧开始时，一次于帧结束时，然后取二者之差就能精确度量上一帧的Δt&lt;/em&gt;。绝大部分的游戏引擎都是用这种方法，但它最大的问题是：使用第k帧度量出的Δt去估计第k+1帧的所需时间，这么做不一定准确。有时甚至会产生非常坏的效果，某一帧特别慢导致预测的Δt越来越大，进入低帧率的恶性循环。&lt;/p&gt;
&lt;h3 id=&quot;2-1-3-使用移动平均&quot;&gt;&lt;a href=&quot;#2-1-3-使用移动平均&quot; class=&quot;headerlink&quot; title=&quot;2.1.3 使用移动平均&quot;&gt;&lt;/a&gt;2.1.3 使用移动平均&lt;/h3&gt;&lt;p&gt;游戏循环中每帧之间是有一些连贯性的。例如，若本帧中摄像机对着含许多渲染耗时物体的走廊，那么下一帧有很大机会仍然对着该走廊。因此可以&lt;em&gt;计算连续几帧的平均时间，用来估计下一帧的Δt&lt;/em&gt;。此方法能使游戏适应转变中的帧率，同时缓和瞬间帧率尖峰所带来的影响。&lt;/p&gt;
&lt;h3 id=&quot;2-1-4-调控帧率&quot;&gt;&lt;a href=&quot;#2-1-4-调控帧率&quot; class=&quot;headerlink&quot; title=&quot;2.1.4 调控帧率&quot;&gt;&lt;/a&gt;2.1.4 调控帧率&lt;/h3&gt;&lt;p&gt;上述方法都是预测下一帧Δt的做法，难免有误差。预期尝试估算下一帧的经过时间，不如尝试保证每帧都准确耗时固定时间，即帧率调控。首先仍然要度量本帧的耗时，&lt;em&gt;若耗时比目标时间短，则让主线程休眠，直至到达目的时间；若耗时比目标时间长，那么只好白等下一个目标时间&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;当游戏的平均帧率接近目标帧率，此方法才有效。若因经常遇到“慢”帧，就会明显降低游戏质量。因此，仍然需要让将引擎系统设计成能接受任意的Δt。在开发时，引擎停留在“可变帧率”模式，实际运行中，游戏若能一贯地达到目标帧率，就开启帧率调控获其好处。使帧率连续维持稳定对游戏多方面都很重要，例如物理模拟使用的数值积分以固定时间更新运作最佳，或者使游戏录播功能更可靠。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【题外】&lt;/strong&gt;游戏录播的实现方式：需要记录游戏进行时的所有相关事件，并把这些事件及其时间戳储存下来。然后在播放时，使用相同的初始条件和随机种子，就能准确地按时间重播那些事件。理论上，这么做能产生和原来游戏过程一模一样的重播。然而，若帧率不稳定，事情可能以不完全相同的次序发生。此问题的简单解决方法是，同时记录每帧的Δt，使游戏性的逻辑模拟部分能完全重播录制时的状态。若播放时的帧率不能维持原来的速度，可选择以较慢的速度播放，或选择略过渲染一些帧。&lt;/p&gt;
&lt;h3 id=&quot;2-1-5-垂直消隐区间&quot;&gt;&lt;a href=&quot;#2-1-5-垂直消隐区间&quot; class=&quot;headerlink&quot; title=&quot;2.1.5 垂直消隐区间&quot;&gt;&lt;/a&gt;2.1.5 垂直消隐区间&lt;/h3&gt;&lt;p&gt;画面撕裂这种显示异常现象，是指由于CRT显示器的电子枪在扫描中途交换背景和前景缓冲区，导致屏幕上半部分显示了旧的影像，而下半部分则显示了新的影像。为避免画面撕裂，许多渲染引擎会在交换缓冲区之前，等待显示器的垂直消隐区间。等待垂直消隐区间是另一种帧率调控，实际上能限制主游戏循环的帧率，使其必然为屏幕刷新率的倍数。例如，在以60Hz刷新的NTSC显示器上，游戏的真实更新率实际会被量化为1/60s的倍数。若两帧之间的时间超过1/60s，便必须等待下一次垂直消隐区间，即该帧共花了2/60s（30FPS）。&lt;/p&gt;
&lt;h2 id=&quot;2-2-高分辨率计时器&quot;&gt;&lt;a href=&quot;#2-2-高分辨率计时器&quot; class=&quot;headerlink&quot; title=&quot;2.2 高分辨率计时器&quot;&gt;&lt;/a&gt;2.2 高分辨率计时器&lt;/h2&gt;&lt;p&gt;标准C程序库函数time()分辨率为秒，不适合度量游戏帧率。度量时间游戏使用的是现代CPU的高分辨率计时器，这种计时器通常会实现&lt;br&gt;为硬件寄存器，其分辨率为纳秒，如3GHz的奔腾处理器上，计时器每秒递增30亿次。奔腾的&lt;code&gt;rdtsc&lt;/code&gt;指令，Win32 API的&lt;code&gt;QueryPerformanceCounter()&lt;/code&gt;，一些PowerPC架构的&lt;code&gt;mftb&lt;/code&gt;指令等等，都可以查询分辨率计时器。&lt;/p&gt;
&lt;p&gt;要特别注意在一些多核处理器中，每个核有其独立的高分辨率计时器，这些计时器可能会彼此漂移。若比较不同核读取的绝对计算器读数，可能会出现一些奇异情况——甚至是负数的经过时间。&lt;/p&gt;
&lt;h2 id=&quot;2-3-时间单位和时钟变量&quot;&gt;&lt;a href=&quot;#2-3-时间单位和时钟变量&quot; class=&quot;headerlink&quot; title=&quot;2.3 时间单位和时钟变量&quot;&gt;&lt;/a&gt;2.3 时间单位和时钟变量&lt;/h2&gt;&lt;p&gt;大多数计时器都是64位的无符号整数时钟，可以支持非常高的精度及很大的数值范围（3GHz CPU每周期0.333ns，约195年才循环一次），这是最具弹性的表示法。当要度量高精度但较短的时间，例如剖析一段代码的性能，可用32位整数时钟。注意仍然用64位整数变量储存起始和结束时刻，中间的差值才用32位整数变量。&lt;/p&gt;
&lt;p&gt;另一常见方法是把较小的持续时间以秒为单位储存为浮点数，即把以CPU周期为单位的时间度量除以CPU时钟频率。由于32位IEEE浮点数的限制（整数部分占用较少位），应小心避免用浮点时钟变量储存很长的持续时间，最多度量几分钟。若要储存绝对值的浮点时钟，需要定期将其重置为零，以免累加至很大的数值。&lt;/p&gt;
&lt;p&gt;有些游戏引擎支持把时间值设定为自定义单位，如以1/300秒为时间单位，优点是：许多情况下足够精确；约165.7天才会溢出；同时是NTSC和PAL制刷新率的倍数。不过这种时间单位对处理动画时间缩放精度仍不够，但对于处理像枪械每次发射间的空档时间、由AI控制的角色要等多久才开始巡逻这些问题就足够了。&lt;/p&gt;
&lt;h2 id=&quot;2-4-应付断点&quot;&gt;&lt;a href=&quot;#2-4-应付断点&quot; class=&quot;headerlink&quot; title=&quot;2.4 应付断点&quot;&gt;&lt;/a&gt;2.4 应付断点&lt;/h2&gt;&lt;p&gt;当游戏在运行时遇到调试断点，游戏循环会暂停，但CPU实时时钟仍在继续累加，当程序员继续执行程序时，该帧的持续时间会度量出一个巨大的值，显然不适合传到引擎各子系统。最简单的方法就是，在主循环中，若度量到某帧的持续时间超过阈值（如1/10s），则可假定游戏刚从断点恢复执行，于是把增量时间人工设为1/30s或1/60s（或其他目标帧率）。&lt;/p&gt;
&lt;h2 id=&quot;2-5-一个简单的时钟类&quot;&gt;&lt;a href=&quot;#2-5-一个简单的时钟类&quot; class=&quot;headerlink&quot; title=&quot;2.5 一个简单的时钟类&quot;&gt;&lt;/a&gt;2.5 一个简单的时钟类&lt;/h2&gt;&lt;p&gt;以下给出一个简单时钟类的实现。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Clock {
    U64 m_timeCycles;    // 时钟周期
    F32 m_timeScale;    // 时间缩放因子
    bool m_isPaused;    // 是否暂停
    static F32 s_cyclesPerSecond;    // CPU每秒的周期数

    // 将秒数转换为周期数
    static inline U64 secondsToCycle(F32 timeSeconds) {
        return (U64) (timeSeconds * s_cyclesPerSecond);
    }

public:
    // 游戏启动时调用此初始化
    static void init() {
        s_cyclesPerSecond = (F32)readHiResTimerFrequency();
    }

    // 构建一个时钟
    explicit Clock(F32 startTimeSeconds = 0.0f) :
        m_timeCycles(secondToCycles(startTimeSeconds)), m_timeScale(1.Of), m_isPaused(false)
    { }

    // 以周期为单位返回当前时间
    U64 getTimeCycles() const {
        return m_timeCycles;
    }

    // 应在每帧调此函数一次，并给予真实度量帧时间（以秒为单位）
    void update(F32 dtRealSeconds) {
        // 非暂停才更新时钟变量
        if (!m_isPaused) {
            U64 dtScaledCycles = secondsToCycles(dtRealSeconds * m_timeScale);    // 乘以缩放因子，实现时间缩放
            m_timeCycles += dtScaledCycles;
        }
    }

    /* 省略其余简单成员函数 */
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;参考文献：电子工业出版社《游戏引擎架构》第7.4、7.5节&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;游戏是实时的、动态的、互动的计算机模拟，所以&lt;strong&gt;时间&lt;/strong&gt;在电子游戏中担当非常重要的角色。游戏中有不同种类的时间——实时、游戏时间、动画的本地时间线、某函数实际消耗的CPU周期等。本文谈及实时、动态模拟软件如何运作，并探讨这类模拟中运用时间的常见方法。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="游戏开发" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
      <category term="游戏引擎" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    
      <category term="游戏引擎" scheme="http://raytaylorlin.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
      <category term="架构" scheme="http://raytaylorlin.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>游戏循环的实现方式</title>
    <link href="http://raytaylorlin.com/tech/game/engine/game-loop/"/>
    <id>http://raytaylorlin.com/tech/game/engine/game-loop/</id>
    <published>2016-06-24T07:30:11.000Z</published>
    <updated>2016-06-24T07:35:04.279Z</updated>
    
    <content type="html">&lt;p&gt;游戏软件本质上是由一个大循环构成的。本文从最简单的渲染循环开始，讨论各种游戏循环的架构风格，接着针对现代多处理器硬件，简要说明一些让游戏引擎利用多核硬件的常见方法。网络游戏的游戏循环比较特殊，最后也会介绍两种最常见的多人游戏循环架构。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-基本游戏循环&quot;&gt;&lt;a href=&quot;#1-基本游戏循环&quot; class=&quot;headerlink&quot; title=&quot;1. 基本游戏循环&quot;&gt;&lt;/a&gt;1. 基本游戏循环&lt;/h1&gt;&lt;h2 id=&quot;1-1-渲染循环&quot;&gt;&lt;a href=&quot;#1-1-渲染循环&quot; class=&quot;headerlink&quot; title=&quot;1.1 渲染循环&quot;&gt;&lt;/a&gt;1.1 渲染循环&lt;/h2&gt;&lt;p&gt;相比于Windows的GUI采用矩形失效技术仅让屏幕有改动的部位重绘，现代3D游戏采用和电影相同的方式产生运动的错觉和互动性——对观众快速连续地显示一连串静止映像，即渲染循环，其最简单的结构如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;while (!quit) {
    // 基于输入或预设的路径更新摄像机变换
    updateCamera();
    // 更新场景中所有动态元素的位置、定向及其他相关的视觉状态
    updateSceneElements();
    // 把静止的场景渲染至屏幕外的帧缓冲（称为“背景缓冲”）
    renderScene();
    // 交换背景缓冲和前景缓冲，令最近渲染的影像显示于屏幕之上
    // （或是在视窗模式下，把背景缓冲复制至前景缓冲）
    swapBuffers();
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;1-2-游戏循环的架构风格&quot;&gt;&lt;a href=&quot;#1-2-游戏循环的架构风格&quot; class=&quot;headerlink&quot; title=&quot;1.2 游戏循环的架构风格&quot;&gt;&lt;/a&gt;1.2 游戏循环的架构风格&lt;/h2&gt;&lt;p&gt;在游戏运行时，多数游戏引擎子系统都需要周期性地提供服务，而它们所需的服务频率各有不同。动画子系统通常需要30Hz或60Hz的更新率，和渲染子系统同步。动力学模拟可能需要更频繁地更新（如120Hz）。像人工智能这种更高级的系统，可能只需要每秒1-2次更新，而且完全不需要和渲染循环同步。&lt;/p&gt;
&lt;p&gt;最简单的游戏循环，是采用&lt;strong&gt;单一循环更新所有子系统&lt;/strong&gt;，即在一个无限循环中计算逻辑并渲染画面。此外还有其他常见的架构风格，核心由若干个简单循环组成，再加上不同的修饰。&lt;/p&gt;
&lt;h3 id=&quot;1-2-1-视窗消息泵&quot;&gt;&lt;a href=&quot;#1-2-1-视窗消息泵&quot; class=&quot;headerlink&quot; title=&quot;1.2.1 视窗消息泵&quot;&gt;&lt;/a&gt;1.2.1 视窗消息泵&lt;/h3&gt;&lt;p&gt;Windows平台下，游戏除了要服务引擎本身的子系统，还要处理来自操作系统的消息。因此需要一段成为消息泵的代码来处理，基本原理是先处理来自Windows的消息，无消息时才执行引擎的任务。这种方法的副作用是设置了处理Windows消息为先，渲染和模拟游戏为后的优先次序，导致当玩家在桌面上改变游戏的视窗大小或移动视窗时，游戏就会愣住不动。典型消息泵代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;while (true) {
    // 处理所有Windows消息
    MSG msg;
    while (PeekMessage(&amp;amp;msg, NULL, 0, 0) &amp;gt; 0) {
        TranslateMessage(&amp;amp;msg);
        DispatchMessage(&amp;amp;msg);
    }
    // 再无Windows消息需要处理，执行“真正”的游戏循环迭代一次
    RunOneIterationOfGameLoop();
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;1-2-2-回调驱动框架&quot;&gt;&lt;a href=&quot;#1-2-2-回调驱动框架&quot; class=&quot;headerlink&quot; title=&quot;1.2.2 回调驱动框架&quot;&gt;&lt;/a&gt;1.2.2 回调驱动框架&lt;/h3&gt;&lt;p&gt;游戏引擎子系统和第三方游戏中间套件既可以以程序库方式构成（提供函数和类供随意调用），也有以框架构成的，程序员需提供框架中空缺的自定义实现（编写回调函数），对应用软件的控制流程只有少量甚至没有。&lt;/p&gt;
&lt;p&gt;OGRE引擎提供一套框架，程序员需要从&lt;code&gt;Ogre::FrameListener&lt;/code&gt;派生一个类，并覆写两个虚函数：&lt;code&gt;frameStarted()&lt;/code&gt;和&lt;code&gt;frameEnded()&lt;/code&gt;，OGRE在渲染主三维场景的前后会调用这两个函数。&lt;/p&gt;
&lt;h3 id=&quot;1-2-3-基于事件的更新&quot;&gt;&lt;a href=&quot;#1-2-3-基于事件的更新&quot; class=&quot;headerlink&quot; title=&quot;1.2.3 基于事件的更新&quot;&gt;&lt;/a&gt;1.2.3 基于事件的更新&lt;/h3&gt;&lt;p&gt;在游戏中，事件是指游戏状态的改变，如玩家按下手柄上的按钮、发生爆炸、敌方角色发现玩家等等。多数游戏引擎都有一个事件系统，让各个引擎子系统登记其关注的某类型事件，当那些事件发生时就可以一一回应。&lt;/p&gt;
&lt;p&gt;上述提到的以各种频率周期性更新子系统，就需要&lt;strong&gt;容许发送未来的事件&lt;/strong&gt;的事件系统来实现，即事件先置于队列，在设定的时间间隔之后才取出处理。接着，代码可以发送一个新事件，并设定该事件在未来1/30s或1/60s生效，那么这个周期性更新就能一直延续下去。&lt;/p&gt;
&lt;h1 id=&quot;2-多处理器的游戏循环&quot;&gt;&lt;a href=&quot;#2-多处理器的游戏循环&quot; class=&quot;headerlink&quot; title=&quot;2. 多处理器的游戏循环&quot;&gt;&lt;/a&gt;2. 多处理器的游戏循环&lt;/h1&gt;&lt;h2 id=&quot;2-1-多处理器游戏机的架构&quot;&gt;&lt;a href=&quot;#2-1-多处理器游戏机的架构&quot; class=&quot;headerlink&quot; title=&quot;2.1 多处理器游戏机的架构&quot;&gt;&lt;/a&gt;2.1 多处理器游戏机的架构&lt;/h2&gt;&lt;p&gt;上述讨论了基本的单线程游戏循环，而随着并行编程的架构和技术的发展，游戏引擎也需要最大化多核硬件的使用率。Xbox 360和PlayStation 3都是多处理器游戏机，为了有意义地讨论并行软件架构，需要先简单了解它们的内核架构。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://raytaylorlin-blog.qiniudn.com/image/engine/Xbox%20360%E5%92%8CPlayStation3%E7%9A%84%E5%86%85%E6%A0%B8%E6%9E%B6%E6%9E%84.jpg&quot; alt=&quot;Xbox 360和PlayStation 3的内核架构&quot;&gt;&lt;/p&gt;
&lt;p&gt;多数现代CPU都会提供单指令多数据（SIMD）指令集，其可以让一个运算同时执行于多个数据之上，此乃一种细粒度形式的硬件并行。游戏中最常用的是并行操作4个32位浮点数，可以让三维矢量和矩阵运算加速至4倍。实际使用SIMD指令时，一般要采用封装良好的三维数学库中的函数来计算。&lt;/p&gt;
&lt;h2 id=&quot;2-2-分叉与汇合&quot;&gt;&lt;a href=&quot;#2-2-分叉与汇合&quot; class=&quot;headerlink&quot; title=&quot;2.2 分叉与汇合&quot;&gt;&lt;/a&gt;2.2 分叉与汇合&lt;/h2&gt;&lt;p&gt;基本原理是把一个单位的工作分割成更小的子单位，再把这些工作量分配到多个核或硬件线程（分叉），最后待所有工作完成后再合并结果（汇合）。游戏循环应用分治法后，其结构看上去和单线程循环相似，不过更新循环的几个主要阶段都能并行化。&lt;/p&gt;
&lt;p&gt;举个例子，若动画混合使用线性插值（LERP），其操作可以独立地施于骨骼上所有关节。假设要混合5个角色的一对骨骼姿势，每个骨骼有100个关节，总共要处理500对关节姿势，可以切割成N个批次，每批次含约500/N对关节姿势。其中N按可用的处理器资源来定，如Xbox 360是3或6（3个核，每核有2个硬件线程），PS3是1-6（视有多少个SPU可用）。&lt;/p&gt;
&lt;h2 id=&quot;2-3-子系统独立线程与作业模型&quot;&gt;&lt;a href=&quot;#2-3-子系统独立线程与作业模型&quot; class=&quot;headerlink&quot; title=&quot;2.3 子系统独立线程与作业模型&quot;&gt;&lt;/a&gt;2.3 子系统独立线程与作业模型&lt;/h2&gt;&lt;p&gt;主控线程负责控制及同步这些子系统的次级子系统，子线程用于某些需重复执行且较有隔离性的子系统，如渲染引擎、物理模拟、动画管道、音频引擎等。多线程架构需要线程库支持，Windows上会使用Win32的线程API，UNIX上用类似pthread的库。&lt;/p&gt;
&lt;p&gt;使用多线程的问题之一就是，每个线程都代表相对较粗粒度的工作量（例如把所有动画任务都置于一个线程，把所有物理任务置于另一线程），这会限制多个处理器的利用率。若某个子系统线程未完成其工作，就可能阻塞主线程和其他线程。为充分利用并行硬件架构，另一种方法是把工作分割成多个细小、比较独立的作业（一组数据与操作代码结合成对），作业准备就绪就加入队列，待有闲置的处理器，作业才会从队列取出执行。PS3的SPURS库的作业模型就实现这种方法，其6个SPU只要有闲置就投入处理细粒度的作业。这样有助于最大化处理器的利用率，也可减少对主线程的限制，自然地对任何数量的处理单元进行扩展或缩减。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://raytaylorlin-blog.qiniudn.com/image/engine/%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%8B%AC%E7%AB%8B%E7%BA%BF%E7%A8%8B%E4%B8%8EPS3%E7%9A%84%E4%BD%9C%E4%B8%9A%E6%A8%A1%E5%9E%8B.jpg&quot; alt=&quot;子系统独立线程与PS3的作业模型&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;3-网络多人游戏循环&quot;&gt;&lt;a href=&quot;#3-网络多人游戏循环&quot; class=&quot;headerlink&quot; title=&quot;3. 网络多人游戏循环&quot;&gt;&lt;/a&gt;3. 网络多人游戏循环&lt;/h1&gt;&lt;h2 id=&quot;3-1-主从式模型&quot;&gt;&lt;a href=&quot;#3-1-主从式模型&quot; class=&quot;headerlink&quot; title=&quot;3.1 主从式模型&quot;&gt;&lt;/a&gt;3.1 主从式模型&lt;/h2&gt;&lt;p&gt;网游在在C/S模型下，大部分游戏逻辑运行在服务器上，客户端仅接收设备输入，渲染，处理音频，处理网络请求，以及加上一些预测玩家的代码（为了不让玩家觉得控制的游戏角色反应非常缓慢）。客户端和服务器不一定要运行于两个独立的机器上，运行在同一个机器上也很常见。网游的游戏循环可以实现为客户端和服务器为完全独立的进程；当两者在同一机器上时，可以置于同一进程的两个线程，或者为了节省本地通信的开销，都置于单个线程，由单游戏循环控制。&lt;/p&gt;
&lt;p&gt;必须注意，客户端和服务器的代码可能以不同频率进行更新。假设服务器以20FPS运行（50ms/f），客户端以60FPS运行（16.6ms/f），可以让主游戏循环以频率快者运行（60FPS），服务器每次循环会计算上次更新至今的经过时间，若超过50ms，服务器就会运行一帧，然后重置计时器。&lt;/p&gt;
&lt;h2 id=&quot;3-2-点对点模型&quot;&gt;&lt;a href=&quot;#3-2-点对点模型&quot; class=&quot;headerlink&quot; title=&quot;3.2 点对点模型&quot;&gt;&lt;/a&gt;3.2 点对点模型&lt;/h2&gt;&lt;p&gt;在这种架构下，游戏中每个动态对象，都由其对应的单一机器所管辖。&lt;strong&gt;每个机器对其拥有管辖权的对象就如同服务器，对于其他无管辖权的对象就如同是客户端&lt;/strong&gt;，只负责渲染远端管辖者所提供的对象状态。主从模型中，客户端和服务器代码分离得比较开，而在点对点模型中，许多代码都要处理（或实现）为两种游戏对象，一种是本机有管辖权的完整“真实”游戏对象，另一种是“代理版本”，仅含远程对象状态的最小子集。&lt;/p&gt;
&lt;p&gt;注意点对点架构可以设计得更复杂，如其中一机器离开游戏，则该机器所有对象的管辖权必须转移至其他参与该游戏的机器。若有新机器加入游戏，理想地该机器应接管其他机器的一些游戏对象，以平衡每部机器的工作量。以上的讨论带出的重点是，多人架构对于游戏主循环的结构有深远影响。&lt;/p&gt;
&lt;p&gt;参考文献：电子工业出版社《游戏引擎架构》第7.1-7.3、7.6、7.7节&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;游戏软件本质上是由一个大循环构成的。本文从最简单的渲染循环开始，讨论各种游戏循环的架构风格，接着针对现代多处理器硬件，简要说明一些让游戏引擎利用多核硬件的常见方法。网络游戏的游戏循环比较特殊，最后也会介绍两种最常见的多人游戏循环架构。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="游戏开发" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
      <category term="游戏引擎" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    
      <category term="游戏引擎" scheme="http://raytaylorlin.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
      <category term="架构" scheme="http://raytaylorlin.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>游戏引擎中的资源与文件系统</title>
    <link href="http://raytaylorlin.com/tech/game/engine/resources-and-file-system/"/>
    <id>http://raytaylorlin.com/tech/game/engine/resources-and-file-system/</id>
    <published>2016-06-17T06:10:20.000Z</published>
    <updated>2016-06-17T06:16:11.682Z</updated>
    
    <content type="html">&lt;p&gt;载入及管理多种媒体，是游戏引擎必须具备的能力。多数引擎会采用某种类型的资源（或资产）管理器，载入并管理游戏所需的资源，并确保在同一时间每个媒体文件只可载入一份。每个资源管理器都会大量使用文件系统。本文将介绍现代三维游戏引擎中的各种文件系统API，再分析典型资源管理器的运作方式。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-文件系统&quot;&gt;&lt;a href=&quot;#1-文件系统&quot; class=&quot;headerlink&quot; title=&quot;1. 文件系统&quot;&gt;&lt;/a&gt;1. 文件系统&lt;/h1&gt;&lt;h2 id=&quot;1-1-文件名和路径&quot;&gt;&lt;a href=&quot;#1-1-文件名和路径&quot; class=&quot;headerlink&quot; title=&quot;1.1 文件名和路径&quot;&gt;&lt;/a&gt;1.1 文件名和路径&lt;/h2&gt;&lt;p&gt;关于文件和文件夹路径的概念，绝对路径和相对路径的概念，它们在各种操作系统之间的区别，属于常识范畴，此处不赘述。&lt;/p&gt;
&lt;p&gt;关于搜寻路径，是指含若干个路径（以特殊字符分隔）的字符串，寻找文件时会从这些路径逐个寻找，PATH环境变量就是一种搜寻路径。在运行期搜寻资产是费时的做法，而通常资产路径会在运行期之前就得知，所以应该完全避免搜寻资产。&lt;/p&gt;
&lt;p&gt;关于路径API，一般用于对路径进行多种操作，如分离“目录/文件名/扩展名”、使路径规范化、绝对和相对路径互转等等。游戏引擎通常会实现或封装轻量化的路径处理API，以便实现跨平台，从各种特殊的储存媒体（如记忆棒、DVD盘、网络文件系统等等）中存取数据，以及提供操作系统API未能提供的功能，如串流（即在游戏运行中同时载入数据）。&lt;/p&gt;
&lt;h2 id=&quot;1-2-基本文件I-O&quot;&gt;&lt;a href=&quot;#1-2-基本文件I-O&quot; class=&quot;headerlink&quot; title=&quot;1.2 基本文件I/O&quot;&gt;&lt;/a&gt;1.2 基本文件I/O&lt;/h2&gt;&lt;h3 id=&quot;1-2-1-文件I-O-API&quot;&gt;&lt;a href=&quot;#1-2-1-文件I-O-API&quot; class=&quot;headerlink&quot; title=&quot;1.2.1 文件I/O API&quot;&gt;&lt;/a&gt;1.2.1 文件I/O API&lt;/h3&gt;&lt;p&gt;许多游戏引擎都会把文件I/O API封装成自定义的API，这样至少有三个好处：保证I/O API在所有目标平台上均有相同行为；API可以简化到只剩下实际需要的函数，使维护开支维持最小限度；可提供延伸功能，如处理各种特殊的储存媒体（同自定义路径处理API）。&lt;/p&gt;
&lt;p&gt;每次调用输入/输出，都需要称为缓冲区的数据区块，以供程序和磁盘之间传送字节。当API负责管理数据缓冲，就称之为有缓冲功能的API，否则为无缓冲。C标准程序库中，以f开头的文件API是带缓冲的，如&lt;code&gt;fopen()&lt;/code&gt;，没有f开头是无缓冲的，如&lt;code&gt;read()&lt;/code&gt;。有时自行管理缓冲区是有必要的。例如往日志写数据可能会显著降低性能，可以先把数据累积在内存缓冲，满溢后才写进盘内，甚至把缓冲输出函数置于另一线程里，以避免令主游戏循环发生流水线停顿。&lt;/p&gt;
&lt;h3 id=&quot;1-2-2-同步与异步&quot;&gt;&lt;a href=&quot;#1-2-2-同步与异步&quot; class=&quot;headerlink&quot; title=&quot;1.2.2 同步与异步&quot;&gt;&lt;/a&gt;1.2.2 同步与异步&lt;/h3&gt;&lt;p&gt;C标准库的两种文件I/O库都是同步的，即程序发出I/O请求以后，必须等待读/写数据完毕，程序才能继续运行。为了提高用户体验，往往要使用串流来载入资源，这必须使用异步文件I/O库。多数异步I/O库容许主程序在请求发出后一段时间，等待I/O操作完成才继续运行。有些异步I/O库容许程序员取得某异步操作所需时间的估算，一些API也可以为请求设置时限，并设置请求超时的安排（例如取消请求、通知程序、继续尝试等）。&lt;/p&gt;
&lt;p&gt;异步I/O操作常有不同的优先权，例如从硬盘中串流音频，并且在串流其他资源时播放音频，显然前者优先权高于后者。异步I/O系统必须能暂停较低优先权的请求，才可以让较高优先权的I/O请求有机会在时限前完成。&lt;/p&gt;
&lt;p&gt;关于异步操作（不局限于文件I/O）的实现原理，一般是利用另一线程进行同步操作来实现。主线程调用异步函数时，会把请求放入一个队列，并立即传回。同时，I/O线程从队列中取出请求，并以阻塞I/O函数处理这些请求。请求的工作完成后，就会调用主线程之前提供的回调函数告之该操作己完成。若主线程选择等待完成I/O请求，就会使用信号量处理（每个请求对应一个信号量，主线程把自身处于休眠状态，等待I/O线程在完成请求工作后通知信号量）。&lt;/p&gt;
&lt;h1 id=&quot;2-资源管理器&quot;&gt;&lt;a href=&quot;#2-资源管理器&quot; class=&quot;headerlink&quot; title=&quot;2. 资源管理器&quot;&gt;&lt;/a&gt;2. 资源管理器&lt;/h1&gt;&lt;p&gt;资源管理器由两部分组成：一部分负责管理离线工具链，用来创建资产并把它们转换成引擎可用的形式；另一部分在执行期管理资源，确保资源在使用前已载入内存，不需要时从内存卸下。&lt;/p&gt;
&lt;h2 id=&quot;2-1-离线资源管理与工具链&quot;&gt;&lt;a href=&quot;#2-1-离线资源管理与工具链&quot; class=&quot;headerlink&quot; title=&quot;2.1 离线资源管理与工具链&quot;&gt;&lt;/a&gt;2.1 离线资源管理与工具链&lt;/h2&gt;&lt;h3 id=&quot;2-1-1-资产的版本控制&quot;&gt;&lt;a href=&quot;#2-1-1-资产的版本控制&quot; class=&quot;headerlink&quot; title=&quot;2.1.1 资产的版本控制&quot;&gt;&lt;/a&gt;2.1.1 资产的版本控制&lt;/h3&gt;&lt;p&gt;有些游戏团队使用源码版本控制工具来管理资源。艺术资产通常有极大的数据量，直接从中央版本库复制到本地往往是低效的。以下是一些参考解决方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用如Alienbrain这种特别针对极大量数据的商业VCS&lt;/li&gt;
&lt;li&gt;在VCS上精心设计一套系统，保证用户只会取得其真正所需的文件到本地&lt;/li&gt;
&lt;li&gt;顽皮狗开发了一款私有工具。用户拥有资产版本库的完整本地视图，只要文件未签出，本地就一直是UNIX的符号链接（Windows可以使用junction实现）以消除数据复制。当签出文件时则移除符号链接，更换为本地副本，签入时则相反。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;2-1-2-资源数据库&quot;&gt;&lt;a href=&quot;#2-1-2-资源数据库&quot; class=&quot;headerlink&quot; title=&quot;2.1.2 资源数据库&quot;&gt;&lt;/a&gt;2.1.2 资源数据库&lt;/h3&gt;&lt;p&gt;游戏引擎不会使用多数资产原本的格式，而是需要通过一些资产调节管道转换资产，转换过程中每个资源都会产生&lt;strong&gt;元数据&lt;/strong&gt;描述如何对资源进行处理。例如描述压缩纹理时，使用哪种压缩方法；描述导出动画片段时，导出哪个范围的帧。大型游戏需要“资源数据库”来管理资源管道所需的数据。无论采用什么形式，数据库都需要提供以下功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以一致的方式处理多种类型的资源&lt;/li&gt;
&lt;li&gt;创建、删除、查看、移动磁盘位置和修改资源&lt;/li&gt;
&lt;li&gt;资源交叉引用其他资源，并维持数据库内的引用完整性&lt;/li&gt;
&lt;li&gt;保存版本历史，含完整日志记录、改动者及事由&lt;/li&gt;
&lt;li&gt;支持不同形式的搜索和查询&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;2-1-3-一些成功的资源数据库设计&quot;&gt;&lt;a href=&quot;#2-1-3-一些成功的资源数据库设计&quot; class=&quot;headerlink&quot; title=&quot;2.1.3 一些成功的资源数据库设计&quot;&gt;&lt;/a&gt;2.1.3 一些成功的资源数据库设计&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;虚幻3：由万用工具UnrealEd管理，它是引擎的一部分&lt;ul&gt;
&lt;li&gt;优点：创建资产后能立即看到资产在游戏中运行的模样；以单一、整合、一致的界面管理所有类型的资源；资产必须明确导入数据库，制作初期便可检查资源有效性&lt;/li&gt;
&lt;li&gt;缺点：所有资源存于少量的大型二进制包文件，不利于VCS合并；资源重命名或移动时，使用虚拟对象，即把旧资源映射到新名称/位置，问题是虚拟对象会闲置、累积起来造成问题，尤其是删除资源时变得严重&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;顽皮狗的《神秘海域》引擎&lt;ul&gt;
&lt;li&gt;最初使用MySQL存储资源元数据，并编写自制GUI工具Builder管理，后改用Perforce以提供版本控制，元数据改为XML&lt;/li&gt;
&lt;li&gt;Builder管理演员（包含行为的动态对象）和关卡（含静态背景网格和关卡信息等）两种类型的资源，动画可以组成名为动画包（buddle）的伪文件夹&lt;/li&gt;
&lt;li&gt;引擎含一组基于命令行的工具，用于查询数据库，处理资源原生DCC文件，生成某演员或关卡&lt;/li&gt;
&lt;li&gt;优点：资源粒度小；Builder仅提供必需的特性；源文件映射显而易见，用户容易得知某资源由哪些资产而来；容易更改DCC数据的到处及处理方式；依赖系统会自动处理，生成资产非常容易&lt;/li&gt;
&lt;li&gt;缺点：欠缺预览资产的可视化工具；各种类型的工具没有完全整合&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;OGRE：拥有一个颇完备、设计非常好的运行时资源管理器，通过一组简单一致又有扩展性的接口就能载入任何类型的资源。缺点在于仅是运行时方案，本身提供的离线处理很弱&lt;/li&gt;
&lt;li&gt;微软的XNA：通过VS IDE的项目管理及生成系统，把游戏资产以同样形式管理及生成&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;2-1-4-资产调节管道&quot;&gt;&lt;a href=&quot;#2-1-4-资产调节管道&quot; class=&quot;headerlink&quot; title=&quot;2.1.4 资产调节管道&quot;&gt;&lt;/a&gt;2.1.4 资产调节管道&lt;/h3&gt;&lt;p&gt;资产调节管道用于将DCC原生格式文件转换成引擎可用的形式，一般经过3个处理阶段：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;导出器：为DCC工具编写自定义插件，将数据导出为某种中间格式。如果DCC不提供自定义方法，则应该把数据存成开放格式，或比较直观的文本格式，或其他可做反向工程的原生格式&lt;/li&gt;
&lt;li&gt;资源编译器：对DCC导出的数据进行一定处理，如把网格的三角形重新排列成三角形带，或压缩纹理。并非所有数据都要编译&lt;/li&gt;
&lt;li&gt;资源链接器：将多个资源先结合成单个有用的包，如复杂的三维模型，然后才载入至游戏引擎。并非所有数据都要链接&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如同程序的源文件，各资产之间也有依赖关系，例如某网格引用若干个材质，这些材质又引用多个纹理。这些依赖关系通常会影响资产在管道内的处理次序，也可告诉我们，当某个源资产做出改动后，要重新生成哪些资产。每个资产调节管道都需要一组规则来描述资产间的依赖关系，并自己搭建系统或使用像make这样的工具来以正确顺序生成资产。一定要管理好资产间的依赖。&lt;/p&gt;
&lt;h2 id=&quot;2-2-运行时资源管理&quot;&gt;&lt;a href=&quot;#2-2-运行时资源管理&quot; class=&quot;headerlink&quot; title=&quot;2.2 运行时资源管理&quot;&gt;&lt;/a&gt;2.2 运行时资源管理&lt;/h2&gt;&lt;h3 id=&quot;2-2-1-运行时资源管理器的责任&quot;&gt;&lt;a href=&quot;#2-2-1-运行时资源管理器的责任&quot; class=&quot;headerlink&quot; title=&quot;2.2.1 运行时资源管理器的责任&quot;&gt;&lt;/a&gt;2.2.1 运行时资源管理器的责任&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;确保任何时候，同一个资源在内存中只有一份副本&lt;/li&gt;
&lt;li&gt;管理每个资源的生命期&lt;/li&gt;
&lt;li&gt;处理复合资源的载入（如三维模型）&lt;/li&gt;
&lt;li&gt;维护引用完整性：包括单个资源内的交叉引用，以及资源间的交叉引用&lt;/li&gt;
&lt;li&gt;管理资源载入后的内存用量，确保资源储存在内存中合适的地方&lt;/li&gt;
&lt;li&gt;容许按资源类型，载入资源后执行自定义的处理&lt;/li&gt;
&lt;li&gt;通常提供统一的易扩展的接口管理多种资源类型&lt;/li&gt;
&lt;li&gt;若引擎支持，则要处理串流&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;2-2-1-资源文件及目录组织&quot;&gt;&lt;a href=&quot;#2-2-1-资源文件及目录组织&quot; class=&quot;headerlink&quot; title=&quot;2.2.1 资源文件及目录组织&quot;&gt;&lt;/a&gt;2.2.1 资源文件及目录组织&lt;/h3&gt;&lt;p&gt;资源一般储存为磁盘上的文件，并位于使创作者方便而组织的树状目录中。但引擎通常不会理会资源被放置于资源树中的哪个位置，引擎会把多个资源包裹为单一文件，这种手法能将寻道时间、开启每个文件的时间、从文件读至内存的时间都降到最低。&lt;/p&gt;
&lt;p&gt;OGRE使用ZIP存档资源，因为ZIP是开放格式，内部虚拟文件有相对路径，可被压缩（载入数据后解压所花的时间，通常比读取无压缩数据所花的时间少），并可视为模块（例如把需要本地化的资产打包，针对不同语言制作不同版本的ZIP）。虚幻3采取类似的手法，但是其所有资源都必须置于大型的pak自定义格式文件中，并不容许资源以盘上独立文件出现。&lt;/p&gt;
&lt;h3 id=&quot;2-2-2-资源文件格式和GUID&quot;&gt;&lt;a href=&quot;#2-2-2-资源文件格式和GUID&quot; class=&quot;headerlink&quot; title=&quot;2.2.2 资源文件格式和GUID&quot;&gt;&lt;/a&gt;2.2.2 资源文件格式和GUID&lt;/h3&gt;&lt;p&gt;每类资源都可能有不同的文件格式。单一文件格式也可储存多种不同类型的资产，如Granny的文件格式可轻易用来储存任何种类的数据。许多引擎会自定义文件格式，因为引擎所需部分信息可能没有标准格式可以支持，以及对资源脱机处理，以让其遵从某种内存布局加速运行时载入。&lt;/p&gt;
&lt;p&gt;所有资源都需要GUID来识别，最常见就是使用资源的文件系统路径（操作系统保证两个文件不能有相同的路径），也有使用128位散列GUID的。虚幻3的GUID格式是包名和包内资源路径串接而成，像《战争机器》的一个资源GUID为&lt;code&gt;Locust_Boomer.PhysicalMaterials.LocustBommerLeather&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;2-2-3-资源注册表&quot;&gt;&lt;a href=&quot;#2-2-3-资源注册表&quot; class=&quot;headerlink&quot; title=&quot;2.2.3 资源注册表&quot;&gt;&lt;/a&gt;2.2.3 资源注册表&lt;/h3&gt;&lt;p&gt;资源管理器都含某种形式的资源注册表，以&lt;strong&gt;保证在任何时间，载入内存的每个资源只会有一份副本&lt;/strong&gt;。最简单的实现方法是使用字典，键为资源的GUID，而值是指向内存中资源的指针。资源载入内存时，加进资源注册表字典。卸下资源时，就删除其注册表记录。&lt;/p&gt;
&lt;p&gt;若不能从表中找到请求的资源，最直觉的处理手法就是自动载入该资源。但这样做可能会因为临时从硬盘或光驱等缓慢设备读取数据而严重拖慢游戏帧率。因此引擎可采取这两种替代手法：游戏进行中完全禁止加载资源（游戏关卡的所有资源在游戏进行前全部加载，那时候通常是loading界面）；或资源以相对较难实现的异步形式加载，如玩关卡A时，关卡B的资源在后台加载。&lt;/p&gt;
&lt;h3 id=&quot;2-2-4-资源生命期&quot;&gt;&lt;a href=&quot;#2-2-4-资源生命期&quot; class=&quot;headerlink&quot; title=&quot;2.2.4 资源生命期&quot;&gt;&lt;/a&gt;2.2.4 资源生命期&lt;/h3&gt;&lt;p&gt;资源管理器的职责之一是自动管理资源生命期，或对游戏提供所需API供手动管理。每个资源对生命期有不同需求：游戏持续的所有时间（如角色网格、纹理、动画，HUD的纹理字形等等），持续某一关卡的时间，短于所在关卡的时间（如过场动画），即时串流（如BGM、环境音效等）。&lt;/p&gt;
&lt;p&gt;某资源的载入时期通常在玩家第一次看见该资源便能决定，但何时卸下资源归还内存，就难以回答，因为可能存在多个关卡共享的资源。解决方案之一就是对资源引用计数，即载入新关卡时，遍历所需资源并引用加1，再遍历即将结束的关卡的资源，所有引用减1。下图给出了资源引用计数的例子。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://raytaylorlin-blog.qiniudn.com/image%2Fengine%2F%E8%BD%BD%E5%85%A5%E6%88%96%E5%8D%B8%E4%B8%8B%E4%B8%A4%E4%B8%AA%E5%85%B3%E5%8D%A1%E6%97%B6%E8%B5%84%E6%BA%90%E7%9A%84%E5%BC%95%E7%94%A8%E5%8F%98%E5%8C%96.jpg&quot; alt=&quot;载入或卸下两个关卡时资源的引用变化&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-2-5-资源的内存管理&quot;&gt;&lt;a href=&quot;#2-2-5-资源的内存管理&quot; class=&quot;headerlink&quot; title=&quot;2.2.5 资源的内存管理&quot;&gt;&lt;/a&gt;2.2.5 资源的内存管理&lt;/h3&gt;&lt;p&gt;资源加载的内存位置可能不同，像纹理、顶点缓冲、着色器驻留在显存，大部分资源驻留在主内存。设计游戏引擎时，有时用已有的内存分配器来设计资源系统，有时则要让内存分配器配合资源管理所需。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于堆栈分配器：若游戏是以线性关卡为中心，且内存足够容纳各个完整关卡，则可用堆栈分配器。注意栈顶端先分配驻留资源（LSR，各关卡共享的资源），再分配关卡所需内存。&lt;/li&gt;
&lt;li&gt;基于池分配器：因为每个内存组块大小相同，要注意设计资源数据时，必须避免大型连续数据结构，容许资源能被切割成同等大小的块。这种分配方式天生的问题就是文件内&lt;strong&gt;最后的组块&lt;/strong&gt;空间被浪费。选择组块大小时，可以考虑设为操作系统I/O缓冲区大小的倍数，如512KB。&lt;/li&gt;
&lt;li&gt;资源组块分配器：专为解决上述组块浪费内存而设的分配模式。只需管理一个链表，内含所有未用满内存的组块以及自由内存块的位置及大小。这种方案有一个问题是卸下资源内存时，其“边角”的组块也会同时消失。解决方案是只利用该种分配器分配&lt;strong&gt;和对应关卡生命期相同的内存&lt;/strong&gt;，这需要独立地管理每个关卡的组块，且用户请求分配时指明从哪个关卡分配内存。&lt;/li&gt;
&lt;li&gt;分段资源文件：将资源文件分为若干段，每段分为若干个组块（与池分配器配合）。各段的作用不同，有的是为主内存而设的数据，有的是仅在载入过程中使用、载入后被弃置的临时数据，有的是发行版本不会载入的调试信息&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;2-2-6-资源的交叉引用&quot;&gt;&lt;a href=&quot;#2-2-6-资源的交叉引用&quot; class=&quot;headerlink&quot; title=&quot;2.2.6 资源的交叉引用&quot;&gt;&lt;/a&gt;2.2.6 资源的交叉引用&lt;/h3&gt;&lt;p&gt;资源的交叉引用意味着资源间的依赖性，所以资源数据库可以表达为依赖对象所组成的有向图。交叉引用可以分为内部（单个文件里对象间的引用）和外部（引用另一个文件的对象）。下图给出了资源数据库的交叉引用例子。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://raytaylorlin-blog.qiniudn.com/image%2Fengine%2F%E8%B5%84%E6%BA%90%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BA%A4%E5%8F%89%E5%BC%95%E7%94%A8%E4%BE%8B%E5%AD%90.png&quot; alt=&quot;资源数据库的交叉引用例子&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;2-2-6-1-处理资源内部引用&quot;&gt;&lt;a href=&quot;#2-2-6-1-处理资源内部引用&quot; class=&quot;headerlink&quot; title=&quot;2.2.6.1 处理资源内部引用&quot;&gt;&lt;/a&gt;2.2.6.1 处理资源内部引用&lt;/h4&gt;&lt;p&gt;在C++中， 由于指针的内存地址总会变，而且离开运行中的程序就失去意义，所以不能用指针来表示对象间的依赖。可以将资源引用存为GUID（全局唯一的字符串或散列码），资源管理器要维护一个全局资源查找表，其中键为GUID，值为资源在内存中的地址。&lt;/p&gt;
&lt;p&gt;储存对象到二进制文件的另一常用方法是，把指针转换为为文件偏移值，并建立指针修正表。下图给出了储存二进制文件以及将文件载入内存的指针修正示意，具体过程为：①把每个对象的内存影响遍历一次，顺序写至文件成为连续映像；②写进文件的代码，清楚知道对象的数据类型和类，也就知道每个对象的指针在哪里，把这些指针位置储存到指针修正表并一同写进文件；③载入文件至内存时，映像内对象仍保持连续，并凭借修正表修正所有指针。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://raytaylorlin-blog.qiniudn.com/image%2Fengine%2F%E5%82%A8%E5%AD%98%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E4%BB%A5%E5%8F%8A%E5%B0%86%E6%96%87%E4%BB%B6%E8%BD%BD%E5%85%A5%E5%86%85%E5%AD%98%E7%9A%84%E6%8C%87%E9%92%88%E4%BF%AE%E6%AD%A3%E7%A4%BA%E6%84%8F.jpg&quot; alt=&quot;储存二进制文件以及将文件载入内存的指针修正示意&quot;&gt;&lt;/p&gt;
&lt;p&gt;从文件载入C++对象，必须调用对象的构造函数。这个问题有两个常见解决方案：使用纯C结构体来储存数据或使用无虚函数、只含不做事情的平凡构造函数的C++ struct/class；表里记录对象属于哪个类，并使用&lt;a href=&quot;https://en.wikipedia.org/wiki/Placement_syntax&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;placement new&lt;/a&gt;语法调用构造函数，像下面的代码所示。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void* pObject = ConvertOffsetToPointer(objectOffset);
::new(pObject) ClassName;  // placement new语法，ClassName为对象所属的类名
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;2-2-6-2-处理资源外部引用&quot;&gt;&lt;a href=&quot;#2-2-6-2-处理资源外部引用&quot; class=&quot;headerlink&quot; title=&quot;2.2.6.2 处理资源外部引用&quot;&gt;&lt;/a&gt;2.2.6.2 处理资源外部引用&lt;/h4&gt;&lt;p&gt;以上提及的两个方案，仅对资源内部引用有效。要正确表示外部引用，除了指明偏移值或GUID，还要加上资源对象所属文件的路径。一般做法是：载入每个资源文件时，扫描文件中的交叉引用表，并载入所有被外部引用但未载入的资源文件，当载入所有互相依赖的资源时，就用主查找表把所有指针转换成真实的内存地址。&lt;/p&gt;
&lt;h3 id=&quot;2-2-7-资源载入后初始化&quot;&gt;&lt;a href=&quot;#2-2-7-资源载入后初始化&quot; class=&quot;headerlink&quot; title=&quot;2.2.7 资源载入后初始化&quot;&gt;&lt;/a&gt;2.2.7 资源载入后初始化&lt;/h3&gt;&lt;p&gt;有一些资源载入内存时需要进行一些无法避免的初始化，例如三维网格的顶点和索引载入主内存后，几乎总是要传送至显存，而且只能在运行时进行。在C++中，可以使用多态为每个类设置如&lt;code&gt;Init()&lt;/code&gt;和&lt;code&gt;Destroy()&lt;/code&gt;的虚函数用于独立初始化和销毁工作。载入后初始化和资源内存分配策略息息相关，有时初始化会在文件的数据上新增数据（如额外计算类中的成员数据），有时初始化的数据用来取代己载入的数据（如引擎载入过时格式的网格数据，自动转换为最新格式，以保证向后兼容）。可以采用先载入到临时内存区域，初始化完成后再把相关数据复制到内存最终位置。&lt;/p&gt;
&lt;p&gt;参考文献：电子工业出版社《游戏引擎架构》第6章&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;载入及管理多种媒体，是游戏引擎必须具备的能力。多数引擎会采用某种类型的资源（或资产）管理器，载入并管理游戏所需的资源，并确保在同一时间每个媒体文件只可载入一份。每个资源管理器都会大量使用文件系统。本文将介绍现代三维游戏引擎中的各种文件系统API，再分析典型资源管理器的运作方式。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="游戏开发" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
      <category term="游戏引擎" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    
      <category term="游戏引擎" scheme="http://raytaylorlin.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
      <category term="架构" scheme="http://raytaylorlin.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>游戏引擎支持系统（下）</title>
    <link href="http://raytaylorlin.com/tech/game/engine/engine-support-system-2/"/>
    <id>http://raytaylorlin.com/tech/game/engine/engine-support-system-2/</id>
    <published>2016-06-12T12:33:11.000Z</published>
    <updated>2016-06-15T03:13:24.282Z</updated>
    
    <content type="html">&lt;p&gt;游戏编程中需要使用各种各样的集合型数据结构，称为容器或集合。字符串看似是个简单基本的数据类型，但在游戏引擎中会涉及许多设计问题和限制。此外，游戏引擎总是伴随大量可调校的选项，有的通过游戏中的选项菜单给玩家调校，有的则只为游戏开发团队设置，在正式发行时被隐掉或去除。&lt;/p&gt;
&lt;p&gt;本文将接着&lt;a href=&quot;/tech/game/engine/engine-support-system-1/&quot;&gt;上一篇&lt;/a&gt;，从游戏引擎的角度描述容器、字符串和引擎配置等游戏引擎支持系统。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-容器&quot;&gt;&lt;a href=&quot;#1-容器&quot; class=&quot;headerlink&quot; title=&quot;1. 容器&quot;&gt;&lt;/a&gt;1. 容器&lt;/h1&gt;&lt;p&gt;常见的容器类型包括但不限于：数组、动态数组（可变长）、链表 、堆栈、队列、双端队列、优先队列（二叉堆）、树、二叉查找树（红黑树、伸展树、AVL树等）、字典、集合、图、有向非循环图。常见操作有：插入、移除、顺序访问/迭代、随机访问、查找、排序等等。&lt;/p&gt;
&lt;p&gt;访问容器元素通常都会使用迭代器，它“知道”如何高效地访问容器中的某个元素，移至下一个元素，并用某种方式表示是否遍历完所有元素。使用迭代器的好处是：避免破坏容器类的封装，简化迭代过程。&lt;/p&gt;
&lt;h2 id=&quot;1-1-是否建立自定义的容器类&quot;&gt;&lt;a href=&quot;#1-1-是否建立自定义的容器类&quot; class=&quot;headerlink&quot; title=&quot;1.1 是否建立自定义的容器类&quot;&gt;&lt;/a&gt;1.1 是否建立自定义的容器类&lt;/h2&gt;&lt;p&gt;许多游戏引擎会提供常见容器的自定义实现，而非使用第三方库，原因如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;完全掌控：控制数据结构的内存需求、具体算法、分配内存时机等&lt;/li&gt;
&lt;li&gt;优化的机会：如借助游戏机独有的硬件功能来优化&lt;/li&gt;
&lt;li&gt;可定制性：提供第三方库不常见的功能，如搜寻n个最相关的元素&lt;/li&gt;
&lt;li&gt;消除外部依赖：使用第三方库有无法自行调试维护的风险&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第三方库功能强大，使用方便，但有时并不适合游戏引擎。如果决定要使用第三方库，要对它们的优缺点有全方位的了解。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;STL&lt;ul&gt;
&lt;li&gt;优点：功能丰富；跨平台；几乎所有C++编译器都自带&lt;/li&gt;
&lt;li&gt;缺点：学习曲线陡峭；相比自定义数据结构速度较慢；占用更多内存；进行许多动态内存分配；各编译器的实现微小差异导致移植多平台麻烦&lt;/li&gt;
&lt;li&gt;STL比较适合PC上的引擎，而不适用于游戏主机&lt;/li&gt;
&lt;li&gt;使用经验：用某个STL类前，充分认识其效能和内存特性；避免在可能的性能瓶颈处使用STL；占小量内存的情况才使用STL；若引擎需要支持多平台，推荐会用STLport&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Boost&lt;ul&gt;
&lt;li&gt;优点：提供许多STL没有的有用功能；提供解决STL设计或实现上的问题的替代方案；有效处理智能指针这种复杂问题；文档写得很好（也是优秀的学习材料）&lt;/li&gt;
&lt;li&gt;缺点：生成颇大的.lib文件，不适合小型项目；不保证支持向后兼容；小心阅读许可证内容&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://loki-lib.sourceforge.net/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Loki&lt;/a&gt;：其模板元编程功能极其强大，但代码可能望而生畏，难以使用，而且某些元件依赖编译器的“副作用”行为。Loki不适合胆小者，但是其设计理念非常值得学习&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-2-一些常用数据结构的使用建议&quot;&gt;&lt;a href=&quot;#1-2-一些常用数据结构的使用建议&quot; class=&quot;headerlink&quot; title=&quot;1.2 一些常用数据结构的使用建议&quot;&gt;&lt;/a&gt;1.2 一些常用数据结构的使用建议&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;动态数组：游戏编程中大量使用固定大小数组以避免动态分配的开销，而且因连续而对缓存友好。可以在开发期选用动态数组，当确定适当的内存预算时，将其改为固定大小的数组（可以自行建立一个兼容&lt;code&gt;std::vector&lt;/code&gt;接口的模板&lt;/li&gt;
&lt;li&gt;链表&lt;ul&gt;
&lt;li&gt;外露式表：节点保存&lt;strong&gt;指向实际元素&lt;/strong&gt;的指针。优点是一个元素能同时置于多个链表，缺点是必须动态分配节点。使用池分配器是最佳选择。&lt;/li&gt;
&lt;li&gt;侵入式表：元素的数据结构被嵌入节点。优点是无须动态分配，缺点是没有外露式表那么有弹性。&lt;/li&gt;
&lt;li&gt;若不惜一切代价都要避免动态内存分配，则选用侵入式表；若能负担得起池分配的开销，或链表中的实例来自第三方库，则选用外露式表&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;字典和散列表：注意散列（把任意类型的键转换为整数）函数的选择是关键。若键为32位整数，把其位模式诠释为32位整数；若键为字符串，则把字符串中所有字符的ASCII或UTF码合并为单个32位整数，常见的字符串散列函数有LOOKUP3、CRC32、MD5等等&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;2-字符串&quot;&gt;&lt;a href=&quot;#2-字符串&quot; class=&quot;headerlink&quot; title=&quot;2. 字符串&quot;&gt;&lt;/a&gt;2. 字符串&lt;/h1&gt;&lt;h2 id=&quot;2-1-字符串类&quot;&gt;&lt;a href=&quot;#2-1-字符串类&quot; class=&quot;headerlink&quot; title=&quot;2.1 字符串类&quot;&gt;&lt;/a&gt;2.1 字符串类&lt;/h2&gt;&lt;p&gt;字符串类虽然方便，但有隐性成本：传递字符串对象时，函数声明或使用不当引起多个拷贝构造函数的开销；复制字符串涉及动态内存分配。若一定要使用字符串类，应该查明其运行性能特性在可接受的范围，并让所有使用它的程序员知悉其开销。&lt;/p&gt;
&lt;p&gt;在储存和管理文件系统路径时，使用特化的字符串类（如Path类）来处理多平台的字符串差异，在游戏引擎中是很有价值的。&lt;/p&gt;
&lt;h2 id=&quot;2-2-唯一标识符&quot;&gt;&lt;a href=&quot;#2-2-唯一标识符&quot; class=&quot;headerlink&quot; title=&quot;2.2 唯一标识符&quot;&gt;&lt;/a&gt;2.2 唯一标识符&lt;/h2&gt;&lt;p&gt;唯一标识符（64位或128位的GUID字符串）用于识别游戏对象或资产，由于数量非常多，大量的比较在游戏中可能极有影响。最好找到一种方法，既保留字符串的表达能力和弹性，又要有整数操作的速度。可以把字符串散列并存于表中（该过程称为字符串扣留），并通过散列码（也称为字符串标识符，string id或SID）取回原来的字符串，但要选取恰当的散列函数保证不碰撞。&lt;/p&gt;
&lt;p&gt;因为字符串扣留（散列，分配字符串内存，复制至查找表）非常缓慢，所以通常&lt;strong&gt;在运行时就进行，而且仅进行一次，把结果储存备用&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;2-3-本地化&quot;&gt;&lt;a href=&quot;#2-3-本地化&quot; class=&quot;headerlink&quot; title=&quot;2.3 本地化&quot;&gt;&lt;/a&gt;2.3 本地化&lt;/h2&gt;&lt;p&gt;对每个向用户显示的字符串，都要事先翻译为需要支持的语言（程序内部使用的，永不显示于用户的字符串无须本地化）。除了通过使用合适的字体，为所有支持语言准备字符字形，游戏还需要处理不同的文本方向（针对一些阅读顺序很特殊的语言）。&lt;/p&gt;
&lt;p&gt;推荐先阅读这篇文章：&lt;a href=&quot;http://local.joelonsoftware.com/wiki/The_Joel_on_Software_Translation_Project:%E8%90%AC%E5%9C%8B%E7%A2%BC&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《每个软件开发者都绝对必知的Unicode及字元集必备知识(没有借口！)》&lt;/a&gt;。游戏引擎中最常采用的是UTF-8和UTF-16。&lt;/p&gt;
&lt;h3 id=&quot;2-3-1-Windows下的Unicode&quot;&gt;&lt;a href=&quot;#2-3-1-Windows下的Unicode&quot; class=&quot;headerlink&quot; title=&quot;2.3.1 Windows下的Unicode&quot;&gt;&lt;/a&gt;2.3.1 Windows下的Unicode&lt;/h3&gt;&lt;p&gt;在Windows下，&lt;code&gt;wchar_t&lt;/code&gt;用来表示单个“宽”UTF-16字符（WCS），&lt;code&gt;char&lt;/code&gt;则用作ANSI字符及多字节UTF-16字符串（MBCS）。Windows容许程序员编写&lt;strong&gt;字符集无关&lt;/strong&gt;的代码，即提供&lt;code&gt;TCHAR&lt;/code&gt;数据类型，它会根据实际所用的字符集自动typedef为特定的类型。&lt;/p&gt;
&lt;p&gt;注意Windows中各种API和标准函数库，无前缀表示普通ANSI字符，前缀为“w”“wcs”表示宽字符，缀为“mbs”表示多字节UTF-16，如&lt;code&gt;strcmp()&lt;/code&gt;、&lt;code&gt;wcscmp()&lt;/code&gt;和&lt;code&gt;_mbscmp()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;对于游戏机上的Unicode，Xbox 360开发套件几乎完全采用WCS字符串。不同的引擎采用哪种编码并不重要，重要的是在项目中尽早决定，并始终贯彻使用。&lt;/p&gt;
&lt;h3 id=&quot;2-3-2-其他本地化要考虑的事&quot;&gt;&lt;a href=&quot;#2-3-2-其他本地化要考虑的事&quot; class=&quot;headerlink&quot; title=&quot;2.3.2 其他本地化要考虑的事&quot;&gt;&lt;/a&gt;2.3.2 其他本地化要考虑的事&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;本地化不仅包括字符，还包括录制语音、带文字的纹理，还要注意一些符号在不同文化中意义的差别，注意不同市场的评级界限&lt;/li&gt;
&lt;li&gt;本地化系统需要建立字符串数据库，通过SID以及全局的“当前语言”设定来查找对应的语言字符串。其函数声明可能为：&lt;code&gt;const wchar_t* getLocalizedString(const char* sid)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;数据库的实现细节不是很重要，可以用CSV，也可以用专门的DBMS&lt;/li&gt;
&lt;li&gt;程序员切记&lt;strong&gt;不要硬编码原始字符串&lt;/strong&gt;，而是采用上述查找函数取得所需字符串。注意字符串可能需要处理像&lt;code&gt;&amp;quot;Player {0} Score: {1}&amp;quot;&lt;/code&gt;这样的格式化串&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;3-引擎配置&quot;&gt;&lt;a href=&quot;#3-引擎配置&quot; class=&quot;headerlink&quot; title=&quot;3. 引擎配置&quot;&gt;&lt;/a&gt;3. 引擎配置&lt;/h1&gt;&lt;h2 id=&quot;3-1-读写选项&quot;&gt;&lt;a href=&quot;#3-1-读写选项&quot; class=&quot;headerlink&quot; title=&quot;3.1 读写选项&quot;&gt;&lt;/a&gt;3.1 读写选项&lt;/h2&gt;&lt;p&gt;可配置选项可简单实现为全局变量或单例中的成员变量，这些选项必须可供用户配置，储存到硬盘、记忆卡或其他媒体，游戏能随时读取。下面是一些读写选项的方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文本配置文件：如INI、XML、JSON等等&lt;/li&gt;
&lt;li&gt;经压缩的二进制文件：主要用于老式游戏主机上储存空间极其有限的记忆卡&lt;/li&gt;
&lt;li&gt;Windows注册表：以树形式存储，内部节点为注册表项（类似文件夹），叶节点以键值对储存选项。任何应用程序都可预留一个注册表项存储任意内容&lt;/li&gt;
&lt;li&gt;命令行选项：通过扫描命令行取得选项设置&lt;/li&gt;
&lt;li&gt;环境变量&lt;/li&gt;
&lt;li&gt;线上用户设定档：存储在中央服务器，必须通过联网存取，一般用于存储用户成就、已购买或解锁的游戏内容、游戏选项及其他信息&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;3-2-个别用户选项&quot;&gt;&lt;a href=&quot;#3-2-个别用户选项&quot; class=&quot;headerlink&quot; title=&quot;3.2 个别用户选项&quot;&gt;&lt;/a&gt;3.2 个别用户选项&lt;/h2&gt;&lt;p&gt;个别用户选项保留了每个玩家自己配置其喜欢的选项，与全局选项区分开来。需要小心控制每个玩家只能“看见”自己的选项，而不会遇见其他玩家在同一设备的选项。&lt;/p&gt;
&lt;p&gt;在Windows上，应用程序通常在&lt;code&gt;C:\Documents and Settings&lt;/code&gt;的隐藏文件夹&lt;code&gt;Application Data&lt;/code&gt;文件夹中建立自己的文件夹，存放个别用户数据。或者通过读写注册表&lt;code&gt;HKEY_CURRENT_USER&lt;/code&gt;下的注册表项，来存取管理当前用户的配置选项。&lt;/p&gt;
&lt;h2 id=&quot;3-3-真实引擎中的配置管理&quot;&gt;&lt;a href=&quot;#3-3-真实引擎中的配置管理&quot; class=&quot;headerlink&quot; title=&quot;3.3 真实引擎中的配置管理&quot;&gt;&lt;/a&gt;3.3 真实引擎中的配置管理&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;雷神之锤的主控台变量（Console Variables，CVAR）：一个储存浮点数或字符串的全局变量，可在主控台下查看及修改，部分值可储存到硬盘上的&lt;code&gt;config.cfg&lt;/code&gt;文件&lt;/li&gt;
&lt;li&gt;OGRE引擎：使用INI，像&lt;code&gt;plugins.cfg&lt;/code&gt;记录要启用的插件及路径，&lt;code&gt;resources.cfg&lt;/code&gt;包含游戏资产的路径。通过&lt;code&gt;Ogre::ConfigFile&lt;/code&gt;类可轻易读写全新的配置文件&lt;/li&gt;
&lt;li&gt;顽皮狗的神秘海域引擎：使用以下多种配置机制&lt;ul&gt;
&lt;li&gt;游戏内置菜单选项：每个可配置选项都实现为全局变量，为选项创建菜单项目时，会提供全局变量的地址，之后菜单项目就能直接控制该全局变量的值&lt;/li&gt;
&lt;li&gt;命令行参数：可指定要载入的关卡名称，以及其他常用参数&lt;/li&gt;
&lt;li&gt;Scheme（一种Lisp方言）数据定义：通过脚本定义数据结构，并用自建的数据编译器转换为二进制文件，同时自动生成C/C++的头文件以解释二进制文件的数据。可以在运行期间重编译和重加载二进制文件，以便随时修改数据结构并立即看到效果。这种系统给予程序员巨大的弹性，可以定义复杂的数据结构，如细致的动画树、物理参数、游戏机制等。下面的代码示例，用于为动画定义属性，并导出2个动画&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;;; Scheme代码，定义一个新的数据类型，名为simple-animation
(deftype simple-animation () (
    (name string)
    (speed float: default 1.0)
    (fade-in-seconds float: default 0.25)
    (fade-out-seconds float: default 0.25)
))

;; 定义此数据结构2个实例
(define-export anim-walk
    (new simple-animation
        :name &amp;quot;walk&amp;quot;
        :speed 1.0
    )
)
(define-export anim-jump
    (new simple-animation
        :name &amp;quot;jump&amp;quot;
        :fade-in-seconds 0.1
        :fade-out-seconds 0.1
    )
)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此Scheme代码会产生以下C/C++头文件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// simple-animation.h
// 警告：本文件是Scheme自动生成的，不要手工修改
struct SimpleAnimation {
    const char* m_name;
    float m_speed;
    float m_fadeInSeconds;
    float m_fadeOutSeconds;
};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在游戏编程中，可调用&lt;code&gt;LookupSymbol()&lt;/code&gt;函数读取数据，该函数&lt;strong&gt;以返回类型为模板参数&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;quot;simple-animation.h&amp;quot;

void someFunction() {
    SimpleAnimation* pWalkAnim = LookupSymbol&amp;lt;SimpleAnimation*&amp;gt;(&amp;quot;anim-walk&amp;quot;);
    SimpleAnimation* pJumpAnim = LookupSymbol&amp;lt;SimpleAnimation*&amp;gt;(&amp;quot;anim-jump&amp;quot;);
    // 在此使用这些动画......
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;参考文献：电子工业出版社《游戏引擎架构》第5.3-5.5节&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;游戏编程中需要使用各种各样的集合型数据结构，称为容器或集合。字符串看似是个简单基本的数据类型，但在游戏引擎中会涉及许多设计问题和限制。此外，游戏引擎总是伴随大量可调校的选项，有的通过游戏中的选项菜单给玩家调校，有的则只为游戏开发团队设置，在正式发行时被隐掉或去除。&lt;/p&gt;
&lt;p&gt;本文将接着&lt;a href=&quot;/tech/game/engine/engine-support-system-1/&quot;&gt;上一篇&lt;/a&gt;，从游戏引擎的角度描述容器、字符串和引擎配置等游戏引擎支持系统。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="游戏开发" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
      <category term="游戏引擎" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    
      <category term="游戏引擎" scheme="http://raytaylorlin.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
      <category term="架构" scheme="http://raytaylorlin.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>游戏引擎支持系统（上）</title>
    <link href="http://raytaylorlin.com/tech/game/engine/engine-support-system-1/"/>
    <id>http://raytaylorlin.com/tech/game/engine/engine-support-system-1/</id>
    <published>2016-06-10T14:02:07.000Z</published>
    <updated>2016-06-10T14:12:57.595Z</updated>
    
    <content type="html">&lt;p&gt;每个游戏都需要一些底层支持系统，以管理一些例行却关键的任务，例如启动及终止引擎、存取文件系统、存取各种不同资产类型（网格、纹理、动画、音频等），以及为游戏团队提供调试工具。&lt;/p&gt;
&lt;p&gt;本文（分上下篇）重点讨论多数游戏引擎中都会出现的底层支持系统，为后续探索大型的核心系统做准备。其中上篇将讨论子系统的启动和终止的顺序管理，以及各种动态内存分配器和碎片整理等内存管理问题。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-子系统的启动和终止&quot;&gt;&lt;a href=&quot;#1-子系统的启动和终止&quot; class=&quot;headerlink&quot; title=&quot;1. 子系统的启动和终止&quot;&gt;&lt;/a&gt;1. 子系统的启动和终止&lt;/h1&gt;&lt;p&gt;游戏引擎是复杂软件，由多个互相合作的子系统结合而成。各子系统间的相互依赖关系，隐含地定义了每个子系统所需的启动次序，例如子系统B依赖子系统A，那么先启动A，再启动B，而各子系统的终止顺序则相反。&lt;/p&gt;
&lt;p&gt;多数游戏引擎都是采用C++为编程语言，所以应该考虑C++原生的语法如何供启动及终止子系统所用。通常，每个子系统会被设计为单例（或称为管理器manager）。最有效的简单方法是，每个单例管理器的构造和析构函数不做任何事，而是自定义各自的&lt;code&gt;startUp()&lt;/code&gt;和&lt;code&gt;shutDown()&lt;/code&gt;方法，然后在main函数中调用控制各系统启动和终止的顺序。&lt;/p&gt;
&lt;p&gt;还有更优雅的实现方式，例如让各管理器把自己登记在一个全局的优先队列，之后再按恰当次序逐一启动；或者让每个管理器列举其依赖的管理器，定义一个管理器间的依赖图，再计算最优的启动次序。总之，蛮力法虽然粗暴，但是简单容易实现，非常容易调试和维护，是首选的方法。&lt;/p&gt;
&lt;h1 id=&quot;2-内存管理&quot;&gt;&lt;a href=&quot;#2-内存管理&quot; class=&quot;headerlink&quot; title=&quot;2. 内存管理&quot;&gt;&lt;/a&gt;2. 内存管理&lt;/h1&gt;&lt;p&gt;任何软件的性能，不仅受算法的选择和算法编码的效率所支配，程序如何运用内存也是重要因素。内存对性能的影响有动态内存分配、内存碎片和缓存等方面。&lt;/p&gt;
&lt;h2 id=&quot;2-1-优化动态内存分配&quot;&gt;&lt;a href=&quot;#2-1-优化动态内存分配&quot; class=&quot;headerlink&quot; title=&quot;2.1 优化动态内存分配&quot;&gt;&lt;/a&gt;2.1 优化动态内存分配&lt;/h2&gt;&lt;p&gt;通过malloc()/free()或C++的new/delete运算符动态分配内存通常是非常慢的，原因有两个：堆分配器是通用设施，可以处理任何大小的分配请求，需要大量的管理开销；多数操作系统上分配内存会在用户模式和内核模式来回切换，这些上下文切换可能会耗费很多时间。因此，游戏开发中一个常见的经验法则是：&lt;strong&gt;维持最低限度的堆分配，并且永不在紧凑循环中使用堆分配。&lt;/strong&gt; 当然，任何游戏引擎都无法完全避免动态内存分配，所以会实现若干个定制分配器。定制分配器比原生分配器更高效的原因有两个：从预分配的内存中完成分配请求（顶分配内存来自new），完全避免了上下文切换；对内存的使用模式做出多种假设，会比通用的堆分配器高效得多。&lt;/p&gt;
&lt;h3 id=&quot;2-1-1-基于堆栈的分配器&quot;&gt;&lt;a href=&quot;#2-1-1-基于堆栈的分配器&quot; class=&quot;headerlink&quot; title=&quot;2.1.1 基于堆栈的分配器&quot;&gt;&lt;/a&gt;2.1.1 基于堆栈的分配器&lt;/h3&gt;&lt;p&gt;许多关卡类的游戏，载入关卡时就会为关卡分配内存，关卡载入后，就会很少甚至不会动态分配内存。在玩家完成关卡之际，关卡的数据会被卸下，所有关卡占用的内存也可被释放。这类内存分配非常适合采用堆栈分配器。这种分配器要分配一大块连续内存，通过移动一个指向堆栈顶端的指针来“模拟”内存的分配和释放。释放时按分配的相反次序，不容许释放个别的内存块，而是释放从回滚点（标记）至目前堆栈顶端之间的所有内存。&lt;/p&gt;
&lt;p&gt;双端堆栈分配器（即一个分配器从内存块底端往上分配，另一个从内存块顶端往下分配）可以更有效地运用内存。一种非常优秀的从不会产生内存碎片问题的分配方案：所有内存分配自单个巨大内存块，以双端堆栈分配器管理，底堆栈用来载入及卸下游戏关卡，顶堆栈则用来分配临时内存块，这些临时内存会在每帧中分配及释放。堆栈分配器的实现模型见下图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://raytaylorlin-blog.qiniudn.com/image%2Fengine%2F%E5%A0%86%E6%A0%88%E5%88%86%E9%85%8D%E5%99%A8%E7%9A%84%E5%88%86%E9%85%8D%E6%A8%A1%E5%BC%8F.png&quot; alt=&quot;堆栈分配器的分配模式&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-1-2-池分配器&quot;&gt;&lt;a href=&quot;#2-1-2-池分配器&quot; class=&quot;headerlink&quot; title=&quot;2.1.2 池分配器&quot;&gt;&lt;/a&gt;2.1.2 池分配器&lt;/h3&gt;&lt;p&gt;矩阵、迭代器、链表中的节点、可渲染的网格实例等会分配大量同等尺寸的小块内存。池分配器是此类分配模式的完美选择。其工作方式为：首先预分配一大块内存，大小刚好是分配元素的倍数（例如每元素4字节的4×4矩阵池的大小设为64字节的倍数），池内每个元素会加到一个存放自由元素的链表。池分配器收到分配请求时，就会把自由链表的下一个元素取出，并传回该元素；释放元素之时，只需简单地把元素插回自由链表中。这些分配和释放都是O(1)的操作。&lt;/p&gt;
&lt;h3 id=&quot;2-1-3-含对齐功能的分配器&quot;&gt;&lt;a href=&quot;#2-1-3-含对齐功能的分配器&quot; class=&quot;headerlink&quot; title=&quot;2.1.3 含对齐功能的分配器&quot;&gt;&lt;/a&gt;2.1.3 含对齐功能的分配器&lt;/h3&gt;&lt;p&gt;为了提高内存的吞吐量和效率，所有内存分配器都必须能传回&lt;strong&gt;字节对齐&lt;/strong&gt;的内存块。只要在分配内存时，分配比请求所需多一点的内存，再向上调整地址至适当的对齐，最后传回调整后的地址。大多数情况下，额外分配的字节等于对齐字节。例如，若请求为16字节对齐的内存块，就可以额外分配多16字节，最坏的情况下要把地址往上移动15字节。多出的1字节可以用来存储偏移量，以便于正确释放分配的内存。&lt;/p&gt;
&lt;h3 id=&quot;2-1-4-单帧和双缓冲分配器&quot;&gt;&lt;a href=&quot;#2-1-4-单帧和双缓冲分配器&quot; class=&quot;headerlink&quot; title=&quot;2.1.4 单帧和双缓冲分配器&quot;&gt;&lt;/a&gt;2.1.4 单帧和双缓冲分配器&lt;/h3&gt;&lt;p&gt;几乎所有游戏都会在游戏循环中分配一些临时用数据，这些数据要么可在循环迭代结束时丢弃，要么可在下一迭代结束时丢弃。这种模式适用于以下两种分配模式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;单帧分配器：先预留一块内存，并以简单堆栈分配器管理。在每帧开始时，都把堆栈的顶端指针重置到内存块的底端地址。在该帧中，分配要求会使堆栈向上成长。优点是极其高效，分配了的内存永远不需要手动释放，因为每帧开始时分配器会自动清除所有内存。最大缺点在于，程序员必须有不错的自制能力，并意识到内存块只在目前的帧里有效，&lt;strong&gt;绝不能把指向单帧内存块的指针跨帧使用&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;双缓冲分配器：第i帧分配的内存块用于第(i+1)帧。实现方法就是建立两个相同尺寸的单帧堆栈分配器，并在每帧交替使用（见下方代码）。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;class DoubleBufferedAllocater {
    U32 m_curStack;
    StackAllocator m_stack[2];
public:
    void swapBuffers() {
        m_curStack = (U32)!m_curStack;
    }

    void clearCurrentBuffer() {
        m_stack[m_curStack].clear();
    }

    void *alloc(U32 mBytes) {
        return m_stack[m_curStack].alloc(nBytes)
    }
}

DoubleBufferedAllocator g_doubleBufAllocator;
// 主游戏循环
while (true) {
    // 每帧清除单帧分配器的缓冲区
    g_singleFrameAllocator.clear();
    // 对双缓冲分配器交换现行和无效的缓冲区
    g_doubleBufAllocator.swapBuffers();
    // 清空新的现行缓冲区，保留前帧的缓冲不变
    g_doubleBufAllocator.clearCurrentBuffer();

    // ...

    // 从双缓冲分配器分配内存，不影响前帧的数据，要确保这些内存仅在本帧或次帧中使用
    void* p = g_doubleFrameAllocator.alloc(nBytes);

    // ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;2-2-内存碎片&quot;&gt;&lt;a href=&quot;#2-2-内存碎片&quot; class=&quot;headerlink&quot; title=&quot;2.2 内存碎片&quot;&gt;&lt;/a&gt;2.2 内存碎片&lt;/h2&gt;&lt;p&gt;当经过非常多次随机次序的分配及释放不同尺寸的内存块，堆中就会出现许多内存“孔洞”，这就是内存碎片状态。由于分配的内存必须是连续的，所以内存碎片会导致分配请求经常失败。在支持虚拟内存的操作系统上，内存碎片并非大问题。对当代的游戏机而言，虽然技术上能支持虚拟内存，但由于其导致的开销，多数游戏引擎不会使用虚拟内存。&lt;/p&gt;
&lt;h3 id=&quot;2-2-1-用堆钱和池分配器避免内存碎片&quot;&gt;&lt;a href=&quot;#2-2-1-用堆钱和池分配器避免内存碎片&quot; class=&quot;headerlink&quot; title=&quot;2.2.1 用堆钱和池分配器避免内存碎片&quot;&gt;&lt;/a&gt;2.2.1 用堆钱和池分配器避免内存碎片&lt;/h3&gt;&lt;p&gt;使用堆栈分配器分配到的内存块总是连续的，可以完全避免内存碎片。池分配器虽然会产生碎片，但因为每个内存块都一样大，所以不会因缺乏足够大的连续内存块而造成分配失败&lt;/p&gt;
&lt;h3 id=&quot;2-2-2-碎片整理及重定位&quot;&gt;&lt;a href=&quot;#2-2-2-碎片整理及重定位&quot; class=&quot;headerlink&quot; title=&quot;2.2.2 碎片整理及重定位&quot;&gt;&lt;/a&gt;2.2.2 碎片整理及重定位&lt;/h3&gt;&lt;p&gt;若要以随机次序分配及释放不同大小的对象，以上两种也不适用。这时可以对堆定期进行碎片整理，即把每个“洞”搬移至高位，最后所有己分配内存块都会连续地凑在堆内存空间的底端。移动内存是简单的事，但背后的副作用是&lt;strong&gt;移动了己分配的内存块，若有指针指向这些内存块，这些指针便会失效。&lt;/strong&gt;其中一个解决方案就是把指向这些内存块的指针逐一更新，使移动内存块后这些指针能指到新的地址，这个过程称为指针重定位。&lt;/p&gt;
&lt;p&gt;由于C/C++不支持搜寻所有指向某地址范围的指针，若要在游戏引擎中支持碎片整理功能，程序员必须小心手动维护所有指针，另一个选择是采用智能指针或句柄（使用索引指向句柄表内的元素，每个元素储存指针，句柄的值不变，移动内存块时要修改指针）来替代。重定位的另一难题是，使用一些第三方库，该库本身不使用智能指针或句柄，那么指向库内数据结构的指针就不能被重定位。最好的办法是，让这些库在另一个特别缓冲区里分配内存，此缓冲区位于可重定位内存范围以外。或者干脆容许一些内存块不能被重定位，若这种内存块数量少且体积小，重定位系统仍可运行得相当好。&lt;/p&gt;
&lt;h3 id=&quot;2-2-3-分摊碎片整理整本&quot;&gt;&lt;a href=&quot;#2-2-3-分摊碎片整理整本&quot; class=&quot;headerlink&quot; title=&quot;2.2.3 分摊碎片整理整本&quot;&gt;&lt;/a&gt;2.2.3 分摊碎片整理整本&lt;/h3&gt;&lt;p&gt;碎片整理要复制内存块，其过程可能很慢。然而可以把碎片整理分摊至多个帧，例如容许容许每帧进行多达N次内存块移动（N是小数目，如8或16），只要分配及释放的次数低于碎片整理的移动次数，那么堆就会经常保持接近完全整理的状态。此方法只对细小的内存块有效，使移动内存块的时间短于每帧配给的重定位时间。若要重定位非常大的内存块，有时候可以把它分拆为两个或更多的小块，而每个小块可以独立被重定位。&lt;/p&gt;
&lt;h2 id=&quot;2-3-缓存一致性&quot;&gt;&lt;a href=&quot;#2-3-缓存一致性&quot; class=&quot;headerlink&quot; title=&quot;2.3 缓存一致性&quot;&gt;&lt;/a&gt;2.3 缓存一致性&lt;/h2&gt;&lt;p&gt;为了降低读写主内存的平均时间，现代处理器会采用高速缓存。每当出现缓存命中失败，程序便要被逼暂停，等待缓存线自主内存更新后才能继续运行。因为数据始终要在缓存和主内存之间移动，所以无法完全避免缓存命中失败。高效计算的诀窍在于，以最优的方式安排内存中的数据及为算法编码，尽量减少缓存命中失败的次数。&lt;/p&gt;
&lt;h3 id=&quot;2-3-1-硬件层面上的缓存&quot;&gt;&lt;a href=&quot;#2-3-1-硬件层面上的缓存&quot; class=&quot;headerlink&quot; title=&quot;2.3.1 硬件层面上的缓存&quot;&gt;&lt;/a&gt;2.3.1 硬件层面上的缓存&lt;/h3&gt;&lt;p&gt;现代的CPU架构上出现了一级L1和二级L2高速缓存，其存取方向为“CPU←→L1缓存←→L2缓存←→主内存”，存取速度依次减慢，L2缓存命中失败通常比L1的成本高。有一种特别差的缓存命中失败称为load-hit-store，此问题在PowerPC架构上（如Xbox360和PS3）极为普遍。其出现过程是，CPU往某内存地址写入数据，随即又读取该地址，而此时要等待L1缓存写回数据至主内存，造成CPU的流水线停顿。具体可以参见&lt;a href=&quot;http://assemblyrequired.crashworks.org/load-hit-stores-and-the-__restrict-keyword/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这篇文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;此外还需要意识到大多数处理器会在物理上独立分开指令缓存和数据缓存，前者会预载即将执行的机器码，后者则用来加速内存读写数据。因此程序变慢，要考虑是指令还是数据缓存命中失败。&lt;/p&gt;
&lt;h3 id=&quot;2-3-2-软件层面上避免缓冲命中失败&quot;&gt;&lt;a href=&quot;#2-3-2-软件层面上避免缓冲命中失败&quot; class=&quot;headerlink&quot; title=&quot;2.3.2 软件层面上避免缓冲命中失败&quot;&gt;&lt;/a&gt;2.3.2 软件层面上避免缓冲命中失败&lt;/h3&gt;&lt;p&gt;避免&lt;strong&gt;数据&lt;/strong&gt;缓存命中失败的最佳办法就是，&lt;strong&gt;把数据编排进连续的内存块中，尺寸越小越好，并且要顺序访问这些数据&lt;/strong&gt;。当数据是连续的（即不会经常在内存中“跳来跳去”），那么单次命中失败便会把尽可能最多的相关数据载入单个缓存线。&lt;/p&gt;
&lt;p&gt;要避免&lt;strong&gt;指令&lt;/strong&gt;缓存命中失败，需要了解C/C++链接器的一些简单规则，例如编译器和链接器按函数在cpp文件中的出现次序排列内存布局；单个函数的机器码几乎总是置于连续的内存；位于一个翻译单元内的函数总是置于连续内存中。据此可以使用以下经验法则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;高效能代码的体积越小越好，体积以机器码指令数目为单位&lt;/li&gt;
&lt;li&gt;在性能关键的代码段中，&lt;strong&gt;避免调用函数&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;若要调用某函数，就把该函数置于&lt;strong&gt;最接近&lt;/strong&gt;调用函数的地方，最好是紧接调用函数的前后，而不要把该函数置于另一翻译单元（cpp文件）&lt;/li&gt;
&lt;li&gt;谨慎使用内联函数。内联小型函数能增进效能，然而过多的内联会增大代码体积，使性能关键代码再不能完全装进缓存。若循环内的代码不能完全装进缓存，应重新考虑算法及其代码实现&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考文献：电子工业出版社《游戏引擎架构》第5.1、5.2节&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;每个游戏都需要一些底层支持系统，以管理一些例行却关键的任务，例如启动及终止引擎、存取文件系统、存取各种不同资产类型（网格、纹理、动画、音频等），以及为游戏团队提供调试工具。&lt;/p&gt;
&lt;p&gt;本文（分上下篇）重点讨论多数游戏引擎中都会出现的底层支持系统，为后续探索大型的核心系统做准备。其中上篇将讨论子系统的启动和终止的顺序管理，以及各种动态内存分配器和碎片整理等内存管理问题。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="游戏开发" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
      <category term="游戏引擎" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    
      <category term="游戏引擎" scheme="http://raytaylorlin.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
      <category term="架构" scheme="http://raytaylorlin.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>游戏引擎架构总览</title>
    <link href="http://raytaylorlin.com/tech/game/engine/game-engine-architecture-preview/"/>
    <id>http://raytaylorlin.com/tech/game/engine/game-engine-architecture-preview/</id>
    <published>2016-05-27T09:07:53.000Z</published>
    <updated>2016-05-27T09:20:51.758Z</updated>
    
    <content type="html">&lt;p&gt;游戏引擎通常由运行时组件和工具套件两部分构成。本文先探讨运行时部分的架构，给出了一个不包含工具的极其庞大的总览图（如果时间有限仅看此图即可），并对图中每一组件进行描述，最后再阐述工具方面的内容。如同所有软件系统，游戏引擎也是以软件层构建的，而且通常上层依赖下层，下层不依赖上层。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-运行时引擎架构&quot;&gt;&lt;a href=&quot;#1-运行时引擎架构&quot; class=&quot;headerlink&quot; title=&quot;1. 运行时引擎架构&quot;&gt;&lt;/a&gt;1. 运行时引擎架构&lt;/h1&gt;&lt;p&gt;下图为游戏运行时引擎架构的总览图，本图相对原书标上了序号，以方便下面各节阐述时对应其位置，并省略了一些细节的组成部分。&lt;strong&gt;图片较大，建议在新标签页中打开图片查看。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://raytaylorlin-blog.qiniudn.com/image%2Fengine%2F%E6%B8%B8%E6%88%8F%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84.png&quot; alt=&quot;游戏运行时引擎架构&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-1-硬件与操作系统&quot;&gt;&lt;a href=&quot;#1-1-硬件与操作系统&quot; class=&quot;headerlink&quot; title=&quot;1.1 硬件与操作系统&quot;&gt;&lt;/a&gt;1.1 硬件与操作系统&lt;/h2&gt;&lt;p&gt;图中的A1为目标硬件层，代表用来执行游戏的计算机系统或游戏主机。典型平台包括基于微软Windows或Linux的PC、苹果的iPhone及Machintosh、微软的Xbox360、索尼的PS4/PSP、任天堂的NDS/Wii等等。&lt;/p&gt;
&lt;p&gt;图中的A2是设备驱动程序，是由操作系统或硬件厂商提供的最低阶软件组件。驱动程序负责管理硬件资源，也隔离了操作系统及上层引擎，使上层的软件无须理解不同硬件版本的通信细节差异。&lt;/p&gt;
&lt;p&gt;图中的A3是操作系统。在PC上操作系统是一直运行的，PC游戏不能假设拥有硬件的所有控制权；而在游戏主机上，操作系统通常只是个轻量级的库，链接到游戏的执行档里。不过像Xbox 360和PS3这些新主机中，操作系统也会中断游戏的执行，接管某些系统资源以显示在线信息。&lt;/p&gt;
&lt;h2 id=&quot;1-2-第三方软件开发包和中间件&quot;&gt;&lt;a href=&quot;#1-2-第三方软件开发包和中间件&quot; class=&quot;headerlink&quot; title=&quot;1.2 第三方软件开发包和中间件&quot;&gt;&lt;/a&gt;1.2 第三方软件开发包和中间件&lt;/h2&gt;&lt;p&gt;图中的B表明大多数游戏引擎会借用第三方SDK及中间件（middleware），SDK提供基于函数或基于类的API。下面是一些常见的例子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据结构及算法：如STL、STLport、Boost、Loki。因为PC上有虚拟内存系统，所以可以无碍使用STL，而游戏主机上，只有有限的（甚至没有）虚拟内存功能，而且缓存命中失败的代价极高，所以最好编写自定义的数据结构&lt;/li&gt;
&lt;li&gt;图形：如DirextX、OpenGL、libgcm、Edge等&lt;/li&gt;
&lt;li&gt;碰撞和物理：如Havok、PhysX、ODE（Open Dynamics Engine）等&lt;/li&gt;
&lt;li&gt;角色动画：如Granny、Havok Animation、Edge等&lt;/li&gt;
&lt;li&gt;人工智能：如Kynapse，提供低阶的AI构件，例如路径搜寻、静态和动态物体回避、空间内的脆弱点辨认，以及相当好的AI和动画间接口&lt;/li&gt;
&lt;li&gt;生物力学角色模型：如Endorphin、Euphoria等，利用了真实人类运动的高阶生物力学模型，去产生角色动作&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-3-平台独立层&quot;&gt;&lt;a href=&quot;#1-3-平台独立层&quot; class=&quot;headerlink&quot; title=&quot;1.3 平台独立层&quot;&gt;&lt;/a&gt;1.3 平台独立层&lt;/h2&gt;&lt;p&gt;图中的C为平台独立层。大部分游戏引擎需要运行于不同的平台上，该层包装了常用的标准C语言库、操作系统调用及其他基础API，确保包装了的接口在所有硬件平台上均为一致。&lt;/p&gt;
&lt;h2 id=&quot;1-4-核心系统&quot;&gt;&lt;a href=&quot;#1-4-核心系统&quot; class=&quot;headerlink&quot; title=&quot;1.4 核心系统&quot;&gt;&lt;/a&gt;1.4 核心系统&lt;/h2&gt;&lt;p&gt;游戏引擎以及其他大规模复杂C++应用软件，都需要一些有用的实用软件（utility)，统称为“核心系统”，即图中的D。以下是一些核心系统层的常见功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内存管理：几乎每个游戏引擎都有若干个自定义内存分配系统，以保证高速的内存分配及释放，并控制内存碎片所造成的负面影响&lt;/li&gt;
&lt;li&gt;数学库：游戏本质上就是高度数学密集的，所以每个游戏引擎都有若干个数学库，提供矢量、矩阵、四元数旋转、三角学、数值积分、解方程组，以及其他游戏程序员需要的功能&lt;/li&gt;
&lt;li&gt;自定义数据结构及算法：除非引擎设计者想完全依靠第三方软件包，否则引擎通常要提供一组工具去管理基础数据结构和算法，以减少或完全消去动态内存分配，并保证在目标平台上的运行效率为最优&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-5-资源管理&quot;&gt;&lt;a href=&quot;#1-5-资源管理&quot; class=&quot;headerlink&quot; title=&quot;1.5 资源管理&quot;&gt;&lt;/a&gt;1.5 资源管理&lt;/h2&gt;&lt;p&gt;图中的E为资源管理器，提供一组统一的接口去访问任何类型的游戏资产及其他引擎输入数据。有些引擎使用高度集中及一致的方式（例如虚幻的包package、OGRE的ResourceManager类）。其他引擎使用专案（ad hoc）方法，比如让程序员直接读取磁盘的或压缩的文件（如雷神之锤引擎使用的PAK文件）。&lt;/p&gt;
&lt;h2 id=&quot;1-6-渲染引擎&quot;&gt;&lt;a href=&quot;#1-6-渲染引擎&quot; class=&quot;headerlink&quot; title=&quot;1.6 渲染引擎&quot;&gt;&lt;/a&gt;1.6 渲染引擎&lt;/h2&gt;&lt;p&gt;任何游戏引擎中，渲染引擎是最大及最复杂的组件之一。渲染器有很多不同的架构方式，通常采用分层架构。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;低阶渲染器（图中F1）：包含引擎中全部原始的渲染功能，着重于高速渲染丰富的几何图元集合&lt;ul&gt;
&lt;li&gt;图形设备接口：使用图形SDK（如DirectX及OpenGL），都需要编写不少代码去枚举图形设备，初始化设备，建立渲染表面等，这些工作通常由图形设备接口组件负责&lt;/li&gt;
&lt;li&gt;其他渲染器组件：目的是要收集须提交的几何图元，包括网格、线表、点表、例子、地形块、字符串等等。低阶渲染器还提供视区（viewport）抽象、材质系统及动态光照系统&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;场景图/剔除优化（图中F2）：该层基于某些可视性判别算法去限制低阶渲染器提交的图元数量。非常小的游戏世界可能只需要简单的平截头体剔除算法，比较大的游戏世界则可能需要较高阶的空间细分数据结构，令渲染更有效率&lt;/li&gt;
&lt;li&gt;视觉效果（图中F3）：支持广泛的视觉效果，例如粒子系统（烟、火、水花等）、贴花系统（弹孔、脚印等），还有一些全屏幕后期处理，例如高动态范围光照（HDR）、敷霜效果、全屏抗锯齿（FSAA）、颜色校正等等&lt;/li&gt;
&lt;li&gt;前端（图中F4）：该层主要用于显示2D图形，如平视显示器（HUD）、GUI界面等等，通常会用附有纹理的四边形结合正射投影来渲染，或者用完全三维的四边形公告板（billboard）渲染&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-7-剖析与调试工具&quot;&gt;&lt;a href=&quot;#1-7-剖析与调试工具&quot; class=&quot;headerlink&quot; title=&quot;1.7 剖析与调试工具&quot;&gt;&lt;/a&gt;1.7 剖析与调试工具&lt;/h2&gt;&lt;p&gt;图中的G用于剖析调优性能，分析内存。还包含了游戏内置调试功能，包括调试用绘图、内置菜单、主控台、录制回放游戏过程等。市场上有很多优良的通用软件剖析工具，如VTune、Quantify、Purify等等，但是多数游戏也会加入自制的剖析与调试工具以应对特殊需求。&lt;/p&gt;
&lt;h2 id=&quot;1-8-碰撞和物理&quot;&gt;&lt;a href=&quot;#1-8-碰撞和物理&quot; class=&quot;headerlink&quot; title=&quot;1.8 碰撞和物理&quot;&gt;&lt;/a&gt;1.8 碰撞和物理&lt;/h2&gt;&lt;p&gt;图中的H为碰撞与物理组件。游戏中如果没有碰撞检测，物体会互相穿透，并且无法在虚拟世界里合理地互动。碰撞和物理系统一般是紧密联系的，因为当碰撞发生时，碰撞几乎总是由物理积分及约束满足逻辑来解决。一些游戏还包含真实或半真实的刚体动力学模拟。时至今日，游戏引擎通常使用第三方的物理SDK，如Havok、PhysX和ODE。&lt;/p&gt;
&lt;h2 id=&quot;1-9-动画&quot;&gt;&lt;a href=&quot;#1-9-动画&quot; class=&quot;headerlink&quot; title=&quot;1.9 动画&quot;&gt;&lt;/a&gt;1.9 动画&lt;/h2&gt;&lt;p&gt;图中的I为动画系统，游戏常会用到精灵/纹理动画、刚体层次结构动画、骨骼动画、每顶点动画、变形目标动画5种基本动画。现今游戏&lt;br&gt;中，骨骼动画是最盛行的动画方式。此外，骨骼网格渲染组件是连接渲染器和动画系统的桥梁，这些组件合作渲染的过程称为蒙皮（skinning）。&lt;/p&gt;
&lt;p&gt;当使用布娃娃系统时，动画和物理系统便产生紧密耦合，这是因为布娃娃是无力的（经常是死了的）角色，其运动完全由物理系统模拟。物理系统把布娃娃当作受约束的刚体系统，用模拟来决定身体每部分的位置及方向。&lt;/p&gt;
&lt;h2 id=&quot;1-10-人体学接口设备&quot;&gt;&lt;a href=&quot;#1-10-人体学接口设备&quot; class=&quot;headerlink&quot; title=&quot;1.10 人体学接口设备&quot;&gt;&lt;/a&gt;1.10 人体学接口设备&lt;/h2&gt;&lt;p&gt;图中的J用于处理玩家输入，包括键盘鼠标、游戏手柄及其他专用游戏控制器（如方向盘、跳舞毯、Wii遥控器等）。除了输入功能，一些设备也提供输出，如游戏手柄的震动、Wii遥控器的音频输出等。&lt;/p&gt;
&lt;p&gt;在架构HID引擎时，通常让硬件的低阶细节与高阶游戏操作脱钩。HID引擎从硬件取得原始数据，为控制器的每个摇杆设置环绕中心点的死&lt;br&gt;区，去除按钮抖动，检测按下和释放按钮事件，演绎加速计的输入并使该输入平滑。HID引擎也可能包含一个系统，负责检测弦（chord）（即数个按钮一起按下）、序列（即接钮在时限内顺序按下）、手势（即按钮、摇杆、加速计等输入的序列）。&lt;/p&gt;
&lt;h2 id=&quot;1-11-音频&quot;&gt;&lt;a href=&quot;#1-11-音频&quot; class=&quot;headerlink&quot; title=&quot;1.11 音频&quot;&gt;&lt;/a&gt;1.11 音频&lt;/h2&gt;&lt;p&gt;图中的K为音频引擎。一些游戏团队会为这些引擎加入自定义功能，或用内部方案替换，例如微软为DirectX平台提供一个名为XACT的优秀的音频工具包，艺电也开发了内部的音频引擎SoundR!OT。然而，即使游戏团队用既有的音频引擎，开发每个游戏时仍然需要大量的定制软件开发、整合工作及注意细节，才可以制作出有高质量音频的最终产品。&lt;/p&gt;
&lt;h2 id=&quot;1-12-在线多人-网络&quot;&gt;&lt;a href=&quot;#1-12-在线多人-网络&quot; class=&quot;headerlink&quot; title=&quot;1.12 在线多人/网络&quot;&gt;&lt;/a&gt;1.12 在线多人/网络&lt;/h2&gt;&lt;p&gt;图中的L为在线多人/网络组件。多人游戏有单屏多人、切割平多人、网络多人、大型多人在线等多种基本形式。支持多人游戏，会深切影响到游戏世界对象模型、人体学接口设备系统、玩家控制系统、动画系统等多个组件的设计。把一个现有的担任引擎改装成多人引擎的难度是非常大的，但如果反过来则比较简单——许多游戏引擎把单人游戏模式当做是一个玩家参与的多人游戏。&lt;/p&gt;
&lt;h2 id=&quot;1-13-游戏性基础系统&quot;&gt;&lt;a href=&quot;#1-13-游戏性基础系统&quot; class=&quot;headerlink&quot; title=&quot;1.13 游戏性基础系统&quot;&gt;&lt;/a&gt;1.13 游戏性基础系统&lt;/h2&gt;&lt;p&gt;游戏性（gameplay）是指：游戏内进行的活动、支配游戏虚拟世界的规则、玩家角色的能力（也称为玩家机制）、其他角色和对象的能力、玩家的长短期目标。游戏性编程除了用引擎的原生语言，通常还会使用高阶的脚本语言，为了连接低阶的引擎子系统和游戏性代码，多数游戏引擎会引入一个软件层，即图中的M。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;游戏世界和游戏对象模型：游戏世界含动态与静态的元素，而典型的游戏对象有静态背景几何物体（如建筑、地形）、动态刚体（如石头、椅子）、玩家角色、NPC、武器、抛射物、载具、光源、摄像机&lt;/li&gt;
&lt;li&gt;事件系统：事件驱动架构常用于游戏对象间的通信&lt;/li&gt;
&lt;li&gt;脚本系统：使用脚本语言来编写游戏独有的游戏性规则和内容，可以快速开发，避免重新编译链接&lt;/li&gt;
&lt;li&gt;人工智能基础：像Kynapse这种商用AI引擎，抽象了大多数AI系统共有的模式，在这个基础层上可以很容易地开发个别游戏的逻辑。其功能包括用路径节点和漫游体积组成网络定义AI角色可行走的地区和路径，在漫游地区边界周围的简化碰撞信息，A*路径搜寻，联系碰撞系统及世界模型进行视线追踪及其他感知，AI决策层架构等等&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-14-个别游戏专用子系统&quot;&gt;&lt;a href=&quot;#1-14-个别游戏专用子系统&quot; class=&quot;headerlink&quot; title=&quot;1.14 个别游戏专用子系统&quot;&gt;&lt;/a&gt;1.14 个别游戏专用子系统&lt;/h2&gt;&lt;p&gt;如图中的N，每个游戏都有若干自身特有的游戏性系统。如果可以清楚地分开引擎和游戏，这条分界线会位于特定游戏专用子系统和游戏性基础软件层之间。实际上，这条分界线永远不会是完美的。一些游戏的特定知识，总是会向下渗透到游戏基础软件层中，更有甚者会延伸至引擎核心。&lt;/p&gt;
&lt;h1 id=&quot;2-工具套件&quot;&gt;&lt;a href=&quot;#2-工具套件&quot; class=&quot;headerlink&quot; title=&quot;2. 工具套件&quot;&gt;&lt;/a&gt;2. 工具套件&lt;/h1&gt;&lt;h2 id=&quot;2-1-数字内容创作工具&quot;&gt;&lt;a href=&quot;#2-1-数字内容创作工具&quot; class=&quot;headerlink&quot; title=&quot;2.1 数字内容创作工具&quot;&gt;&lt;/a&gt;2.1 数字内容创作工具&lt;/h2&gt;&lt;p&gt;游戏本质上是多媒体应用。游戏引擎的输入数据形式广泛，例如三维网格数据、纹理位图、动画数据、音频文件等。所有源数据皆由美术或音效师等专业人员使用数字内容创作（Digital Content Creation，DCC）应用软件制作，如Maya、3ds Max、Photoshop、SoundForge等等。有些游戏引擎提供专门的设计游戏世界的编辑器，而有的团队会在现有软件像3ds Max的基础上开发插件去设计场景，甚至用简单的位图编辑器去制作地形高度图。总之，游戏团队想要及时开发高完成度的产品，工具必须&lt;strong&gt;相对易用&lt;/strong&gt;，并且&lt;strong&gt;绝对可靠&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;2-2-资产（asset）调节管道&quot;&gt;&lt;a href=&quot;#2-2-资产（asset）调节管道&quot; class=&quot;headerlink&quot; title=&quot;2.2 资产（asset）调节管道&quot;&gt;&lt;/a&gt;2.2 资产（asset）调节管道&lt;/h2&gt;&lt;p&gt;DCC所生成的数据格式，很少有直接用于游戏中的，原因有两点：生成的数据格式通常比游戏所需的复杂得多，游戏引擎只需其中一小部分信息；直接读取速度过慢，而且有些格式是不公开的专有格式。因此，DCC软件制作的数据，通常要导出为容易读取的标准格式或自定义格式，有时还需要针对不同平台进行再处理，以便在游戏中使用。从DCC到游戏引擎的管道，就是所谓的资产调节管道。&lt;/p&gt;
&lt;h2 id=&quot;2-3-常见的游戏资产数据&quot;&gt;&lt;a href=&quot;#2-3-常见的游戏资产数据&quot; class=&quot;headerlink&quot; title=&quot;2.3 常见的游戏资产数据&quot;&gt;&lt;/a&gt;2.3 常见的游戏资产数据&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;几何图形数据&lt;ul&gt;
&lt;li&gt;笔刷集合图形：由凸包集合定义，每个凸包则由多个平面定义。其优点是制作迅速简单，便于设计师建立粗略的原型，也可用作碰撞体积；缺点是分辨率低难以制作复杂图形，不能支持有关节的物体或运动角色&lt;/li&gt;
&lt;li&gt;三维模型/网格：由三角形和顶点组成，每个网格使用若干个材质。网格通常在三维建模软件里制作，并且需要专用的导出器来导出游戏引擎可读的格式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;骨骼动画数据：骨骼网格是一种为关节动画而绑定到骨骼层次结构之上的特殊网格，游戏引擎需要网格本身、骨骼层次结构和若干动画片段3种数据来渲染骨骼网络&lt;/li&gt;
&lt;li&gt;音频数据：由专业的音频制作工具导出，有不同格式和采样率。音频文件通常组织成音频库，以方便管理，载入及串流。&lt;/li&gt;
&lt;li&gt;粒子系统数据：由视觉特效设计师使用第三方工具（如Houdini）或引擎自带的粒子效果编辑工具制作&lt;/li&gt;
&lt;li&gt;游戏世界数据：不少商用游戏引擎会提供优良的世界编辑器，用于编辑游戏世界&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考文献：电子工业出版社《游戏引擎架构》第1.6、1.7节&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;游戏引擎通常由运行时组件和工具套件两部分构成。本文先探讨运行时部分的架构，给出了一个不包含工具的极其庞大的总览图（如果时间有限仅看此图即可），并对图中每一组件进行描述，最后再阐述工具方面的内容。如同所有软件系统，游戏引擎也是以软件层构建的，而且通常上层依赖下层，下层不依赖上层。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="游戏开发" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
      <category term="游戏引擎" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    
      <category term="游戏引擎" scheme="http://raytaylorlin.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
      <category term="架构" scheme="http://raytaylorlin.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>软件构建（十五）——尾声</title>
    <link href="http://raytaylorlin.com/tech/complex/software/software-construction-15/"/>
    <id>http://raytaylorlin.com/tech/complex/software/software-construction-15/</id>
    <published>2016-05-14T14:21:15.000Z</published>
    <updated>2016-05-19T02:30:35.465Z</updated>
    
    <content type="html">&lt;p&gt;本文是《代码大全》学习笔记系列的最后一篇。书中最后几章是一些杂项主题，本文将简要记录这几个主题的内容，包括个人性格对编程的影响，软件开发艺术的有关问题，以及关于软件工程的推荐书单。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-个人性格&quot;&gt;&lt;a href=&quot;#1-个人性格&quot; class=&quot;headerlink&quot; title=&quot;1. 个人性格&quot;&gt;&lt;/a&gt;1. 个人性格&lt;/h1&gt;&lt;p&gt;编程过程非常耗用脑力，这种特性使得个人性格显得很重要。而编程工作本质上是项无法监督的工作，因为没人真正清楚你正在做什么。老板也无法强迫你成为好的程序员，很多时候他甚至无法判断你是否合格，一切都只能靠自己。你无法提升自己的聪明程度，但性格在一定程度上能够改进。事实证明，个人性格对于造就出程序员高手更具有决定性意义。&lt;/p&gt;
&lt;h2 id=&quot;1-1-个人性格对编程的影响&quot;&gt;&lt;a href=&quot;#1-1-个人性格对编程的影响&quot; class=&quot;headerlink&quot; title=&quot;1.1 个人性格对编程的影响&quot;&gt;&lt;/a&gt;1.1 个人性格对编程的影响&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;聪明和谦虚：高智商与优秀程序员之间并无太密切的联系。实际上许多好的编程做法都是为了减轻脑力负担，例如将系统分解是为了使之易于理解，进行审查、评审和测试是为了减少人为失误，通过各种各样的规范是为了将思路从相对繁琐的编程事务中解放出来。精通编程的人是那些了解自己头脑有多大局限性的人，都很谦虚。&lt;/li&gt;
&lt;li&gt;求知欲：技术环境的特定特征每5到10年就变化一番，如果没有足够的求知欲来跟上这些变化，就会面临落伍的威胁，下面是一些培养求知欲的方法&lt;ul&gt;
&lt;li&gt;在开发过程中建立自我意识&lt;/li&gt;
&lt;li&gt;不断用小程序来试验技术点&lt;/li&gt;
&lt;li&gt;阅读解决问题的有关方法&lt;/li&gt;
&lt;li&gt;在行动之前做分析和计划&lt;/li&gt;
&lt;li&gt;学习成功项目的开发经验，阅读高手的代码&lt;/li&gt;
&lt;li&gt;认真阅读文档和其他书本期刊&lt;/li&gt;
&lt;li&gt;同专业人士交往&lt;/li&gt;
&lt;li&gt;向专业开发看齐：专业开发可分为这样四个等级：入门级（会使用某语言的基本功能和特性），中级（已度过入门期，能使用多种 语言，并得心应手使用至少一种语言），熟练级（对语言或环境有着专业技能，通常是公司的核心开发，很多程序员不能超越该层次），技术带头人级（具有熟练级的专业技能，也明白写代码是给人看而非给机器看）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;诚实：通常表现为：不是高手时不假装是高手；乐于承认错误；力图理解编译器的警告，而非弃之不理；透彻理解自己的程序，而不要只是编译看看能否运行；提供实际的状况报告；提供现实的进度方案，在上司面前坚持自己的意见&lt;/li&gt;
&lt;li&gt;交流与合作：真正优秀的程序员知道怎样同别人融洽地工作和娱乐，并且会把提高代码可读性和修改你代码的人放在心上&lt;/li&gt;
&lt;li&gt;创造力和纪律：不要把各种标准和规范的纪律看成是对创造力的约束，相反，许多有很强创造力的人都极其遵守纪律和规范&lt;/li&gt;
&lt;li&gt;偷懒：通常表现为拖延不喜欢的任务（没有任何益处），迅速做完不喜欢的任务以摆脱之（尽管是偷懒，但毕竟用最少时间完成了任务），&lt;strong&gt;编写某个工具来完成不喜欢的任务以便再也不用做这样的事情&lt;/strong&gt;（一劳永逸的懒，无疑是最具产值的偷懒形式）&lt;/li&gt;
&lt;li&gt;习惯：优秀的程序员早就养成了编程各方面的良好习惯，而不是最近才培养的。初涉某事时，就应端正态度来学，干了一段时间后，“习惯的力量”就开始起作用。如果没养成最有效的习惯，或者想改掉坏习惯，应该用良好的新习惯去取代，而不是强行杜绝掉坏习惯&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-2-不如你想象中那样起作用的性格因素&quot;&gt;&lt;a href=&quot;#1-2-不如你想象中那样起作用的性格因素&quot; class=&quot;headerlink&quot; title=&quot;1.2 不如你想象中那样起作用的性格因素&quot;&gt;&lt;/a&gt;1.2 不如你想象中那样起作用的性格因素&lt;/h2&gt;&lt;p&gt;注意以下列举的性格都是&lt;strong&gt;反面因素&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;坚持：多数时候软件开发中的坚持其实就是没有好处的“固执”，当在某段新代码上卡壳时，不妨另辟蹊径，尝试重新设计类，或者绕过去，以后回头再试。花好几个小时干掉某一错误确实会有满足感，但实际上早点放弃固有的思路，换个角度可能可以节省更多时间。&lt;/li&gt;
&lt;li&gt;经验：由于软件技术更新换代太快，所谓的“经验”很快就会落伍，程序员要持续学些，保持与时俱进。&lt;/li&gt;
&lt;li&gt;编程狂人：彻夜编程让你感觉像是世上最好的程序员，却要花几个星期去纠正你在短暂辉煌时埋下的失误。可以热爱编程，但热情不能代替熟练的能力，请想明白什么更重要。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;2-软件开发艺术的有关问题&quot;&gt;&lt;a href=&quot;#2-软件开发艺术的有关问题&quot; class=&quot;headerlink&quot; title=&quot;2. 软件开发艺术的有关问题&quot;&gt;&lt;/a&gt;2. 软件开发艺术的有关问题&lt;/h1&gt;&lt;p&gt;这一章相当于对全书介绍的各种细节背后所折射出的哲学思想做出一个总结。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;克服复杂性：《代码大全》绝大部分的篇幅都用于阐述如何划分系统模块，抽象类和接口，遵循什么样的编程规范等等，归根结底是为了降低软件的复杂性。&lt;/li&gt;
&lt;li&gt;精选开发过程：对于小的项目，程序员的个人才能对软件质量影响最大，对于多人项目，组织性的重要程度超过了个人技能。关于开发过程的重要性，一个明显的例子是看看在需求还未确定就开始设计和编码的后果。其他有用的开发过程，如增量开发，先设计后编码，先粗调后优化，伪代码编码并不断添加注释等等，均在之前的文章提到过，不再赘述。&lt;/li&gt;
&lt;li&gt;首先为人写程序，其次才是为机器：可读的代码写起来并不比含糊的代码多花时间，得到的好处是巨大的。自己维护，后期重构，复审代码，别人修改程序，统统都要读到代码，因此一次性编写可读性强的代码，是非常经济划算的。即便是自写自用的私有代码，也应该认真对待，因为这是一种优秀的习惯（习惯在上述个人性格中提到过）。&lt;/li&gt;
&lt;li&gt;深入一门语言去编程，不浮于表面：要先考虑要干什么，然后采用手头的工具去实现目标。如果你所用的语言不支持某种你想要的特性，可以尝试用一些变通的方法以最大限度地遵循编程规范，因为规范能帮助你理清环境中的危险特性。&lt;/li&gt;
&lt;li&gt;借助规范集中注意力：规范能够节省程序员回答同样问题的麻烦，能精确地传达重要信息，免除各种编码的危险做法，还能弥补语言的某些不足之处&lt;/li&gt;
&lt;li&gt;基于问题域编程：顶层的代码要说明想解决的问题，而不要充斥各种与文件、数据结构、数据类型有关的操作细节。设计程序时，应考虑下图这样的抽象层次&lt;ul&gt;
&lt;li&gt;&lt;img src=&quot;http://raytaylorlin-blog.qiniudn.com/image%2Fsoftware%2F%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%8A%BD%E8%B1%A1%E5%B1%82%E6%AC%A1.png&quot; alt=&quot;程序的抽象层次&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;留心警告信号：当你或其他人说“这段代码暗藏玄机”时，或者类中含有比平均数目更多的错误，或者发现子程序中有许多判断点、嵌套，或者发现代码有重复，或者发现代码不容易写注释和命名变量，或者编译时出现警告等等，这些都是警告信号。任何警告信号都应让你质疑程序的质量，并促使你去寻求更满意的解决之道。&lt;/li&gt;
&lt;li&gt;一次又一次迭代：需求、设计、开发、测试，软件开发从头到尾每一步都充斥着迭代并逐步精化的过程。所以不要追求所谓的“一步登天”。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不要&lt;/strong&gt;存在软件信仰（即坚持某种做法）&lt;ul&gt;
&lt;li&gt;折中主义：要对编程问题找出最有效的解决方案时，盲目迷信某种方法只会缩小你的选择余地。折中主义是一种有益的态度，对于每个特定问题，应该将多种方法视为工具箱中的工具。多数时候工具的选择关系不大，但有些场合需要自己判断权衡，挑选最好的工具&lt;/li&gt;
&lt;li&gt;试验：要想有效地试验，应能基于试验结果改变思路。许多顽固的方法源于对错误的畏惧心理，“试图没有错误”是最大的错误。软件开发的各方面，你都应保待开放的心态&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;3-书单&quot;&gt;&lt;a href=&quot;#3-书单&quot; class=&quot;headerlink&quot; title=&quot;3. 书单&quot;&gt;&lt;/a&gt;3. 书单&lt;/h1&gt;&lt;p&gt;书中最后一章作者给出了一些建议阅读的经典著作，下面挑选了一部分有中译版本的书（有一些书再版了多次，链接给出的都是最新的版本）组成一个参考书单，供以后学习。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;软件构建类&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://book.douban.com/subject/5387402/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《程序员修炼之道》&lt;/a&gt;（《The Pragmatic Programmer》，Andrew Hunt / David Thomas）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://book.douban.com/subject/3227098/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《编程珠玑》&lt;/a&gt;（《Programming Pearls》，Jon Bentley）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://book.douban.com/subject/6524000/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《程序设计实践&lt;strong&gt;（评注版）&lt;/strong&gt;》&lt;/a&gt;（《The Practice of Programming》，Brian W. Kernighan / Rob Pike），注意这本书市面上没有很好的中译本，只有最新的这本评注版&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;软件工程综述类&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://book.douban.com/subject/26419766/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《软件开发心理学》&lt;/a&gt;（《The Psychology of Computer Programming》，Gerald M. Weinberg）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://book.douban.com/subject/2230248/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《人月神话》&lt;/a&gt;（《The Mythical Man-Month》，Frederick P.Brooks）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://book.douban.com/subject/6047742/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《软件工程：实践者的研究方法》&lt;/a&gt;（《The Mythical Man-Month》，Roger S.Pressman）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考文献：电子工业出版社《代码大全（第2版）》第33、34、35章&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;本文是《代码大全》学习笔记系列的最后一篇。书中最后几章是一些杂项主题，本文将简要记录这几个主题的内容，包括个人性格对编程的影响，软件开发艺术的有关问题，以及关于软件工程的推荐书单。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="综合" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/"/>
    
      <category term="软件工程" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="软件构建" scheme="http://raytaylorlin.com/tags/%E8%BD%AF%E4%BB%B6%E6%9E%84%E5%BB%BA/"/>
    
      <category term="软件工程" scheme="http://raytaylorlin.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="代码大全" scheme="http://raytaylorlin.com/tags/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>软件构建（十四）——代码布局与自说明代码</title>
    <link href="http://raytaylorlin.com/tech/complex/software/software-construction-14/"/>
    <id>http://raytaylorlin.com/tech/complex/software/software-construction-14/</id>
    <published>2016-05-12T13:17:18.000Z</published>
    <updated>2016-05-12T13:16:22.704Z</updated>
    
    <content type="html">&lt;p&gt;本文关注的是计算机编程的美学话题——程序源代码的布局和自说明性。尽管这些技巧并不影响执行速度、内存使用量等方面的程序性能，但它却会让你日后理解、检查以及修改代码变得更容易，也使其他人在你缺位的时候更容易阅读、理解和修改你的代码。&lt;/p&gt;
&lt;p&gt;需要注意的是，形成良好的代码布局，并让代码具备自说明性，需要始终贯穿项目的生命期，晚了就很难做好了。要想完全实现这些细节规定，在最初建构时就要着手去做。如果你干的是合作项目，更是要在开始编码之前统一大家的风格。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-代码布局&quot;&gt;&lt;a href=&quot;#1-代码布局&quot; class=&quot;headerlink&quot; title=&quot;1. 代码布局&quot;&gt;&lt;/a&gt;1. 代码布局&lt;/h1&gt;&lt;h2 id=&quot;1-1-良好布局的目标&quot;&gt;&lt;a href=&quot;#1-1-良好布局的目标&quot; class=&quot;headerlink&quot; title=&quot;1.1 良好布局的目标&quot;&gt;&lt;/a&gt;1.1 良好布局的目标&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;准确表现代码的逻辑结构：例如利用缩进、空行等空白来表达逻辑关系&lt;/li&gt;
&lt;li&gt;始终如一地表现代码的逻辑结构&lt;/li&gt;
&lt;li&gt;改善可读性：如果有一种缩进策略合乎逻辑，但却令程序更难看懂，那么它就毫无用处&lt;/li&gt;
&lt;li&gt;经得起修改：好的布局应该在修改某行时不必连带修改其他行的代码&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-2-常用布局技术与风格&quot;&gt;&lt;a href=&quot;#1-2-常用布局技术与风格&quot; class=&quot;headerlink&quot; title=&quot;1.2 常用布局技术与风格&quot;&gt;&lt;/a&gt;1.2 常用布局技术与风格&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;空白：包括空格、制表符、换行、空行等等。程序中的空白就像书籍中划分章节、段落、句子一样向读者展示组织主题的思路&lt;ul&gt;
&lt;li&gt;分组：确保相关的语句成组放在一起，用空行分隔，就像文章中的一段话一样&lt;/li&gt;
&lt;li&gt;空行：将不相关的语句分隔开，就像文章中段与段的分隔一样&lt;/li&gt;
&lt;li&gt;缩进：显示程序的逻辑结构&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;括号：对包含两个以上的项的表达式，应该用括号去澄清&lt;/li&gt;
&lt;li&gt;控制结构布局&lt;ul&gt;
&lt;li&gt;别让begin和end对两次缩进&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;单条语句&lt;/strong&gt;的代码块的格式要前后统一&lt;/li&gt;
&lt;li&gt;对于复杂的表达式，将条件分隔放在几行上&lt;/li&gt;
&lt;li&gt;case语句不要有行尾布局的例外&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;单条语句布局&lt;ul&gt;
&lt;li&gt;各种标点符号两侧使用空格会让逻辑表达式更易读&lt;/li&gt;
&lt;li&gt;使用空格让数组引用，子程序参数更易读&lt;/li&gt;
&lt;li&gt;单条语句过长时，应分行，并让续行显得更明显，通常在行尾以&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;、&lt;code&gt;||&lt;/code&gt;、&lt;code&gt;+-*/&lt;/code&gt;等符号为结尾&lt;/li&gt;
&lt;li&gt;续行要以标准的空格数缩进&lt;/li&gt;
&lt;li&gt;不要将赋值语句按等号对齐&lt;/li&gt;
&lt;li&gt;每行仅写一条语句（C++中不要让一行里有多个副作用操作（如&lt;code&gt;++a&lt;/code&gt;））&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据声明布局&lt;ul&gt;
&lt;li&gt;每行只声明一个变量&lt;/li&gt;
&lt;li&gt;合理组织声明顺序：建议按类型分类&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;注释布局&lt;ul&gt;
&lt;li&gt;注释的缩进要与相应代码一致&lt;/li&gt;
&lt;li&gt;每行注释用至少一个空行分开&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;子程序布局&lt;ul&gt;
&lt;li&gt;用空行分隔子程序的各部分&lt;/li&gt;
&lt;li&gt;将子程序参数按标准缩进，如果参数过多，可以考虑一行放一个参数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;类布局&lt;ul&gt;
&lt;li&gt;类的内容按以下顺序排布：说明类及其完整用法的头部注释、类数据、构造函数与析构函数、public子程序、protected子程序、private子程序&lt;/li&gt;
&lt;li&gt;一个文件应只有一个类，文件的命名应与类名有关&lt;/li&gt;
&lt;li&gt;在文件中清晰地分隔各子程序&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关于块结构和花括号指定的块边界，不同语言有不一样的规范。书中所提规范放在某些语言也不适用，实际使用应遵循相应的规范，此处不赘述书中所提的布局与风格。&lt;/p&gt;
&lt;h1 id=&quot;2-自说明代码&quot;&gt;&lt;a href=&quot;#2-自说明代码&quot; class=&quot;headerlink&quot; title=&quot;2. 自说明代码&quot;&gt;&lt;/a&gt;2. 自说明代码&lt;/h1&gt;&lt;h2 id=&quot;2-1-编程风格的重要性&quot;&gt;&lt;a href=&quot;#2-1-编程风格的重要性&quot; class=&quot;headerlink&quot; title=&quot;2.1 编程风格的重要性&quot;&gt;&lt;/a&gt;2.1 编程风格的重要性&lt;/h2&gt;&lt;p&gt;自说明代码代表了易读性的最高水平，而且一般是&lt;strong&gt;由良好的编码风格决定&lt;/strong&gt;，很大程度&lt;strong&gt;与注释无关&lt;/strong&gt;。对于精心编写的代码而言， 注释不过是美丽衣裳上的小饰物而已。关于自说明代码所体现出的编码风格，请参见&lt;a href=&quot;http://www.kancloud.cn/raytaylorlin/code-complete-checklist/150866&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;核对表：自说明代码&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;2-2-高效注释&quot;&gt;&lt;a href=&quot;#2-2-高效注释&quot; class=&quot;headerlink&quot; title=&quot;2.2 高效注释&quot;&gt;&lt;/a&gt;2.2 高效注释&lt;/h2&gt;&lt;p&gt;注释的作用分为六种：重复代码（用文字把代码的工作又描述一次，&lt;strong&gt;这种注释是废话，应杜绝&lt;/strong&gt;）、解释代码（通常是因为代码含糊不清，此时应&lt;strong&gt;改进代码&lt;/strong&gt;而不是添加注释）、代码标记（提示工作未做完，待修复等等）、概述代码（用一两句话把若干行代码的意思说出来）、代码意图说明（指出一段代码要解决的问题，而非解决问题的方法）、传达代码无法表述的信息（如版权声明、保密要求、doc注释符号等等）。&lt;strong&gt;对于完工的代码，只允许有的三种注释类型：概述代码、代码说明意图和代码无法表达的信息。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;注释占用太多时间通常归因于两点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;注释的风格可能耗时或枯燥乏味。如果这样，请另谋新的风格。需要庞大工作量的注释风格维护起来也会令人头痛。如果注释不便修改，人们就不愿意修改。于是注释就会变得不准确，起到误导作用，反而还不如没有注释&lt;/li&gt;
&lt;li&gt;说明程序干什么的话不好想出来。这通常是你没有真正理解程序的信号。“写注释”所占用的时间其实都用在了更好地理解程序上面，而不管你写不写注释，这些时间注定是得花的&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面是高效注释的几条指导原则。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;采用不会打断或抑制修改的注释凤格：不要为了美观而使用大量的&lt;code&gt;.-*&lt;/code&gt;符号排版的注释，例如用星号围成一个矩形的注释，每加入一行都得小心维护右边的星号。如果花大量时间增删符号只是为了对齐，你就不是在编程，而是浪费时光&lt;/li&gt;
&lt;li&gt;用伪代码编程法减少注释时间&lt;/li&gt;
&lt;li&gt;将注释集成到你的开发过程中：不要项目快结束时才开始写注释，也不要把注释当做专门的任务，而应该边写代码边注释。&lt;/li&gt;
&lt;li&gt;性能不是逃避注释的好借口：像Javascript的注释会增大网络传输的流量，但这不是理由，解决方案应该是构建不包含注释的发布版代码，区别于开发版代码&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-3-注释技术&quot;&gt;&lt;a href=&quot;#2-3-注释技术&quot; class=&quot;headerlink&quot; title=&quot;2.3 注释技术&quot;&gt;&lt;/a&gt;2.3 注释技术&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;注释单行&lt;ul&gt;
&lt;li&gt;不要随意添加无关的注释&lt;/li&gt;
&lt;li&gt;尽量不要使用行尾注释，因为写行尾难以格式化和维护，也经常是重复说明本行代码的废话。这几种例外情况可以使用行尾注释：用于数据声明，或标记代码块尾部（如end while，end if）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;注释代码段&lt;ul&gt;
&lt;li&gt;注释应表达代码段的意图，指出代码本身说不清的本意。TIPS：在给代码段写意图注释时，想象这段代码转换成一个子程序，应该命名什么名字，这个名字很有可能就是意图&lt;/li&gt;
&lt;li&gt;注释应注重“为何做（why）”而不是“怎么做（how）”&lt;/li&gt;
&lt;li&gt;用注释为后面的内容做铺垫：好的注释会让读者只要浏览注释就能了解代码在做什么，去哪找特定的操作&lt;/li&gt;
&lt;li&gt;说明非常规做法（trick）&lt;/li&gt;
&lt;li&gt;代码错误或语言环境独特点都要加注释&lt;/li&gt;
&lt;li&gt;给出不得不故意违背良好编程风格的理由&lt;/li&gt;
&lt;li&gt;不要为投机取巧的代码加注释说明，应重写之&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;注释数据声明&lt;ul&gt;
&lt;li&gt;注释数据的单位（包括单位所处的背景环境）和取值范围（包括输入数据的限制）&lt;/li&gt;
&lt;li&gt;注释枚举类型各个值的含义，注释bit位标识的含义&lt;/li&gt;
&lt;li&gt;注释全局数据：指出该数据的目的，为何必须是全局数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;注释控制结构&lt;ul&gt;
&lt;li&gt;应在每个if、case、循环前加上注释，阐明控制结构的意图&lt;/li&gt;
&lt;li&gt;在长控制结构或嵌套控制结构结尾处加上注释&lt;/li&gt;
&lt;li&gt;如果用到了上一条规则，那么应将控制结构结束处的注释看成是代码太复杂的征兆：最好办法就是重写代码，使之不再复杂到需要费劲注释的程度&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;注释子程序&lt;ul&gt;
&lt;li&gt;在子程序上部用一两句话说明其意图，如果参数很复杂要在声明参数处注释这些参数（如果参数涉及输出，还要特别说明）&lt;/li&gt;
&lt;li&gt;利用诸如Javadoc之类的代码说明工具，则可以替代上一条&lt;/li&gt;
&lt;li&gt;注释接口假设：例如假设传入的数组是有序的，传入的对象是初始化过的等等，都应该描述清楚&lt;/li&gt;
&lt;li&gt;对子程序的局限性作注释：例如指出结果的精确度，子程序碰到麻烦时的默认行为，对程序做什么修改会损坏此子程序等等&lt;/li&gt;
&lt;li&gt;说明子程序对全局数据的操作，如果有的话&lt;/li&gt;
&lt;li&gt;记录所用算法的来源&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;注释类和文件&lt;ul&gt;
&lt;li&gt;说明类的设计方法，局限性、用法假设，不要在类接口处说明实现细节&lt;/li&gt;
&lt;li&gt;在文件开头处用注释块说明文件的意图和内容&lt;/li&gt;
&lt;li&gt;在文件注释块中包含作者姓名、电子邮件、电话号码、版本控制标记、法律通告等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考文献：电子工业出版社《代码大全（第2版）》第31、32章&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;本文关注的是计算机编程的美学话题——程序源代码的布局和自说明性。尽管这些技巧并不影响执行速度、内存使用量等方面的程序性能，但它却会让你日后理解、检查以及修改代码变得更容易，也使其他人在你缺位的时候更容易阅读、理解和修改你的代码。&lt;/p&gt;
&lt;p&gt;需要注意的是，形成良好的代码布局，并让代码具备自说明性，需要始终贯穿项目的生命期，晚了就很难做好了。要想完全实现这些细节规定，在最初建构时就要着手去做。如果你干的是合作项目，更是要在开始编码之前统一大家的风格。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="综合" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/"/>
    
      <category term="软件工程" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="软件构建" scheme="http://raytaylorlin.com/tags/%E8%BD%AF%E4%BB%B6%E6%9E%84%E5%BB%BA/"/>
    
      <category term="软件工程" scheme="http://raytaylorlin.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="代码大全" scheme="http://raytaylorlin.com/tags/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>软件构建（十三）——代码集成</title>
    <link href="http://raytaylorlin.com/tech/complex/software/software-construction-13/"/>
    <id>http://raytaylorlin.com/tech/complex/software/software-construction-13/</id>
    <published>2016-05-09T07:35:29.000Z</published>
    <updated>2016-05-12T13:13:50.400Z</updated>
    
    <content type="html">&lt;p&gt;集成是指将一些独立的软件组件组合为一个完整系统。对大项目，集成也许要花数周或数月时间，把一组程序编织为一个整体。本文将首先介绍不太常用的阶段式集成，然后再介绍更为常用的增量集成，其中集成的策略是讨论的重点。最后每日构建与冒烟测试的使用原则。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;集成是在开发人员完成开发者测试之后才进行的，而且集成过程是与系统测试一道进行的，所以集成有时也被认为是一种测试行为。然而，集成本身就足够复杂了，因此应该被看做一项独立的行动。程序集成有两种方式：阶段式集成和增量集成。&lt;/p&gt;
&lt;h1 id=&quot;1-阶段式集成&quot;&gt;&lt;a href=&quot;#1-阶段式集成&quot; class=&quot;headerlink&quot; title=&quot;1. 阶段式集成&quot;&gt;&lt;/a&gt;1. 阶段式集成&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;设计、编码、测试、调试各个类，这一步称为“单元开发”&lt;/li&gt;
&lt;li&gt;将这些类组合为一个庞大的系统，这一步成为“系统集成”&lt;/li&gt;
&lt;li&gt;测试并调试整个系统，这一步成为“系统瓦解（system dis-integration）”&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这种集成的问题是，当第一次把系统中的类放到一起时，新的问题会不可避免地大量浮现，所有的类都有嫌疑导致出问题的位置难以确定。所以对绝大多数情况，阶段式集成都不是很适用。&lt;/p&gt;
&lt;h1 id=&quot;2-增量集成&quot;&gt;&lt;a href=&quot;#2-增量集成&quot; class=&quot;headerlink&quot; title=&quot;2. 增量集成&quot;&gt;&lt;/a&gt;2. 增量集成&lt;/h1&gt;&lt;h2 id=&quot;2-1-方法&quot;&gt;&lt;a href=&quot;#2-1-方法&quot; class=&quot;headerlink&quot; title=&quot;2.1 方法&quot;&gt;&lt;/a&gt;2.1 方法&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;开发一个小的系统功能部件。它可能是最小的功能部件、最难的部件、关键部件、或者以上的某种组合，对它彻底地测试并调试。将它作为骨架，稍后附着肌肉、神经、皮肤等系统的其余部件&lt;/li&gt;
&lt;li&gt;设计、编码、测试、调试某个类&lt;/li&gt;
&lt;li&gt;将这个新的类集成到系统骨架上，测试并调试“骨架和新类的结合体”。在进一步添加任何新类之前，确保该结合体能工作。如果做完了剩余的所有工作，就回到步骤2开始重复这一过程&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;2-2-相对阶段式集成的优势&quot;&gt;&lt;a href=&quot;#2-2-相对阶段式集成的优势&quot; class=&quot;headerlink&quot; title=&quot;2.2 相对阶段式集成的优势&quot;&gt;&lt;/a&gt;2.2 相对阶段式集成的优势&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;易于定位错误：降低“多个问题之间相互影响”或“一个问题将另一个问题掩盖”的风险&lt;/li&gt;
&lt;li&gt;及旱在项目里取得系统级的成果&lt;/li&gt;
&lt;li&gt;改善对进度的监控：利于管理层判断进度和需求&lt;/li&gt;
&lt;li&gt;更加充分地测试系统中的各个单元&lt;/li&gt;
&lt;li&gt;能在更短的开发进度计划内建造出整个系统&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-3-策略&quot;&gt;&lt;a href=&quot;#2-3-策略&quot; class=&quot;headerlink&quot; title=&quot;2.3 策略&quot;&gt;&lt;/a&gt;2.3 策略&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;自顶向下集成&lt;ul&gt;
&lt;li&gt;一般从主入口（Main函数、主窗体等等）开始，测试顶层类时需要一些存根（stub）类辅助，最终逐渐替换为实际的类&lt;/li&gt;
&lt;li&gt;优点：能快速得到一个能部分工作的系统，并及早地暴露一些设计上的问题&lt;/li&gt;
&lt;li&gt;缺点：棘手的系统接口的演练必须留到最后才进行，有问题的底层可能会反过来影响顶层&lt;/li&gt;
&lt;li&gt;纯粹的自顶向下集成几乎是不可能的，大多时候使用混合方法集成，或用下图的在各个竖直划分的功能块中自顶向下集成&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://raytaylorlin-blog.qiniudn.com/image%2Fsoftware%2F%E5%9C%A8%E5%90%84%E4%B8%AA%E7%AB%96%E7%9B%B4%E5%88%92%E5%88%86%E7%9A%84%E5%8A%9F%E8%83%BD%E5%9D%97%E4%B8%AD%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E9%9B%86%E6%88%90.png&quot; alt=&quot;在各个竖直划分的功能块中自顶向下集成&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自底向上集成&lt;ul&gt;
&lt;li&gt;首先要完成整个系统的设计，然后一个一个添加底层类向上层集成，最初需要编写驱动测试类&lt;/li&gt;
&lt;li&gt;优点：容易定位错误，尽早演练“可能存在问题的系统接口”&lt;/li&gt;
&lt;li&gt;缺点：如果高层存在概念上的设计问题，那么要把所有细节工作都做完才能发现&lt;/li&gt;
&lt;li&gt;一般也很少用纯粹的自底向上集成&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;三明治集成&lt;ul&gt;
&lt;li&gt;首先集成继承体系顶部的高层业务对象类，然后集成底部的与设备接口的类和广泛使用的工具类，最后集成中间层的类&lt;/li&gt;
&lt;li&gt;结合了上述两种方式的优点，是现实的实用的方法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;风险导向的集成&lt;ul&gt;
&lt;li&gt;大顺序和三明治集成一致，但细节顺序，是优先考虑高风险的实现最有挑战的部件，如顶层接口、底层系统接口、未被透彻理解的算法的类等等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;功能导向的集成&lt;ul&gt;
&lt;li&gt;首先需要搭建好骨架，然后按照功能（模块）划分顺序来集成，如下图所示&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://raytaylorlin-blog.qiniudn.com/image%2Fsoftware%2F%E5%8A%9F%E8%83%BD%E5%AF%BC%E5%90%91%E7%9A%84%E9%9B%86%E6%88%90%E7%A4%BA%E6%84%8F%E5%9B%BE.png&quot; alt=&quot;功能导向的集成示意图&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;T型集成&lt;ul&gt;
&lt;li&gt;先选中某个特定的“竖直块”及早开发并集成，这个功能块应该能从头到尾演练系统，并找出系统设计的全部主要问题。纠正所有问题后，就可以开始开发系统其它核心部件，如下图所示。这种方法常与风险导向和功能导向集成集合使用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://raytaylorlin-blog.qiniudn.com/image%2Fsoftware%2FT%E5%9E%8B%E9%9B%86%E6%88%90%E7%A4%BA%E6%84%8F%E5%9B%BE.png&quot; alt=&quot;T型集成示意图&quot;&gt;&lt;/p&gt;
&lt;p&gt;集成顺序的策略有多种多样的形状和规模，没有哪一种对所有情况而言都是最佳的。&lt;strong&gt;最佳集成步骤随项目不同而变化，最佳解决方案总是为了满足特定项目的特定需求而制定的，不要像教条一样遵循前面提到的任何过程。&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;3-每日构建与冒烟测试&quot;&gt;&lt;a href=&quot;#3-每日构建与冒烟测试&quot; class=&quot;headerlink&quot; title=&quot;3. 每日构建与冒烟测试&quot;&gt;&lt;/a&gt;3. 每日构建与冒烟测试&lt;/h1&gt;&lt;p&gt;无论选用哪种集成策略，&lt;a href=&quot;http://baike.baidu.com/view/1704207.htm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;每日构建（daily build）&lt;/a&gt;和&lt;a href=&quot;http://baike.baidu.com/view/120001.htm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;冒烟测试&lt;/a&gt;都是软件集成的好方法。这些简单的过程可以降低出现低质量软件的风险，也便于诊断缺陷，并且每天的成果可以极大地鼓舞士气。以下是这两种方法的一些使用原则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关键是&lt;strong&gt;每一天&lt;/strong&gt;坚持build：某次build失败可以将错误锁定在一天之内&lt;/li&gt;
&lt;li&gt;检查失败的build：每个项目要建立一套评定“什么才算是破坏了build”的质量标准&lt;/li&gt;
&lt;li&gt;每天进行准确的冒烟测试：冒烟测试应彻底地从头到尾演练&lt;strong&gt;已完成的&lt;/strong&gt;系统的主要功能，不要认为是浪费时间的重复性工作&lt;/li&gt;
&lt;li&gt;自动化：&lt;strong&gt;脱离自动化谈每日构建与冒烟测试是不切实际的&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;成立build小组&lt;/li&gt;
&lt;li&gt;仅当有意义时，才将修订（revisions）加入build中……：因为通常开发者编写代码的速度不会快到使系统每天都有明显的进展&lt;/li&gt;
&lt;li&gt;……但是别等太久才将修订加入进来：警惕某个开发人员接连两三天都不check in他做的改动，他很可能陷入一组牵扯到大量文件的修订中&lt;/li&gt;
&lt;li&gt;要求开发人员在把他的代码添加到系统之前，进行本地冒烟测试&lt;/li&gt;
&lt;li&gt;为即将添加到build的代码准备一块暂存区，在暂存区产生新的build并认为其可接受时，才合并到主源码中&lt;/li&gt;
&lt;li&gt;惩罚破坏build的人：build失败是异常情况，应严肃对待&lt;/li&gt;
&lt;li&gt;在早上发布build：测试人员可以当天测试，发现问题也能尽早找到开发者解决&lt;/li&gt;
&lt;li&gt;即使有进度压力，也要保持daily build和冒烟测试&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考文献：电子工业出版社《代码大全（第2版）》第29章&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;集成是指将一些独立的软件组件组合为一个完整系统。对大项目，集成也许要花数周或数月时间，把一组程序编织为一个整体。本文将首先介绍不太常用的阶段式集成，然后再介绍更为常用的增量集成，其中集成的策略是讨论的重点。最后每日构建与冒烟测试的使用原则。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="综合" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/"/>
    
      <category term="软件工程" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="软件构建" scheme="http://raytaylorlin.com/tags/%E8%BD%AF%E4%BB%B6%E6%9E%84%E5%BB%BA/"/>
    
      <category term="软件工程" scheme="http://raytaylorlin.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="代码大全" scheme="http://raytaylorlin.com/tags/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>软件构建（十二）——软件的规模与管理</title>
    <link href="http://raytaylorlin.com/tech/complex/software/software-construction-12/"/>
    <id>http://raytaylorlin.com/tech/complex/software/software-construction-12/</id>
    <published>2016-05-06T09:00:40.000Z</published>
    <updated>2016-05-12T13:14:52.322Z</updated>
    
    <content type="html">&lt;p&gt;软件开发的规模扩大并不是像“拿一个小项目来，然后增大它的每一部分”那样简单。如果要开发大型软件，就必须了解软件规模对构建的影响。此外，本文将记录与构建直接相关的一些特定管理问题。如果你是一名开发人员，本文将帮助你了解管理者需要考虑的一些问题；如果你是一名管理者，本文将帮助你了解开发人员是如何看待管理者的，以及如何才能有效地管理构建。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-程序规模对构建的影响&quot;&gt;&lt;a href=&quot;#1-程序规模对构建的影响&quot; class=&quot;headerlink&quot; title=&quot;1. 程序规模对构建的影响&quot;&gt;&lt;/a&gt;1. 程序规模对构建的影响&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;成员交流与项目规模的关系：交流路径越多，花在交流上的时间就越多（见下图），因交流而出错的机会也就越大，改善交流效率的常用方法是采用正式的文挡&lt;ul&gt;
&lt;li&gt;&lt;img src=&quot;http://7d9rl0.com1.z0.glb.clouddn.com/image/software/%E6%88%90%E5%91%98%E4%BA%A4%E6%B5%81%E4%B8%8E%E9%A1%B9%E7%9B%AE%E8%A7%84%E6%A8%A1%E7%9A%84%E5%85%B3%E7%B3%BB.png&quot; alt=&quot;成员交流与项目规模的关系&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;项目规模对错误的影响：在小项目中，构建错误大约占所有被发现错误的75%，在更大的项目中，构建错误占错误总数的比例逐步下降到50%左右，而需求错误和架构错误则弥补了其中差额。缺陷密度（每1000行代码所包含的缺陷数量）会随项目规模增大而增加&lt;/li&gt;
&lt;li&gt;顶目规模对生产率的影响：小项目的生产率会比大项目高出2至3倍，并且最小的项目和最大的项目的生产率差距可能达到5到10倍之巨&lt;/li&gt;
&lt;li&gt;顶目规模对开发活动的影响：对小型项目，构建占差不多65%的开发实践，随着项目规模增大，构建的比重逐渐减小，架构、设计、集成和测试占更多时间&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;2-管理构建&quot;&gt;&lt;a href=&quot;#2-管理构建&quot; class=&quot;headerlink&quot; title=&quot;2. 管理构建&quot;&gt;&lt;/a&gt;2. 管理构建&lt;/h1&gt;&lt;h2 id=&quot;2-1-鼓励良好的编码实践&quot;&gt;&lt;a href=&quot;#2-1-鼓励良好的编码实践&quot; class=&quot;headerlink&quot; title=&quot;2.1 鼓励良好的编码实践&quot;&gt;&lt;/a&gt;2.1 鼓励良好的编码实践&lt;/h2&gt;&lt;p&gt;从管理的角度出发，强制采用一套严格的技术标准并不是个好主意。如果项目中有人要制定标准，那么应该由一位受人尊敬的架构师来做，而不应该由管理者来做。下面给出一些编码实践，这些实践比呆板的编码标准更容易实行：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;给项目的每一部分分派两个人：结对编程，导师带学生等等&lt;/li&gt;
&lt;li&gt;同行复查代码：包括程序员本人和至少两名评审员的复查，可以为改善代码质量提供压力&lt;/li&gt;
&lt;li&gt;要求代码签名：在认定代码完成之前，高级技术人员要在代码清单上签字&lt;/li&gt;
&lt;li&gt;安排一些好的代码示例供人参考&lt;/li&gt;
&lt;li&gt;强调代码是公有财产&lt;/li&gt;
&lt;li&gt;奖励好代码：给予程序员想要的奖励，只有非常出色的代码才应得到奖励&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-2-配置管理&quot;&gt;&lt;a href=&quot;#2-2-配置管理&quot; class=&quot;headerlink&quot; title=&quot;2.2 配置管理&quot;&gt;&lt;/a&gt;2.2 配置管理&lt;/h2&gt;&lt;p&gt;配置管理即“变更控制”。如果你不对需求变更加以控制，那么就会为系统中某些最终会被去除的部件编写代码，也会去写出一些可能与系统中新的部件不兼容的代码；可能会修改某个别人也正在修改的子程序，把两个人的改动合并导致出现问题。总之，配置管理就是使用评估提交的更改、追踪更改、保留系统在不同时间点的历史版本等等技术来对软件项目的变化进行控制。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需求变更和设计变更&lt;ul&gt;
&lt;li&gt;遵循某种系统化的变更控制手续&lt;/li&gt;
&lt;li&gt;成组地处理变更请求：先记下所有的想法和建议，直到有时间再去整体处理它们，以防总是在中途突然变卦&lt;/li&gt;
&lt;li&gt;评估每项变更的成本：重新设计和编码，修改用户文档，评估代码复查，重新测试等等各种时间成本&lt;/li&gt;
&lt;li&gt;提防大量的变更请求：有时这可能是一个表明需求、架构或上层设计做的不够好导致无法支持变更的警报&lt;/li&gt;
&lt;li&gt;成立变更控制委员会或者类似机构&lt;/li&gt;
&lt;li&gt;警惕官僚主义，但也不要因为害怕官僚主义而排斥有效的变更控制&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;软件代码变更：使用合适的版本控制软件&lt;/li&gt;
&lt;li&gt;工具版本：可能有些项目需要“重新构造出‘创建软件的各个特定版本’的原样环境”的能力，这时需要把编译器、链接器、代码库等也纳入版本控制中&lt;/li&gt;
&lt;li&gt;机器配置：使用标准化的开发机器配置和操作系统映像，可以省掉许多开发前配置的麻烦&lt;/li&gt;
&lt;li&gt;备份计划：项目过程中应定期备份代码、文档、图表以及保存介质；要测试备份过程，确保所需的全部数据能正确恢复；昨晚项目后及时归档&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-3-评估构建进度&quot;&gt;&lt;a href=&quot;#2-3-评估构建进度&quot; class=&quot;headerlink&quot; title=&quot;2.3 评估构建进度&quot;&gt;&lt;/a&gt;2.3 评估构建进度&lt;/h2&gt;&lt;p&gt;对于项目预估进度和实际进度，有调查表明，开发人员的估计值比实际值要乐观20%~30%。评估项目规模的方法有很多种，例如使用评估软件，使用算法方法，聘请外界的评估专家，评估项目的每一部分并加起来等等。下面是一套评估项目的参考原则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;建立目标：理清评估的目的、内容、准确度、乐观评估和悲观评估结果等&lt;/li&gt;
&lt;li&gt;为评估留出时间，并且做出计划&lt;/li&gt;
&lt;li&gt;清楚地说明软件需求&lt;/li&gt;
&lt;li&gt;在底层细节层面（划分为多个小块并分别）进行评估&lt;/li&gt;
&lt;li&gt;使用若干不同的评估方法，并且比较其结果&lt;/li&gt;
&lt;li&gt;在项目推进过程中定期做重新评估&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了按时完成软件项目而做的“计划”中，评估是很重要的组成部分。然而，最初评估的准确度的重要性远远比不上“随后为了完成进度而成功地&lt;strong&gt;控制资源&lt;/strong&gt;”的重要性。如果项目进度落后了，人们经常会产生一些错觉：“我们后面一定会加班加点把时间补回来”，调查显示越接近项目后期，延误和超支的现象就越严重；“扩充团队来加速开发”，新手需要先花时间熟悉项目，占用现有人员的培训时间，然后才能发挥出生产率，而且仅仅增加人员数量，会导致项目交流的复杂度和数量增加，除非项目的任务是可分割的才能通过增加人手完成。&lt;/p&gt;
&lt;p&gt;缩减项目范围是在进度落后时的有效手段。最初做产品计划的时候，要把产品的功能划分成“必须有”、“有了更好”和“可选择”三类。如果进度落后了，那么就调整“可选择”和“有了更好”的优先级，并扔掉那些最不重要的功能。&lt;/p&gt;
&lt;h2 id=&quot;2-4-把程序员当人看&quot;&gt;&lt;a href=&quot;#2-4-把程序员当人看&quot; class=&quot;headerlink&quot; title=&quot;2.4 把程序员当人看&quot;&gt;&lt;/a&gt;2.4 把程序员当人看&lt;/h2&gt;&lt;p&gt;首先要了解程序员的时间分配。研究表明一个程序员大约有30%的时间花费在“对项目没有直接好处”的非技术活动之上：步行、个人事务等，学习和编写代码占约30%。&lt;/p&gt;
&lt;p&gt;其次是了解程序员的信仰问题。这些信仰涉及编程语言、编码风格、编程工具、编程方法论等等。作为一个管理者，要清楚地知道信仰是一个敏感的问题，对这些领域要使用“建议”或者“指导原则”（避免僵硬的“规则”或“标准”），并让程序员们制定他们自己的标准。当然，如果有人因可读性差等影响整个项目的实践行为，为了提高代码质量，不要怕引发一些摩擦。&lt;/p&gt;
&lt;p&gt;最后，要了解物理环境对程序员生产率有着巨大的影响。这些环境包括桌子、椅子、电脑、书籍、键盘，以及办公氛围、不经常被打扰的环境等等。如果你的工作环境属于最差的那25%，那么你有机会给生产率带来100%的提升，办法是把环境改善为最佳的那25%。&lt;/p&gt;
&lt;h2 id=&quot;2-5-管理你的管理者&quot;&gt;&lt;a href=&quot;#2-5-管理你的管理者&quot; class=&quot;headerlink&quot; title=&quot;2.5 管理你的管理者&quot;&gt;&lt;/a&gt;2.5 管理你的管理者&lt;/h2&gt;&lt;p&gt;在软件开发中，如果你需要面对非技术出身的管理者，你可能要肩负起“管理你的管理者”的责任。其要点在于，你要表现得使你的管理者认为他仍然在管理你。有这么一些应对管理者的方法：把你希望做什么的念头先藏起来，等着你的管理者组织一场有关你希望什么的头脑风暴/集体讨论；把做事情的正确方法传授给你的管理者；关注你的管理者的兴趣，按照他的真正意图去做；拒绝按照你的管理者所说的去做，坚持用正确的方法做自己的事；换工作。&lt;/p&gt;
&lt;p&gt;参考文献：电子工业出版社《代码大全（第2版）》第27、28章&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;软件开发的规模扩大并不是像“拿一个小项目来，然后增大它的每一部分”那样简单。如果要开发大型软件，就必须了解软件规模对构建的影响。此外，本文将记录与构建直接相关的一些特定管理问题。如果你是一名开发人员，本文将帮助你了解管理者需要考虑的一些问题；如果你是一名管理者，本文将帮助你了解开发人员是如何看待管理者的，以及如何才能有效地管理构建。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="综合" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/"/>
    
      <category term="软件工程" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="软件构建" scheme="http://raytaylorlin.com/tags/%E8%BD%AF%E4%BB%B6%E6%9E%84%E5%BB%BA/"/>
    
      <category term="软件工程" scheme="http://raytaylorlin.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="代码大全" scheme="http://raytaylorlin.com/tags/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/"/>
    
  </entry>
  
</feed>
