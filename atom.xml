<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ray Taylor Lin&#39;s world</title>
  <subtitle>林寿山的技术博客 Ray Taylor Lin&#39;s world</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://raytaylorlin.com/"/>
  <updated>2016-04-24T14:29:06.951Z</updated>
  <id>http://raytaylorlin.com/</id>
  
  <author>
    <name>Ray Taylor Lin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>软件构建（八）——表驱动法与一般控制问题</title>
    <link href="http://raytaylorlin.com/tech/complex/software/software-construction-8/"/>
    <id>http://raytaylorlin.com/tech/complex/software/software-construction-8/</id>
    <published>2016-04-24T14:24:03.000Z</published>
    <updated>2016-04-24T14:29:06.951Z</updated>
    
    <content type="html">&lt;p&gt;表驱动法是一种编程模式——从表里面查找信息而不使用逻辑语句（if和case）。事实上，凡是能通过逻辑语句来选择的事物，都可以通过查表来选择。本文将介绍直接访问表、索引访问表和阶梯访问表三种常见的表驱动法。最后，本文将记录一些控制问题（如布尔表达式的使用、空语句、深层嵌套问题等等）上的使用原则，这一部分内容比较简单而且与前面的章节有一些重叠，因此将快速带过。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-表驱动法&quot;&gt;&lt;a href=&quot;#1-表驱动法&quot; class=&quot;headerlink&quot; title=&quot;1. 表驱动法&quot;&gt;&lt;/a&gt;1. 表驱动法&lt;/h1&gt;&lt;p&gt;例如当使用复杂的if-elseif逻辑对字符分类时，可以用一个查询表（数组或字典）来代替查询，当然，查询表要事先创建好。&lt;/p&gt;
&lt;h2 id=&quot;1-1-直接访问表&quot;&gt;&lt;a href=&quot;#1-1-直接访问表&quot; class=&quot;headerlink&quot; title=&quot;1.1 直接访问表&quot;&gt;&lt;/a&gt;1.1 直接访问表&lt;/h2&gt;&lt;p&gt;使用直接访问法的例子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个月中的天数：建立含12个整数的数组，把月份当下标查询&lt;/li&gt;
&lt;li&gt;保险费率：费率随年龄、性别、婚姻状况等变化，可以以这几个维度建立多维数组，从外部读入数据&lt;/li&gt;
&lt;li&gt;灵活的消息格式：假定一份文件中有几百条消息，消息种类约20种，每种消息都有若干字段。可以把消息种类构造为查询表，并把每种字段对应的行为用多态实现，这样可以大幅简化对消息种类和字段进行判断&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用直接访问法查表时，关键是能直接得到查询的键值。有时像保险费率中的年龄，可能小于18岁，18-65岁，超过65岁是三种不一样的费率，这时可以使用以下这些方法将其转换为可查询的键值：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;复制信息：查询表填充18个18岁以下的费率，47个18-65岁的费率，以此类推，缺点是复制的冗余会浪费空间，而且表中存在错误的可能性也会增加&lt;/li&gt;
&lt;li&gt;转换键值：将一个区间通过某个函数转换为一个值，例如&lt;code&gt;max(min(66, age), 17)&lt;/code&gt;可以生成一个位于17到66之间的键值，这种方法要精心设计转换函数&lt;/li&gt;
&lt;li&gt;把键值转换提取成独立子程序：上面的转换键值方法其实不太适用于年龄转换这种复杂情况，编写一个&lt;code&gt;KeyFromAge()&lt;/code&gt;方法里面写几个if判断将年龄转换为键值更加清晰&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-2-索引访问表&quot;&gt;&lt;a href=&quot;#1-2-索引访问表&quot; class=&quot;headerlink&quot; title=&quot;1.2 索引访问表&quot;&gt;&lt;/a&gt;1.2 索引访问表&lt;/h2&gt;&lt;p&gt;使用索引的时候，先用一个基本类型的数据从一张索引表中查出一个键值，然后再用这一键值查出你感兴趣的主数据。下图解释了这种技术的具体原理：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7d9rl0.com1.z0.glb.clouddn.com/image/software/%E7%B4%A2%E5%BC%95%E8%AE%BF%E9%97%AE%E8%A1%A8%E7%9A%84%E5%8E%9F%E7%90%86.jpg&quot; alt=&quot;索引访问表的原理&quot;&gt;&lt;/p&gt;
&lt;p&gt;索引访问技术有几个主要优点：首先，如果主查询表中的每一条记录都很大，那么创建一个浪费了很多空间的&lt;strong&gt;索引数组&lt;/strong&gt;所用的空间，就要比创建一个浪费了很多空间的&lt;strong&gt;主查询表&lt;/strong&gt;所用的空间小得多；其次，即使用了索引以后没有节省内存空间，操作位于索引中的记录有时也要比操作位于主表中的记录更方便廉价；最后，索引访问技术在可维护性上所具有的普遍优点，编写到表里面的数据比嵌入代码中的数据更容易维护。&lt;/p&gt;
&lt;h2 id=&quot;1-3-阶梯访问表&quot;&gt;&lt;a href=&quot;#1-3-阶梯访问表&quot; class=&quot;headerlink&quot; title=&quot;1.3 阶梯访问表&quot;&gt;&lt;/a&gt;1.3 阶梯访问表&lt;/h2&gt;&lt;p&gt;阶梯结构的基本想法是，表中的记录对于不同的数据范围有效，而不是对不同的数据点有效。最常见的例子是按分数段（浮点数）评定ABCDF等级。由于是浮点数划分范围，用数据转换函数或索引都不适合。为了使用阶梯方法，要把每一区间的上限写入一张表里，然后写一个循环，按照各区间的上限来检查分数，当分数第一次超过某个区间的上限时，就知道相应的等级了。除此之外，还可以将这种方法应用在概率分布的统计（这在游戏中的抽奖相当常见），这种无规则分布的数据是不可能用一个函数把它们整齐地转换成表键值的。使用阶梯访问表需要注意一些细节：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;留心端点：充分考虑每一个阶梯区间的上界，不要把&amp;lt;误用为&amp;lt;=&lt;/li&gt;
&lt;li&gt;考虑用“准”二分查找取代顺序查找&lt;/li&gt;
&lt;li&gt;考虑用索引访问采取代阶梯技术：如果执行速度很重要，应考虑用空间换时间的索引表技术&lt;/li&gt;
&lt;li&gt;把阶梯表查询操作提取成单独的子程序&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;2-一般控制问题&quot;&gt;&lt;a href=&quot;#2-一般控制问题&quot; class=&quot;headerlink&quot; title=&quot;2. 一般控制问题&quot;&gt;&lt;/a&gt;2. 一般控制问题&lt;/h1&gt;&lt;h2 id=&quot;2-1-布尔表达式的使用&quot;&gt;&lt;a href=&quot;#2-1-布尔表达式的使用&quot; class=&quot;headerlink&quot; title=&quot;2.1 布尔表达式的使用&quot;&gt;&lt;/a&gt;2.1 布尔表达式的使用&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;用true和false做布尔判断，而不要用0和1等数值&lt;/li&gt;
&lt;li&gt;隐式地比较布尔值：即使用&lt;code&gt;while (!done)&lt;/code&gt;而不要写成&lt;code&gt;while (done == false)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;简化复杂的表达式：可以通过拆分复杂的判断并引入新的布尔变量，把复杂的表达式提取成布尔函数，用决策表代替复杂的条件等方法&lt;/li&gt;
&lt;li&gt;编写肯定形式的布尔表达式：在变量命名上尽量采用肯定形式，if语句的布尔表达式尽量&lt;strong&gt;不用not形式&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;用&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%BE%B7%E6%91%A9%E6%A0%B9%E5%AE%9A%E5%BE%8B&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;德摩根定理&lt;/a&gt;简化否定的布尔判断&lt;/li&gt;
&lt;li&gt;用括号便布尔表达式更清晰&lt;/li&gt;
&lt;li&gt;理解布尔表达式是如何求值的：主要是要充分理解所用编程语言中&lt;strong&gt;“短路求值”&lt;/strong&gt;的用法&lt;/li&gt;
&lt;li&gt;按照数轴的顺序编写数值比较表达式&lt;/li&gt;
&lt;li&gt;与0比较时应该：隐式地比较逻辑变量，显式地把数字和0相比较，显式地把指针与NULL相比较，在C语言中显示地比较字符和&lt;code&gt;\0&lt;/code&gt;终止符&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-2-空语句&quot;&gt;&lt;a href=&quot;#2-2-空语句&quot; class=&quot;headerlink&quot; title=&quot;2.2 空语句&quot;&gt;&lt;/a&gt;2.2 空语句&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;万非得以使用空语句时，要突出这种用法：空语句并不多见，应该让其独占一行，加以缩进，用成对的花括号括住空语句以表强调&lt;/li&gt;
&lt;li&gt;为主语句创建一个DoNothing()预处理宏或者内联函数&lt;/li&gt;
&lt;li&gt;考虑如果换用一个非空的循环体，是否会让代码更清晰&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-3-深层嵌套问题&quot;&gt;&lt;a href=&quot;#2-3-深层嵌套问题&quot; class=&quot;headerlink&quot; title=&quot;2.3 深层嵌套问题&quot;&gt;&lt;/a&gt;2.3 深层嵌套问题&lt;/h2&gt;&lt;p&gt;过分深层的缩进（嵌套）是产生混乱代码的罪魁祸首之一。有研究表明，应避免使用超过3到4层的嵌套。下面给出一些用于避免深层嵌套的方法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过重复检测条件中的某一部分来简化嵌套的if语句&lt;/li&gt;
&lt;li&gt;在循环中用break块来简化嵌套if&lt;/li&gt;
&lt;li&gt;把嵌套if转换成一组if-else-if语句或case语句&lt;/li&gt;
&lt;li&gt;把深层嵌套的代码抽取出来放进单独的子程序&lt;/li&gt;
&lt;li&gt;对于复杂的case语句，可以考虑面向对象的手段来简化&lt;/li&gt;
&lt;li&gt;重新设计深层嵌套的代码&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-4-控制结构与复杂度&quot;&gt;&lt;a href=&quot;#2-4-控制结构与复杂度&quot; class=&quot;headerlink&quot; title=&quot;2.4 控制结构与复杂度&quot;&gt;&lt;/a&gt;2.4 控制结构与复杂度&lt;/h2&gt;&lt;p&gt;降低软件复杂度首先要知道如何度量复杂度，其中最著名的方法是计算子程序中“决策点”的数量：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从1开始，一直往下筒骨哦程序&lt;/li&gt;
&lt;li&gt;一旦遇到&lt;code&gt;if&lt;/code&gt;、&lt;code&gt;while&lt;/code&gt;、&lt;code&gt;repeat&lt;/code&gt;、&lt;code&gt;for&lt;/code&gt;、&lt;code&gt;and&lt;/code&gt;、&lt;code&gt;or&lt;/code&gt;这些关键字或同类的词，就加1&lt;/li&gt;
&lt;li&gt;给case语句中每一种情况都加1&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过下面的评分来分析子程序的复杂度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0-5：子程序可能还不错&lt;/li&gt;
&lt;li&gt;6-10：得想办法简化子程序了&lt;/li&gt;
&lt;li&gt;10+：把子程序的某一部分拆分成另一个子程序并调用它&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;把子程序的一部分提取成另一个子程序，不会降低整个程序的复杂度，只是把决策点移到其他地方。但是这样做可以降低你在同一时间必须关注的复杂度水平。由于重点是要降低你需要在头脑中同时考虑的项目的数量，所以降低一个给定子程序的复杂度是有价值的。10个决策点的上限并不是绝对的。应该把决策点的数量当作一个警示，该警示说明某个子程序可能需要重新设计了，不要死守决策点上限这个规则。&lt;/p&gt;
&lt;p&gt;参考文献：电子工业出版社《代码大全（第2版）》第18、19章&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;表驱动法是一种编程模式——从表里面查找信息而不使用逻辑语句（if和case）。事实上，凡是能通过逻辑语句来选择的事物，都可以通过查表来选择。本文将介绍直接访问表、索引访问表和阶梯访问表三种常见的表驱动法。最后，本文将记录一些控制问题（如布尔表达式的使用、空语句、深层嵌套问题等等）上的使用原则，这一部分内容比较简单而且与前面的章节有一些重叠，因此将快速带过。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="综合" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/"/>
    
      <category term="软件工程" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="软件构建" scheme="http://raytaylorlin.com/tags/%E8%BD%AF%E4%BB%B6%E6%9E%84%E5%BB%BA/"/>
    
      <category term="软件工程" scheme="http://raytaylorlin.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>软件构建（七）——防御式编程</title>
    <link href="http://raytaylorlin.com/tech/complex/software/software-construction-7/"/>
    <id>http://raytaylorlin.com/tech/complex/software/software-construction-7/</id>
    <published>2016-04-20T09:28:57.000Z</published>
    <updated>2016-04-20T09:32:37.390Z</updated>
    
    <content type="html">&lt;p&gt;防御式编程这一概念来自防御式驾驶。在防御式驾驶中要建立这样一种思维，那就是你永远也不能确定另一位司机将要做什么。这样才能确保在其他人做出危险动作时你也不会受到伤害。你要承担起保护自己的责任，哪怕是其他司机犯的错误。本文将讲述如何面对严酷的非法数据的世界、在遇到“绝不会发生”的事件以及其他程序员犯下的错误时保护你自己。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-防御式编程&quot;&gt;&lt;a href=&quot;#1-防御式编程&quot; class=&quot;headerlink&quot; title=&quot;1. 防御式编程&quot;&gt;&lt;/a&gt;1. 防御式编程&lt;/h1&gt;&lt;p&gt;防御式编程的主要思想是：子程序应该不因传入错误数据而被破坏，哪怕是由其他子程序产生的错误数据。更一般地说，其核心想法是要承认程序都会有问题，都需要被修改。防御式编码的最佳方式就是在一开始不要在代码中引入错误。使用途代式设计、编码前先写伪代码、写代码前先写测试用例、低层设计检查等活动，都有助于防止引入错误。因此，要在防御式编程之前优先运用这些技术。&lt;/p&gt;
&lt;h2 id=&quot;1-1-保护程序免遭非法输入数据的破坏&quot;&gt;&lt;a href=&quot;#1-1-保护程序免遭非法输入数据的破坏&quot; class=&quot;headerlink&quot; title=&quot;1.1 保护程序免遭非法输入数据的破坏&quot;&gt;&lt;/a&gt;1.1 保护程序免遭非法输入数据的破坏&lt;/h2&gt;&lt;p&gt;对已形成产品的软件而言，应该做到“垃圾进，什么都不出”、“进来垃圾，出去是出错提示”或“不许垃圾进来”。通常有三种方法来处理进来垃圾的情况。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;检查所有来源于外部的数据的值：检查从文件、用户、网络或其他外部接口中获取的数据&lt;/li&gt;
&lt;li&gt;检查子程序所有输入参数的值&lt;/li&gt;
&lt;li&gt;决定如何处理错误的输入数据&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-2-使用断言（assert）&quot;&gt;&lt;a href=&quot;#1-2-使用断言（assert）&quot; class=&quot;headerlink&quot; title=&quot;1.2 使用断言（assert）&quot;&gt;&lt;/a&gt;1.2 使用断言（assert）&lt;/h2&gt;&lt;p&gt;断言可以用于在代码中说明各种假定，澄清各种不希望的情形。但通常断言只是在开发阶段用于帮助查清相互矛盾的假定、预料之外的情况以及传给子程序的错误数据等。在生成产品代码时，不要把断言编译进目标代码，以免降低性能和让用户看到断言报错信息。下面是关于使用断言的一些指导性建议。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用错误处理代码来处理预期会发生的状况，用断言来处理绝不应该发生的状况&lt;/li&gt;
&lt;li&gt;避免把需要执行的代码放到断言中：断言只检查变量的值，而不要在断言中&lt;strong&gt;运行&lt;/strong&gt;函数&lt;/li&gt;
&lt;li&gt;用断言来注解并验证前条件和后条件：所谓前条件是子程序或类的调用方代码在调用子程序或实例化对象之前要确保为真的属性，后条件是子程序或类在执行结束后要确保为真的属性&lt;/li&gt;
&lt;li&gt;对于高健壮性的代码，应该先使用断言再处理错误&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-3-错误处理技术&quot;&gt;&lt;a href=&quot;#1-3-错误处理技术&quot; class=&quot;headerlink&quot; title=&quot;1.3 错误处理技术&quot;&gt;&lt;/a&gt;1.3 错误处理技术&lt;/h2&gt;&lt;p&gt;有很多种解决方案用于处理那些预料中可能要发生的错误，下面列举一些可用的方案，实际中还经常把这些技术集合起来使用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;返回中立值：遇到错误时继续执行操作并简单地返回一个没有危害的数值。但对于关键领域（如医疗、航天），关闭程序也比显示错误的数据要好&lt;/li&gt;
&lt;li&gt;换用下一个正确的数据：如读数据库时发现一条损坏的记录，则继续读下去直到找到一条正确记录为止&lt;/li&gt;
&lt;li&gt;返回与前次相同的数据：在前后变化不会太大的场景使用，如游戏重绘使用上一帧的图像&lt;/li&gt;
&lt;li&gt;换用最接近的合法值：如小于0的值用0代替&lt;/li&gt;
&lt;li&gt;把警告信息记录到日志文件中&lt;/li&gt;
&lt;li&gt;返回一个错误码：简单地报告有错误发生，并信任调用链上游的某个子程序会处理该错误&lt;/li&gt;
&lt;li&gt;调用全局的错误处理子程序或对象&lt;/li&gt;
&lt;li&gt;当错误发生时显示出错消息以提高用户体验：采用这种做法时要考虑模块划分，多语言化，还要小心不要告诉系统的潜在攻击者太多东西&lt;/li&gt;
&lt;li&gt;用最妥当的方式在局部处理错误&lt;/li&gt;
&lt;li&gt;关闭程序：适用于人身安全攸关的应用程序&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-4-异常&quot;&gt;&lt;a href=&quot;#1-4-异常&quot; class=&quot;headerlink&quot; title=&quot;1.4 异常&quot;&gt;&lt;/a&gt;1.4 异常&lt;/h2&gt;&lt;p&gt;异常是把代码中的错误或异常事件传递给调用方代码的一种特殊手段。如果在一个子程序中遇到了预料之外的情况，但不知道该如何处理的话，它就可以抛出一个异常，就好比是举起双手说“我不知道该怎么处理它一一我真希望有谁知道该怎么办！” 一样。对出错的前因后果不甚了解的代码，可以把对控制权转交给系统中其他能更好地解释错误并采取措施的部分。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用异常通知程序的其他部分，发生了不可忽略的错误&lt;/li&gt;
&lt;li&gt;只在真正例外的情况下才抛出异常：仅在其他编码实践方法无法解决的情况下才使用异常&lt;/li&gt;
&lt;li&gt;不能用异常来推卸责任：如果某种的错误情况可以在局部处理，那就应该在局部处理掉它&lt;/li&gt;
&lt;li&gt;避免在构造函数和析构函数中抛出异常，除非你在同一地方把它们捕获&lt;/li&gt;
&lt;li&gt;在恰当的抽象层次抛出异常&lt;/li&gt;
&lt;li&gt;在异常消息中加入关于导致异常发生的全部信息&lt;/li&gt;
&lt;li&gt;避免使用空的catch语句：不要试图敷衍一个不知该如何处理的异常&lt;/li&gt;
&lt;li&gt;了解所所用函数库可能抛出的异常&lt;/li&gt;
&lt;li&gt;考虑创建一个集中的异常报告机制&lt;/li&gt;
&lt;li&gt;把项目中对异常的使用标准化&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-5-在架构上设置隔栏来隔离错误&quot;&gt;&lt;a href=&quot;#1-5-在架构上设置隔栏来隔离错误&quot; class=&quot;headerlink&quot; title=&quot;1.5 在架构上设置隔栏来隔离错误&quot;&gt;&lt;/a&gt;1.5 在架构上设置隔栏来隔离错误&lt;/h2&gt;&lt;p&gt;隔栏是一种容损策略，这与与船体外壳上装备隔离舱或者建筑物中的防火墙是类似的。以防御式编程为目的而进行隔离的一种方法，是把某些接口选定为“安全”区域的边界。对穿越安全区域边界的数据进行合法性校验，并当数据非法时做出敏锐的反映。可以把这种方法看做是手术室里使用的一种技术——任何东西在允许进入手术室之前都要经过消毒处理。因此手术室内的任何东西都可以认为是安全的。这其中最核心的设计决策是规定什么可以进入手术室，什么不可以进入，还有把手术室的门设在哪里。&lt;/p&gt;
&lt;h2 id=&quot;1-6-编写辅助调试的代码&quot;&gt;&lt;a href=&quot;#1-6-编写辅助调试的代码&quot; class=&quot;headerlink&quot; title=&quot;1.6 编写辅助调试的代码&quot;&gt;&lt;/a&gt;1.6 编写辅助调试的代码&lt;/h2&gt;&lt;p&gt;防御式编程的另一重要方面是使用辅助调试的代码，可以用于帮助快速地检测错误。一般人除非被某个错误反复纠缠，否则是懒得花精力去写这些辅助调试代码的，但如果越早引入辅助调试的代码，它能够提供的帮助也越大。还有一种“进攻时编程”的方式来处理异常情况：在开发阶段让错误显现出来，而在产品代码运行时能够自我修复——在开发时惨痛地失败，能让你在发布产品后不会败得太惨。&lt;/p&gt;
&lt;p&gt;如果使用了辅助调试的代码，那要做好清理的计划。例如使用类似ant或make这样的编译控制工具，或者使用内置的预处理器（如C/C++的&lt;code&gt;#define&lt;/code&gt;的，如果语言不支持预编译器就考虑用变通方法写自己的预处理器），在发布的产品代码中剔除掉调试代码。&lt;/p&gt;
&lt;p&gt;说了这么多防御式编程的手段，但是过度地防御也会引起问题，例如引入的额外代码增加了软件的复杂度，引入的代码也可能引入其他bug。因此，要考虑好什么地方你需要进行防御，然后因地制宜地调整你进行防御式编程的优先级。&lt;/p&gt;
&lt;p&gt;参考文献：电子工业出版社《代码大全（第2版）》第8章&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;防御式编程这一概念来自防御式驾驶。在防御式驾驶中要建立这样一种思维，那就是你永远也不能确定另一位司机将要做什么。这样才能确保在其他人做出危险动作时你也不会受到伤害。你要承担起保护自己的责任，哪怕是其他司机犯的错误。本文将讲述如何面对严酷的非法数据的世界、在遇到“绝不会发生”的事件以及其他程序员犯下的错误时保护你自己。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="综合" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/"/>
    
      <category term="软件工程" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="软件构建" scheme="http://raytaylorlin.com/tags/%E8%BD%AF%E4%BB%B6%E6%9E%84%E5%BB%BA/"/>
    
      <category term="软件工程" scheme="http://raytaylorlin.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>软件构建（六）——语句</title>
    <link href="http://raytaylorlin.com/tech/complex/software/software-construction-6/"/>
    <id>http://raytaylorlin.com/tech/complex/software/software-construction-6/</id>
    <published>2016-04-16T13:54:28.000Z</published>
    <updated>2016-04-17T15:23:13.185Z</updated>
    
    <content type="html">&lt;p&gt;本文开始从以数据为中心的编程观点转到以语句为中心的观点上。常用的编程语句有顺序、控制和循环三种基本结构，本文将依次介绍这三种基本结构的使用原则。最后，还总结了一些不太常见的控制结构，如子程序多处返回、递归、关于goto语句的讨论。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-顺序语句&quot;&gt;&lt;a href=&quot;#1-顺序语句&quot; class=&quot;headerlink&quot; title=&quot;1. 顺序语句&quot;&gt;&lt;/a&gt;1. 顺序语句&lt;/h1&gt;&lt;p&gt;下面分别举了一个有前后明确的运行顺序的没有明显顺序的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 有前后依赖关系的语句
data = ReadData();
results = CalculateResultsFromData(data);
PrintResults(results);

// 不太明显的前后依赖关系的语句
revenue.ComputeMonthly();
revenue.ComputeQuarterly();
revenue.ComputeAnnual();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果语句之间存在依赖关系，并且这些关系要求你把语句按照一定的顺序加以排列，那么应设法使得这些依赖关系变得明显。下面是一些用于组织语句的简单原则。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设法组织代码，使依赖关系变得非常明显&lt;/li&gt;
&lt;li&gt;使子程序名能突显依赖关系&lt;/li&gt;
&lt;li&gt;利用子程序参数明确显示依赖关系&lt;/li&gt;
&lt;li&gt;用注释对不清晰的依赖关系进行说明：首先要尽力写没有顺序依赖关系的代码&lt;/li&gt;
&lt;li&gt;用断言或者错误处理代码来检查依赖关系&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果语句没有明显依赖关系，那也应该按一定原则来排列语句，使得其可读性更好，其中的指导原则就是就近原则：把相关的操作放在一起。&lt;strong&gt;要让程序易于自上而下阅读，而不是让读者的目光跳来跳去。&lt;/strong&gt; 此外，还要把相关的语句组织在一起，一种检验的方法是，打印出要检验的程序代码（可以输出图片），然后把相关的语句画上框，如果方框彼此&lt;strong&gt;不交叠&lt;/strong&gt;则相关语句组织得好。&lt;/p&gt;
&lt;h1 id=&quot;2-条件语句&quot;&gt;&lt;a href=&quot;#2-条件语句&quot; class=&quot;headerlink&quot; title=&quot;2. 条件语句&quot;&gt;&lt;/a&gt;2. 条件语句&lt;/h1&gt;&lt;h2 id=&quot;2-1-if-else语句&quot;&gt;&lt;a href=&quot;#2-1-if-else语句&quot; class=&quot;headerlink&quot; title=&quot;2.1 if-else语句&quot;&gt;&lt;/a&gt;2.1 if-else语句&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;首先写正常代码路径，再处理不常见情况&lt;/li&gt;
&lt;li&gt;确保对于等量的分支是正确的：仔细考虑“&amp;gt;”“&amp;lt;”和“&amp;gt;=”“&amp;lt;=”的逻辑&lt;/li&gt;
&lt;li&gt;把正常情况的处理放在if后面而不要放在else后面&lt;/li&gt;
&lt;li&gt;不要在if分支执行空语句&lt;/li&gt;
&lt;li&gt;考虑else分支：考虑是否真的仅仅只需要一个if分支就可满足，除非原因显而易见，否则也应考虑用注释来解释空else分支是没有必要的&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-2-switch-case语句&quot;&gt;&lt;a href=&quot;#2-2-switch-case语句&quot; class=&quot;headerlink&quot; title=&quot;2.2 switch-case语句&quot;&gt;&lt;/a&gt;2.2 switch-case语句&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;为case选择最有效的排列方式：按字母数字顺序，或者把正常的情况撞在前面，或者按执行频率高低&lt;/li&gt;
&lt;li&gt;简化每种情况对应的操作：不要在case中堆一堆操作&lt;/li&gt;
&lt;li&gt;不要为了使用case语句而刻意制造一个变量&lt;/li&gt;
&lt;li&gt;把default子句用于检查真正的默认情况或检查错误&lt;/li&gt;
&lt;li&gt;在case末尾明确无误地标明需要穿越执行的程序流程&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;3-循环语句&quot;&gt;&lt;a href=&quot;#3-循环语句&quot; class=&quot;headerlink&quot; title=&quot;3. 循环语句&quot;&gt;&lt;/a&gt;3. 循环语句&lt;/h1&gt;&lt;h2 id=&quot;3-1-循环的种类&quot;&gt;&lt;a href=&quot;#3-1-循环的种类&quot; class=&quot;headerlink&quot; title=&quot;3.1 循环的种类&quot;&gt;&lt;/a&gt;3.1 循环的种类&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;计数循环：执行次数一定，如for循环。&lt;strong&gt;不要在for循环中去修改下标值或中途退出。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;连续求值的循环：预先不知道循环次数，如while循环&lt;/li&gt;
&lt;li&gt;无限循环：一旦启动就一直执行，除非在循环中间退出，如while循环带break中断&lt;/li&gt;
&lt;li&gt;迭代器循环：容器类的常见操作，如foreach循环&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;3-2-循环的原则&quot;&gt;&lt;a href=&quot;#3-2-循环的原则&quot; class=&quot;headerlink&quot; title=&quot;3.2 循环的原则&quot;&gt;&lt;/a&gt;3.2 循环的原则&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;进入循环&lt;ul&gt;
&lt;li&gt;只从一个位置进入循环&lt;/li&gt;
&lt;li&gt;把初始化代码紧放在循环前面&lt;/li&gt;
&lt;li&gt;用&lt;code&gt;while(true)&lt;/code&gt;表示无限循环&lt;/li&gt;
&lt;li&gt;在适当的情况下多使用for循环；但如果while循环更适用的话，不要使用for循环：因为while循环需要在循环之前初始化条件，循环最后变更条件，容易出错和可读性较差&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;处理循环体&lt;ul&gt;
&lt;li&gt;避免空循环&lt;/li&gt;
&lt;li&gt;循环内务操作（循环变量的变更）要么放在循环的开始，要么放在循环的末尾&lt;/li&gt;
&lt;li&gt;一个循环只做一件事：应该把循环体当做黑盒或子程序看待，读者只需要关心其循环条件是什么，而不需关心其内容&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;退出循环&lt;ul&gt;
&lt;li&gt;设法确认循环能够终止：要考虑正常的情况、端点，及每一种异常情况&lt;/li&gt;
&lt;li&gt;使循环终止条件看起来很明显&lt;/li&gt;
&lt;li&gt;不要为了终止循环而胡乱改动for循环的下标&lt;/li&gt;
&lt;li&gt;避免出现依赖于循环下标&lt;strong&gt;最终取值&lt;/strong&gt;的代码：更具自我描述性的做法是，在循环体内某个适当的地方把这一最终取值赋给某个变量&lt;/li&gt;
&lt;li&gt;考虑使用安全计数器：安全计数器是一个特殊变量，在每次循环之后都递增它，以便判断该循环的执行次数是不是过多&lt;/li&gt;
&lt;li&gt;考虑在while循环中使用break语句而不用布尔标记&lt;/li&gt;
&lt;li&gt;小心那些有很多break散布在循环各处&lt;/li&gt;
&lt;li&gt;在循环开始处用continue进行判断：可以避免用一个让整个循环体的缩进的if块&lt;/li&gt;
&lt;li&gt;除非你已经考虑过各种替换方案，否则不要使用break：使用break消除了把循环看做黑盒子的可能性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;检查端点：既要在脑海中模拟，也要手工检查一遍&lt;/li&gt;
&lt;li&gt;循环变量&lt;ul&gt;
&lt;li&gt;用整数或者枚举类型表示数组和循环的边界&lt;/li&gt;
&lt;li&gt;在嵌套循环中使用有意义的变量名来提高其可读性：避免i、j、k及下标串话误用&lt;/li&gt;
&lt;li&gt;把循环下标变量的作用域限制在本循环内&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;循环的长度&lt;ul&gt;
&lt;li&gt;循环要尽可能地短，以便能够一目了然：建议限制在一屏之内&lt;/li&gt;
&lt;li&gt;把嵌套限制在3层以内&lt;/li&gt;
&lt;li&gt;把长循环的内容移到子程序里&lt;/li&gt;
&lt;li&gt;要让长循环格外清晰&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;4-不太常见的控制结构&quot;&gt;&lt;a href=&quot;#4-不太常见的控制结构&quot; class=&quot;headerlink&quot; title=&quot;4. 不太常见的控制结构&quot;&gt;&lt;/a&gt;4. 不太常见的控制结构&lt;/h1&gt;&lt;h2 id=&quot;4-1-子程序多处返回&quot;&gt;&lt;a href=&quot;#4-1-子程序多处返回&quot; class=&quot;headerlink&quot; title=&quot;4.1 子程序多处返回&quot;&gt;&lt;/a&gt;4.1 子程序多处返回&lt;/h2&gt;&lt;p&gt;子程序的多处返回是指一个子程序中有多处地方出现return。通常来说，应该用防卫子句（早返回或早退出）来简化复杂的错误处理，不要使用过多的缩进嵌套，并且减少每个子程序中return的数量。下面的例子很好地体现了这些原则。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (!file.validName()) {
    errorStatus = FileError.InvalidFileName;
    return;
}
if (!file.Open()) {
    errorStatus = FileError.CantOpenFile;
    return;
}
if (!encryptionKey.valid()) {
    errorStatus = FileError.InvalidEncryptionKey;
    return;
}
// 此处为处理正常情况的代码
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;4-2-递归&quot;&gt;&lt;a href=&quot;#4-2-递归&quot; class=&quot;headerlink&quot; title=&quot;4.2 递归&quot;&gt;&lt;/a&gt;4.2 递归&lt;/h2&gt;&lt;p&gt;递归并不常用，但如果使用得谨慎，一些小范围内的问题还是可以得到非常优雅的解。对于大多数问题，它所带来的解将会是极其复杂的——在那些情况下，使用简单的迭代通常会比较容易理解。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;确认递归能够停止&lt;/li&gt;
&lt;li&gt;使用安全计数器防止出现无穷递归：安全计数器必须是一个不随每次子程序调用而重新创建的变量&lt;/li&gt;
&lt;li&gt;把递归限制在一个子程序内：循环边归（A调用B, B调用C, C调用A）非常危险&lt;/li&gt;
&lt;li&gt;留心栈空间：给安全计数器设置上限时考虑给递归子程序分配多少栈空间，并观察递归函数中局部变量的分配情况&lt;/li&gt;
&lt;li&gt;不要用递归去计算阶乘或者斐波纳契数列：最重要的，在用递归之前你应该考虑它的替换方案&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;4-3-关于goto语句&quot;&gt;&lt;a href=&quot;#4-3-关于goto语句&quot; class=&quot;headerlink&quot; title=&quot;4.3 关于goto语句&quot;&gt;&lt;/a&gt;4.3 关于goto语句&lt;/h2&gt;&lt;p&gt;入们反对使用goto的普遍理由是：含有goto的代码很难安排好格式；使用goto也会破坏编译器的优化特性。关于goto的讨论非常多，而且其现代版本仍在以各种各样的形式出现。用不用goto是一个&lt;strong&gt;信仰问题&lt;/strong&gt;。《代码大全》作者的信条是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在现代语言里，你可以很容易地把九成的goto替换成与之等价的顺序结构。对于这些简单的情况，你应该把goto替换掉并把这当成习惯。对于复杂的情况，你仍有九成不用goto的可能：你可以把代码拆分成小的子程序，使用try-finally，使用嵌套if，检测并重新检测某个状态变量，或者重新设置条件结构。对于这些情况，想消除goto相对来说比较难，但这是一种很好的智力训练……&lt;br&gt;对于剩下的那1%的情况，即当使用goto是解决问题的合理办法的时候，请在使用的同时予以详细的说明。如果你穿着雨鞋，那么就没有必要绕开泥潭走路了。不过也要虚心参考别的程序员提出的不用goto的方法。也许他们发现了一些被你忽视的东西。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;在那些不直接支持结构化控制语句的语言里，用goto去模拟那些控制结构。在做这些的时候，应该准确地模拟，不要滥用goto所带来的灵活性&lt;/li&gt;
&lt;li&gt;如果语言内置了等价的控制结构，那么就不要用goto&lt;/li&gt;
&lt;li&gt;如果是为提高代码效率而使用goto，请衡量此举实际带来的性能提升&lt;/li&gt;
&lt;li&gt;除非你要模拟结构化语句，否则尽量在每个子程序内只使用一个goto标号&lt;/li&gt;
&lt;li&gt;除非你要模拟结构化语句，否则尽量让goto向前跳转而不要向后跳转&lt;/li&gt;
&lt;li&gt;确认所布的goto标号都被用到了。没用到的goto标号表明缺少了代码，即缺少了跳向该标号的代码。如果某些标号没有用，那么就删掉它们&lt;/li&gt;
&lt;li&gt;确认goto不会产生某些执行不到的代码&lt;/li&gt;
&lt;li&gt;如果你是一位经理，那么就应该持这样的观点：对某一个goto用法所展开的争论并不是事关全局的。如果程序员知道存在替换方案，并且也愿意为使用goto辩解，那么用goto也无妨&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考文献：电子工业出版社《代码大全（第2版）》第14-17章&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;本文开始从以数据为中心的编程观点转到以语句为中心的观点上。常用的编程语句有顺序、控制和循环三种基本结构，本文将依次介绍这三种基本结构的使用原则。最后，还总结了一些不太常见的控制结构，如子程序多处返回、递归、关于goto语句的讨论。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="综合" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/"/>
    
      <category term="软件工程" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="软件构建" scheme="http://raytaylorlin.com/tags/%E8%BD%AF%E4%BB%B6%E6%9E%84%E5%BB%BA/"/>
    
      <category term="软件工程" scheme="http://raytaylorlin.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>软件构建（五）——各种数据类型的使用原则</title>
    <link href="http://raytaylorlin.com/tech/complex/software/software-construction-5/"/>
    <id>http://raytaylorlin.com/tech/complex/software/software-construction-5/</id>
    <published>2016-04-11T06:58:29.000Z</published>
    <updated>2016-04-13T07:50:44.236Z</updated>
    
    <content type="html">&lt;p&gt;几乎所有的常见编程语言，都包含了整数、浮点数、字符串、布尔等等数据类型，而通过基本的数据类型又可以复合出各种数据结构。本文总结了常用的数据类型（整数、浮点数、字符、字符串、布尔、枚举、数组等等）以及一些不常见的数据类型（结构体、指针等等）的使用原则。最后总结了关于全局数据的一些风险和使用原则。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-常用的数据类型使用原则&quot;&gt;&lt;a href=&quot;#1-常用的数据类型使用原则&quot; class=&quot;headerlink&quot; title=&quot;1. 常用的数据类型使用原则&quot;&gt;&lt;/a&gt;1. 常用的数据类型使用原则&lt;/h1&gt;&lt;h2 id=&quot;1-1-使用数值的原则&quot;&gt;&lt;a href=&quot;#1-1-使用数值的原则&quot; class=&quot;headerlink&quot; title=&quot;1.1 使用数值的原则&quot;&gt;&lt;/a&gt;1.1 使用数值的原则&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;普遍原则&lt;ul&gt;
&lt;li&gt;避免使用“神秘数值”，即硬编码数字：这是为了使修改变得可靠容易，并更有可读性&lt;/li&gt;
&lt;li&gt;如果需要，可以使用硬编码的0和1：通常用于增减量或循环的第一个元素&lt;/li&gt;
&lt;li&gt;预防除零错误&lt;/li&gt;
&lt;li&gt;使类型转换变得明显：不要依赖隐式类型转换&lt;/li&gt;
&lt;li&gt;避免混合类型的比较：同样不要依赖隐式类型转换，确保比较的两个数是同种类型的&lt;/li&gt;
&lt;li&gt;注意编译器的警告&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;整数&lt;ul&gt;
&lt;li&gt;检查整数除法：小心&lt;strong&gt;整数除&lt;/strong&gt;和现实除法的差异&lt;/li&gt;
&lt;li&gt;检查整数溢出和中间结果溢出&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;浮点数&lt;ul&gt;
&lt;li&gt;避免数量级相差巨大的数之间的加减运算：由于精度问题，对于32位浮点数，小心1000000.00 + 0.1得到的结果和期望不同。如果要把一系列差异巨大的数相加，解决方法是先排序，再从最小值开始加起，这样可以把影响减少到最低限度&lt;/li&gt;
&lt;li&gt;避免直接进行等量比较：应自己编写equals函数判断两者之差是否小于某阈值&lt;/li&gt;
&lt;li&gt;处理舍入误差问题：考虑换用更高精度的类型，或者把浮点数放大n倍用整型类型做计算&lt;/li&gt;
&lt;li&gt;使用语言和函数库对特定数据类型的支持&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-2-字符和字符串&quot;&gt;&lt;a href=&quot;#1-2-字符和字符串&quot; class=&quot;headerlink&quot; title=&quot;1.2 字符和字符串&quot;&gt;&lt;/a&gt;1.2 字符和字符串&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;避免使用神秘字符和字符串：除了数值所提到的理由之外，还有这些理由：分离字符串到字符串资源文件更容易实现i18n，字符串字面量会占用较多的存储空间&lt;/li&gt;
&lt;li&gt;了解你的语言和开发环境是如何支持Unicode的&lt;/li&gt;
&lt;li&gt;在程序生命期中尽早决定国际化/本地化策略&lt;/li&gt;
&lt;li&gt;如果你知道只需要支持一种文字的语言，考虑使用ISO8859字符集，否则使用Unicode&lt;/li&gt;
&lt;li&gt;采用某种一致的字符串类型转换策略&lt;/li&gt;
&lt;li&gt;针对C语言字符串的建议：&lt;ul&gt;
&lt;li&gt;注意字符串指针和字符数组之间的差异：警惕任何包含字符串和等号的表达式；通过命名规则区分变量是字符数组还是字符串指针&lt;/li&gt;
&lt;li&gt;把C-style字符串的长度声明为&lt;code&gt;STRING_LENGTH + 1&lt;/code&gt;：统一约定这条规则，有助于减少脑力消耗以及编程失误&lt;/li&gt;
&lt;li&gt;用null初始化字符串以避免没有终端的字符串&lt;/li&gt;
&lt;li&gt;如果内存不是限制性的因素，就用字符数组取代C中的指针&lt;/li&gt;
&lt;li&gt;用strncpy()取代strcpy()以避免无终端的字符串&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-3-布尔变量&quot;&gt;&lt;a href=&quot;#1-3-布尔变量&quot; class=&quot;headerlink&quot; title=&quot;1.3 布尔变量&quot;&gt;&lt;/a&gt;1.3 布尔变量&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;用布尔变量对程序加以文档说明，并用来简化复杂的判断。&lt;/strong&gt;通过下面的例子来了解布尔变量的正确用法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 目的不明确的布尔判断，咋一看根本不知道要判断什么
if ( (elementindex &amp;lt; 0 ) || (MAX_ELEMENTS &amp;lt; elementIndex) || (elementIndex == lastElementIndex) ) { ... }

// 目的明确的布尔判断
bool finished = (elementindex &amp;lt; 0 ) || (MAX_ELEMENTS &amp;lt; elementIndex);
bool repeatedEntry = (elementIndex == lastElementIndex);
if (finished || repeatedEntry) { ... }
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;1-4-枚举类型&quot;&gt;&lt;a href=&quot;#1-4-枚举类型&quot; class=&quot;headerlink&quot; title=&quot;1.4 枚举类型&quot;&gt;&lt;/a&gt;1.4 枚举类型&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;用枚举类型来提高可读性和可靠性：如果仅使用具名常量，编译器无法知道是否使用了非法的数值&lt;/li&gt;
&lt;li&gt;将枚举类型作为布尔变量的替换方案：有时布尔变量无法充分表达它所需要表达的含义（比如出错信息），那么用枚举&lt;/li&gt;
&lt;li&gt;定义出枚举的第一项和最后一项，以使用于循环边界，把枚举类型的第一个元素留做非法值：如&lt;code&gt;enum Country {InvalidFirst = 0, First = 1, China = 1, England = 2, Usa = 3, Last = 4}&lt;/code&gt;，但是这样做也可能造成混乱，一定要&lt;strong&gt;明确定义项目代码编写标准，并在使用时保持一致，否则就不要用&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;警惕给枚举元素明确赋值而带来的失误：当定义0，1，2，4，8这样的枚举值时，不要去遍历&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-5-数组&quot;&gt;&lt;a href=&quot;#1-5-数组&quot; class=&quot;headerlink&quot; title=&quot;1.5 数组&quot;&gt;&lt;/a&gt;1.5 数组&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;确认所有的数组下标都没有超出数组的边界&lt;/li&gt;
&lt;li&gt;考虑用合适的容器（栈、队列、集合、列表等等）来取代数组&lt;/li&gt;
&lt;li&gt;检查数组的边界点&lt;/li&gt;
&lt;li&gt;如果数组是多维的，确认下标的&lt;strong&gt;使用顺序&lt;/strong&gt;是正确的：如很容易把&lt;code&gt;array[i][j]&lt;/code&gt;搞混成&lt;code&gt;array[j][i]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;提防下标串话：如把&lt;code&gt;array[i]&lt;/code&gt;写成&lt;code&gt;array[j]&lt;/code&gt;，和上一条一样，如果使用比i和j更有意义的下标名，这种错误就很难发生&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;2-不常见的数据类型&quot;&gt;&lt;a href=&quot;#2-不常见的数据类型&quot; class=&quot;headerlink&quot; title=&quot;2. 不常见的数据类型&quot;&gt;&lt;/a&gt;2. 不常见的数据类型&lt;/h1&gt;&lt;h2 id=&quot;2-1-结构体&quot;&gt;&lt;a href=&quot;#2-1-结构体&quot; class=&quot;headerlink&quot; title=&quot;2.1 结构体&quot;&gt;&lt;/a&gt;2.1 结构体&lt;/h2&gt;&lt;p&gt;在Java和C++里面，类有时表现得也像结构体一样（当类完全由公用的数据成员组成，而不包含公用子程序的时候）。通常情况下，你会希望创建类而非结构体，下面列出了一些使用结构体的理由：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用结构体来明确数据关系&lt;/li&gt;
&lt;li&gt;用结构体简化对数据块的操作&lt;/li&gt;
&lt;li&gt;用结构体来简化参数列表&lt;/li&gt;
&lt;li&gt;用结构体来减少维护&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-2-指针&quot;&gt;&lt;a href=&quot;#2-2-指针&quot; class=&quot;headerlink&quot; title=&quot;2.2 指针&quot;&gt;&lt;/a&gt;2.2 指针&lt;/h2&gt;&lt;p&gt;指针的使用是现代编程中最容易出错的领域之一，即便你的语言不要求你使用指针，很好地理解指针也会有助于你理解你的编程语言是如何工作的。从概念上看，每一个指针都包含两个部分：内存中的某处位置（实质是一个整数值，常用16进制表示），以及如何解释指针所指的内容（由指针的基类型决定）。&lt;/p&gt;
&lt;p&gt;通常，指针错误都产生于指针指向了它不应该指向的位置。因此，更正指针错误的大部分工作量便是找出它的位置。正确地使用指针要求程序员采用一种双向策略，首先要避免造成指针错误，其次在编写代码之后尽快地检测出指针错误来。下面说明如何实现这些目标。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;把指针操作限制在子程序或者类里面&lt;/li&gt;
&lt;li&gt;同时声明和定义指针&lt;/li&gt;
&lt;li&gt;在与指针分配相同的作用域中删除指针&lt;/li&gt;
&lt;li&gt;在使用指针之前确保指针所指向的内存位置是合理的&lt;/li&gt;
&lt;li&gt;先检查指针所引用的变量内容再使用它&lt;/li&gt;
&lt;li&gt;用标记字段来检测损毁的内存：分配内存时多分配4个字节，将前4个字节设为标记字段，返回这4个字节后的内存的指针，到了需要删除该指针的时候，检查这个标记，如果标记的值是正确的，就把它设为NULL，最后删除该指针&lt;/li&gt;
&lt;li&gt;增加明显的冗余：将某些特定字段重复两次，以此替代标记字段的方案，但是这样会带来很高的成本&lt;/li&gt;
&lt;li&gt;用额外的指针变量来提高代码清晰度：如不要写绕口的诸如&lt;code&gt;pointer-&amp;gt;next-&amp;gt;last-&amp;gt;next&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;画一个图理清指针之间的结构关系&lt;/li&gt;
&lt;li&gt;按照正确的顺序删除链表中的指针&lt;/li&gt;
&lt;li&gt;分配一片保留的内存后备区域：如果使用动态内存，最好预先分配一片内存后备，防止程序忽然用尽内存&lt;/li&gt;
&lt;li&gt;在删除或者释放指针之后把它们设为空值&lt;/li&gt;
&lt;li&gt;在删除变量之前检查非法指针&lt;/li&gt;
&lt;li&gt;跟踪指针分配情况：维护一份你已经分配的指针的列表&lt;/li&gt;
&lt;li&gt;编写覆盖子程序，集中实现避免指针问题的策略：如编写&lt;code&gt;SAFE_NEW&lt;/code&gt;和&lt;code&gt;SAFE_DELETE&lt;/code&gt;宏来统一包装指针的操作&lt;/li&gt;
&lt;li&gt;采用非指针的技术&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;还有一些特定的针对C++和C语言的指针使用技巧，此处不赘述。&lt;/p&gt;
&lt;h1 id=&quot;3-全局数据&quot;&gt;&lt;a href=&quot;#3-全局数据&quot; class=&quot;headerlink&quot; title=&quot;3. 全局数据&quot;&gt;&lt;/a&gt;3. 全局数据&lt;/h1&gt;&lt;p&gt;全局数据可以在程序中任意一个位置访问，这一概念有时被延伸到作用域比局部变量更广的变量，例如可以在一个包或一个命名空间内任意位置访问。一般来说，使用全局数据的风险比使用局部数据大，只有在万不得已时才使用，如果要用也应该遵循一些使用原则来降低风险。&lt;/p&gt;
&lt;h2 id=&quot;3-1-使用全局数据的风险&quot;&gt;&lt;a href=&quot;#3-1-使用全局数据的风险&quot; class=&quot;headerlink&quot; title=&quot;3.1 使用全局数据的风险&quot;&gt;&lt;/a&gt;3.1 使用全局数据的风险&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;无意间修改了全局数据&lt;/li&gt;
&lt;li&gt;与全局数据有关的别名问题：当一个全局变量被传递给一个子程序，然后该子程序将它既用作全局变量又用作参数使用的情况下会出现这种问题&lt;/li&gt;
&lt;li&gt;多线程下风险很大&lt;/li&gt;
&lt;li&gt;全局数据阻碍代码重用&lt;/li&gt;
&lt;li&gt;与全局数据有关的非确定的初始化顺序事直&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;全局数据破坏了模块化和智力上的可管理性&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;3-2-全局数据的使用原则&quot;&gt;&lt;a href=&quot;#3-2-全局数据的使用原则&quot; class=&quot;headerlink&quot; title=&quot;3.2 全局数据的使用原则&quot;&gt;&lt;/a&gt;3.2 全局数据的使用原则&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;创建一种命名规则来突出全局变量：例如使用g_前缀&lt;/li&gt;
&lt;li&gt;为全部的全局变量创建一份注释良好的清单&lt;/li&gt;
&lt;li&gt;不要用全局变量来存放中间结果&lt;/li&gt;
&lt;li&gt;不要把所有的数据都放在一个大对象中并到处传递，以说明你没有使用全局变量：这纯粹是一种负担，如果要用全局数据，就大胆公开地用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考文献：电子工业出版社《代码大全（第2版）》第12、13章&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;几乎所有的常见编程语言，都包含了整数、浮点数、字符串、布尔等等数据类型，而通过基本的数据类型又可以复合出各种数据结构。本文总结了常用的数据类型（整数、浮点数、字符、字符串、布尔、枚举、数组等等）以及一些不常见的数据类型（结构体、指针等等）的使用原则。最后总结了关于全局数据的一些风险和使用原则。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="综合" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/"/>
    
      <category term="软件工程" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="软件构建" scheme="http://raytaylorlin.com/tags/%E8%BD%AF%E4%BB%B6%E6%9E%84%E5%BB%BA/"/>
    
      <category term="软件工程" scheme="http://raytaylorlin.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>软件构建（四）——变量的使用原则</title>
    <link href="http://raytaylorlin.com/tech/complex/software/software-construction-4/"/>
    <id>http://raytaylorlin.com/tech/complex/software/software-construction-4/</id>
    <published>2016-04-08T06:11:59.000Z</published>
    <updated>2016-04-08T01:59:30.832Z</updated>
    
    <content type="html">&lt;p&gt;变量的好与坏就在很大程度上取决于它的命名的好坏，在给变量命名的时候需要小心谨慎。本文首先详细讲述构建活动中的基本组成成分，即变量的使用原则，接着再讲述适用于为变量——对象和基本数据——命名的原则。这些原则也适用于类、包、文件及其他的编程实体。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-使用变量的原则&quot;&gt;&lt;a href=&quot;#1-使用变量的原则&quot; class=&quot;headerlink&quot; title=&quot;1. 使用变量的原则&quot;&gt;&lt;/a&gt;1. 使用变量的原则&lt;/h1&gt;&lt;h2 id=&quot;1-1-变量初始化原则&quot;&gt;&lt;a href=&quot;#1-1-变量初始化原则&quot; class=&quot;headerlink&quot; title=&quot;1.1 变量初始化原则&quot;&gt;&lt;/a&gt;1.1 变量初始化原则&lt;/h2&gt;&lt;p&gt;不恰当的变量初始化所导致的一系列问题都源于变量的默认初始值与你的预期不同，下面给出一些避免产生初始化错误的建议。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在声明变量的时候初始化&lt;/li&gt;
&lt;li&gt;在靠近变量第一次使用的位置初始化它&lt;/li&gt;
&lt;li&gt;理想情况下， 在靠近第一次使用变量的位置声明和定义该变量&lt;/li&gt;
&lt;li&gt;在可能的情况下使用final或者const关键字&lt;/li&gt;
&lt;li&gt;注意计数器和累加器，在下次使用前要重置&lt;/li&gt;
&lt;li&gt;在类的构造函数里初始化该类的数据成员&lt;/li&gt;
&lt;li&gt;利用编译器的警告信息检查是否使用了未经初始化的变量&lt;/li&gt;
&lt;li&gt;在程序开始时初始化工作内&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-2-变量的作用域&quot;&gt;&lt;a href=&quot;#1-2-变量的作用域&quot; class=&quot;headerlink&quot; title=&quot;1.2 变量的作用域&quot;&gt;&lt;/a&gt;1.2 变量的作用域&lt;/h2&gt;&lt;p&gt;关于变量引用局部化的指标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;跨度：衡量一个变量的不同引用点的靠近程度，具体数字为对变量前后引用之间的代码行数&lt;/li&gt;
&lt;li&gt;存活时间：一个变量存在期间（被引用的第一条语句至结束引用它的最后一条语句）所跨越的语句总数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;尽可能缩短变量的跨度和存活时间，可以减少初始化错误的可能，让自己对的代码有更准确的认识，使代码更具可读性。像全局变量的跨度和存活时间都很长，应尽量避免使用。下面是一些减小作用域的一般原则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在循环开始之前再去初始化该循环里使用的变量，而不是在该循环所属的子程序的开始处初始化这些变量&lt;/li&gt;
&lt;li&gt;直到变量即将被使用时再为其赋值&lt;/li&gt;
&lt;li&gt;把相关语句放到一起&lt;/li&gt;
&lt;li&gt;把相关语句组提取成单独的子程序&lt;/li&gt;
&lt;li&gt;开始时采用最严格的可见性，然后根据需要扩展变量的作用&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-3-变量的使用原则&quot;&gt;&lt;a href=&quot;#1-3-变量的使用原则&quot; class=&quot;headerlink&quot; title=&quot;1.3 变量的使用原则&quot;&gt;&lt;/a&gt;1.3 变量的使用原则&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;每个变量只用于单一用途：不要将临时变量如temp用于两种用途&lt;/li&gt;
&lt;li&gt;避免让变量具有隐含含义，以下做法都是&lt;strong&gt;不可取&lt;/strong&gt;的&lt;ul&gt;
&lt;li&gt;pageCount表示已打印纸张的数量，如果是-1表示有错误发生&lt;/li&gt;
&lt;li&gt;bytesWritten表示写入输出文件的字节数，如果取值为负，表示用于输出的磁盘驱动器的号码&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;确保使用了所有己声明的变量&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关于变量的绑定时间，通常来说越晚绑定会有更多的灵活性，但复杂度也会越低。看看下面演示的例子，应酌情选择变量绑定时间：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 编写代码时绑定：硬编码（使用“神秘数字”）很糟糕，一旦要修改颜色则代码其他地方很难保持一致
titleBar.color = 0xFF;

// 编译时绑定：用具名常量可以增加可读性，还能只修改一处就对所有位置生效
private static final int COLOR_BLUE = 0xFF;
private static final int TITLE_BAR_COLOR = COLOR_BLUE;
titleBar.color = TITLE_BAR_COLOR;

// 运行时绑定：程序运行期间读取，可能从配置文件读取，也可能从注册表读取，这是相对最灵活的方式
titleBar.color = ReadTitleBarColor();

// 此外还有对象实例化时绑定（如每次窗体创建时读取数据），甚至即时绑定（如每次窗体重绘时读取数据）
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;2-变量的命名规范&quot;&gt;&lt;a href=&quot;#2-变量的命名规范&quot; class=&quot;headerlink&quot; title=&quot;2. 变量的命名规范&quot;&gt;&lt;/a&gt;2. 变量的命名规范&lt;/h1&gt;&lt;h2 id=&quot;2-1-选择好变量名的注意事项&quot;&gt;&lt;a href=&quot;#2-1-选择好变量名的注意事项&quot; class=&quot;headerlink&quot; title=&quot;2.1 选择好变量名的注意事项&quot;&gt;&lt;/a&gt;2.1 选择好变量名的注意事项&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;名字要完全、准确地描述出该变量所代表的事物，&lt;strong&gt;这是最重要的命名注意事项&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;以问题为导向：好记的名字反映的通常都是问题，而不是解决方案，例如表示打印机准备状态，printerReady就比bitFlag要更准确描述问题&lt;/li&gt;
&lt;li&gt;最适当的名字长度：建议平均8-20个字符，举个例子numberOfPeopleOnTheUsOlympicTeam太长，ntm太短，numTeamMembers正好&lt;/li&gt;
&lt;li&gt;较长的名字适用于很少用到的变量，较短的名字适用于局部变量或循环变量&lt;/li&gt;
&lt;li&gt;对位于全局命名空间中的名字加以限定词：用namespace、1g_前缀等等&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;把限定词放到最后，为变量赋予主要含义的部分应位于最前面&lt;/strong&gt;：例如revenueTotal要优于totalRevenue。这条规则非常适用于项目内约束以提高一致性&lt;ul&gt;
&lt;li&gt;常用的限定词：Total、Sum、Average、Max、Min、Record、Pointer等等&lt;/li&gt;
&lt;li&gt;Num限定词是个例外，通常customerNum表示下表，而numCustomers表示员工总数。但最好的办法是避免用Num，而改用Count或Total来表示总数，用Index表示下标&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下表给出一些名字好坏的对比：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;变量用途&lt;/th&gt;
&lt;th&gt;描述清晰的好名字&lt;/th&gt;
&lt;th&gt;描述不到位的坏名字&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;支票累计额&lt;/td&gt;
&lt;td&gt;runningTotal, checkTotal&lt;/td&gt;
&lt;td&gt;written, ct, checks, CHKTTL&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;列车的运行速度&lt;/td&gt;
&lt;td&gt;trainVelocity, velocityInMph&lt;/td&gt;
&lt;td&gt;velt, v tv, train&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;当前日期&lt;/td&gt;
&lt;td&gt;currentDate, todaysDate&lt;/td&gt;
&lt;td&gt;cd, current, c, date&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;每页的行数&lt;/td&gt;
&lt;td&gt;linesPerPage&lt;/td&gt;
&lt;td&gt;lpp, lines, l, x, x1, x2&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&quot;2-2-为特定类型的数据命名&quot;&gt;&lt;a href=&quot;#2-2-为特定类型的数据命名&quot; class=&quot;headerlink&quot; title=&quot;2.2 为特定类型的数据命名&quot;&gt;&lt;/a&gt;2.2 为特定类型的数据命名&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;循环下标：i、j、k作为下标是约定俗称的。若循环较长会有多层嵌套，最好用xxxIndex的描述性名字做下标&lt;/li&gt;
&lt;li&gt;状态变量：取一个比xxxFlag更好的名字，例如reportType要比statusFlag要更清晰。也建议状态变量采用具名常量或枚举类型来表达&lt;/li&gt;
&lt;li&gt;临时变量：取一个比temp更具描述性的名字&lt;/li&gt;
&lt;li&gt;布尔变量：done表示某件事是否完成，error表示是否发生错误，found表示是否找到，success表示是否成功。布尔变量的名字要明确反映true或false。此外，要使用&lt;strong&gt;肯定&lt;/strong&gt;的名字，不要取notFound、notSuccessful之类的&lt;/li&gt;
&lt;li&gt;常量：根据常量所表示的含义取名，而不是为其数值取名&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-3-应该避免的名字&quot;&gt;&lt;a href=&quot;#2-3-应该避免的名字&quot; class=&quot;headerlink&quot; title=&quot;2.3 应该避免的名字&quot;&gt;&lt;/a&gt;2.3 应该避免的名字&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;避免使用令人误解的名字或缩写&lt;/li&gt;
&lt;li&gt;避免使用具有相似含义的名字：如input和inputValue，recordNum和numRecords等等&lt;/li&gt;
&lt;li&gt;避免使用具有不同含义却又相似名字的变量：如clientRecs和clientReps&lt;/li&gt;
&lt;li&gt;避免使用发音相近的名字：如wrap和rap&lt;/li&gt;
&lt;li&gt;避免在名字中使用数字&lt;/li&gt;
&lt;li&gt;避免在名字中拼错单词&lt;/li&gt;
&lt;li&gt;避免使用英语中常常拼错的单词&lt;/li&gt;
&lt;li&gt;不要仅靠大小写来区分变量&lt;/li&gt;
&lt;li&gt;不要使用与变量含义完全无关的名字&lt;/li&gt;
&lt;li&gt;避免在名字中包含易混淆的字符&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;3-制定命名规范&quot;&gt;&lt;a href=&quot;#3-制定命名规范&quot; class=&quot;headerlink&quot; title=&quot;3. 制定命名规范&quot;&gt;&lt;/a&gt;3. 制定命名规范&lt;/h1&gt;&lt;p&gt;命名规则在各种编程语言，乃至各个公司都是不同的，但也有一些比较通用的规范可以注意。限于篇幅本文不阐述变量的命名的规范，下面只提一下为何要制定命名规范：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当多个程序员合作开发一个项目时&lt;/li&gt;
&lt;li&gt;当你计划把一个程序转交给另一位程序员来修改和维护的时候（这几乎总是会发生）&lt;/li&gt;
&lt;li&gt;当你所在组织中的其他程序员评估你写的程序的时候&lt;/li&gt;
&lt;li&gt;当你写的程序规模太大，以致于你无法在脑海里同时了解事情的全貌，而必须分而治之的时候&lt;/li&gt;
&lt;li&gt;当你写的程序生命期足够长，长到你可能会在把它搁置几个星期或几个月之后又重新启动有关该程序的工作时&lt;/li&gt;
&lt;li&gt;当在一个项目中存在一些不常见的术语，并且你希望在编写代码阶段使用标准的术语或者缩写的时候&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不同规范所要求的正式程度也有所不同。通常，一个项目所需的规范正式程度取决于为项目组的人员数量，程序的规模，以及程序预期的生命周期。对于微小的、用完即弃的项目而言，实施严格的规则可能就没什么必要。但对于多人协作的大型项目而言，无论是在开始阶段还是贯穿整个程序的生命周期，正式规范都是成为提高可读性的必不可少的辅助手段。&lt;/p&gt;
&lt;p&gt;参考文献：电子工业出版社《代码大全（第2版）》第10、11章&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;变量的好与坏就在很大程度上取决于它的命名的好坏，在给变量命名的时候需要小心谨慎。本文首先详细讲述构建活动中的基本组成成分，即变量的使用原则，接着再讲述适用于为变量——对象和基本数据——命名的原则。这些原则也适用于类、包、文件及其他的编程实体。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="综合" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/"/>
    
      <category term="软件工程" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="软件构建" scheme="http://raytaylorlin.com/tags/%E8%BD%AF%E4%BB%B6%E6%9E%84%E5%BB%BA/"/>
    
      <category term="软件工程" scheme="http://raytaylorlin.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>软件构建（三）——高质量的类和子程序</title>
    <link href="http://raytaylorlin.com/tech/complex/software/software-construction-3/"/>
    <id>http://raytaylorlin.com/tech/complex/software/software-construction-3/</id>
    <published>2016-04-05T06:11:59.000Z</published>
    <updated>2016-04-05T08:13:52.278Z</updated>
    
    <content type="html">&lt;p&gt;在计算时代的早期，程序员基于语句思考编程问题。到了20世纪七八十年代，程序员开始基于子程序去思考编程。进入21世纪，程序员以类为基础思考编程问题。类是由一组数据和子程序构成的集合，这些数据和子程序共同拥有一组内聚的、明确定义的职责。由此可见类和子程序在现代编程中的地位。本文将就如何创建高质量的类和子程序提供一些建议。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-高质量的类&quot;&gt;&lt;a href=&quot;#1-高质量的类&quot; class=&quot;headerlink&quot; title=&quot;1. 高质量的类&quot;&gt;&lt;/a&gt;1. 高质量的类&lt;/h1&gt;&lt;h2 id=&quot;1-1-类的基础：抽象数据类型（ADT）&quot;&gt;&lt;a href=&quot;#1-1-类的基础：抽象数据类型（ADT）&quot; class=&quot;headerlink&quot; title=&quot;1.1 类的基础：抽象数据类型（ADT）&quot;&gt;&lt;/a&gt;1.1 类的基础：抽象数据类型（ADT）&lt;/h2&gt;&lt;p&gt;要想理解面向对象编程，首先要理解ADT（Abstract Data Type）。ADT是指一些数据以及对这些数据所进行的操作的集合。这些操作既向程序的其余部分描述了这些数据是怎么样的，也允许程序的其余部分改变这些数据。抽象数据类型可以让你像在现实世界中一样操作实体，而不必纠结在低层如何实现上。&lt;/p&gt;
&lt;h3 id=&quot;1-1-1-使用ADT的好处&quot;&gt;&lt;a href=&quot;#1-1-1-使用ADT的好处&quot; class=&quot;headerlink&quot; title=&quot;1.1.1 使用ADT的好处&quot;&gt;&lt;/a&gt;1.1.1 使用ADT的好处&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;可以隐藏实现细节&lt;/li&gt;
&lt;li&gt;改动不会影响到整个程序&lt;/li&gt;
&lt;li&gt;让接口能提供更多信息&lt;/li&gt;
&lt;li&gt;更容易提高性能&lt;/li&gt;
&lt;li&gt;程序更具自我说明性&lt;/li&gt;
&lt;li&gt;无须在程序内到处传递数据&lt;/li&gt;
&lt;li&gt;可以像在现实世界中那样操作实体，而不用在底层实现上操作它&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1-1-2-使用ADT的指导建议&quot;&gt;&lt;a href=&quot;#1-1-2-使用ADT的指导建议&quot; class=&quot;headerlink&quot; title=&quot;1.1.2 使用ADT的指导建议&quot;&gt;&lt;/a&gt;1.1.2 使用ADT的指导建议&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;把常见的底层数据类型创建为ADT并使用这些ADT，而不再使用底层数据类型（要尽可能选择最高的抽象层次）&lt;/li&gt;
&lt;li&gt;把像文件这样的常用对象当成ADT&lt;/li&gt;
&lt;li&gt;简单的事物也可当做ADT（如灯的“开”“关”操作可以放到单独的方法）&lt;/li&gt;
&lt;li&gt;不要让ADT依赖于其存储介质&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-2-良好的类接口&quot;&gt;&lt;a href=&quot;#1-2-良好的类接口&quot; class=&quot;headerlink&quot; title=&quot;1.2 良好的类接口&quot;&gt;&lt;/a&gt;1.2 良好的类接口&lt;/h2&gt;&lt;p&gt;上一节所讲的ADT构成了类的基础，类可以看成是抽象数据类型再加上继承和多态两个概念。创建高质量的类最重要的一步是创建一个好的接口，包括通过接口来展现良好的抽象，并确保细节被很好地封装在类中。封装是一个比抽象更强的概念：抽象通过提供一个可以让你忽略实现细节的模型来管理复杂度，而封装则强制阻止你看到细节。一般来说，抽象和封装要么两者皆有，要么两者皆无。&lt;/p&gt;
&lt;h3 id=&quot;1-2-1-良好的抽象&quot;&gt;&lt;a href=&quot;#1-2-1-良好的抽象&quot; class=&quot;headerlink&quot; title=&quot;1.2.1 良好的抽象&quot;&gt;&lt;/a&gt;1.2.1 良好的抽象&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;类的接口应该展现一致的抽象层次：每一个类应该&lt;strong&gt;只实现一个ADT&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;一定要理解类所实现的抽象是什么&lt;/li&gt;
&lt;li&gt;提供成对的服务：例如开和关，添加和删除，但一定要考虑是否真的需要，不要盲目创建相反的操作&lt;/li&gt;
&lt;li&gt;把不相关的信息转移到其他类&lt;/li&gt;
&lt;li&gt;尽可能让接口可编程，而不是表达语义：可编程的部分能被编译器检查，但语义部分是由“本接口将会被怎样使用”的假定组成（比如“ RoutineA必须在RoutineB之前被调用”或“如果dataMember未经初始化就传给RoutineA的话，将会导致RoutineA崩溃”）&lt;/li&gt;
&lt;li&gt;谨防在修改时破坏接口的抽象：在对类进行修改和扩展时要特别注意&lt;/li&gt;
&lt;li&gt;不要添加与接口抽象不一致的公用成员&lt;/li&gt;
&lt;li&gt;同时考虑抽象性和内聚性&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1-2-2-良好的封装&quot;&gt;&lt;a href=&quot;#1-2-2-良好的封装&quot; class=&quot;headerlink&quot; title=&quot;1.2.2 良好的封装&quot;&gt;&lt;/a&gt;1.2.2 良好的封装&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;尽可能地限制类和成员的可访问性&lt;/li&gt;
&lt;li&gt;不要公开暴露成员数据：使用get、set访问器来访问&lt;/li&gt;
&lt;li&gt;&lt;em&gt;避免把私用的实现细节放入类的接口中&lt;/em&gt;（特指C++）：应尽量避免在类的头文件中查看private的内容。《Efective C++》第2版第34条建议，把类的接口与类的实现隔离开，并在类的声明中包含一个指针，让该指针指向类的实现，但不能包含任何其他实现细节。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;避免使用友元类&lt;/em&gt;（特指C++）&lt;/li&gt;
&lt;li&gt;不要因为一个子程序里仅使用公用子程序，就把它归入公开接口&lt;/li&gt;
&lt;li&gt;不要对类的使用者做出任何假设，要格外警惕从语义上破坏封装：&lt;strong&gt;每当你发现自己是通过查看类的内部实现来得知该如何使用这个类的时候，你就不是在针对接口编程了，而是在透过接口针对内部实现编程了&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-3-有关设计和实现类的问题&quot;&gt;&lt;a href=&quot;#1-3-有关设计和实现类的问题&quot; class=&quot;headerlink&quot; title=&quot;1.3 有关设计和实现类的问题&quot;&gt;&lt;/a&gt;1.3 有关设计和实现类的问题&lt;/h2&gt;&lt;p&gt;通常类和类之间的关系，有“包含”和“继承”两种。继承需要更多的技巧，而且更容易出错，包含才是面向对象编程中的主力技术。以下是一些关于包含和继承技术的参考原则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;警惕包含超过约7个数据成员的类&lt;/li&gt;
&lt;li&gt;要么使用继承并进行详细说明，要么就不要用它：如果某个类并未设计为可被继承，要明确声明不可被继承&lt;/li&gt;
&lt;li&gt;遵循&lt;a href=&quot;http://baike.baidu.com/view/1688346.htm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;里氏替换原则&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;确保只继承需要继承的部分：注意父类方法的&lt;strong&gt;默认实现&lt;/strong&gt;和子类方法的&lt;strong&gt;覆盖（override）性&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;不要“覆盖”一个不可覆盖的成员函数：换种说法，即子类方法不要和父类的private方法同名&lt;/li&gt;
&lt;li&gt;把共用的接口、数据及操作放到继承树中尽可能高的位置&lt;/li&gt;
&lt;li&gt;只有一个实例的类是值得怀疑的：可以考虑用单例模式&lt;/li&gt;
&lt;li&gt;只有一个派生类的基类也值得怀疑：不要“提前设计”任何非绝对必要的继承结构&lt;/li&gt;
&lt;li&gt;派生后覆盖了某个子程序，但在其中没做任何操作，这种情况也值得怀：这表明基类的设计有错误&lt;/li&gt;
&lt;li&gt;避免让继承体系过深&lt;/li&gt;
&lt;li&gt;尽量使用多态，避免大量的类型检查：警惕频繁重复出现的switch case语句&lt;/li&gt;
&lt;li&gt;避免创建万能类/避免用动词命名的类/消除无关紧要的类&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关于类的数据和方法（包括构造函数）的参考原则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;让类中子程序的数量尽可能少&lt;/li&gt;
&lt;li&gt;禁止隐式地产生你不需要的成员函数和运算符&lt;/li&gt;
&lt;li&gt;减少类所使用的不同子程序的数量&lt;/li&gt;
&lt;li&gt;对其他类的子程序的间接调用要尽可能少&lt;/li&gt;
&lt;li&gt;如果可能，应该在所有的构造函数中初始化所有的数据成员&lt;/li&gt;
&lt;li&gt;用private构造函数来强制实现单例属性&lt;/li&gt;
&lt;li&gt;优先采用深拷贝，除非论证可行才使用浅拷贝&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://www.kancloud.cn/raytaylorlin/code-complete-checklist/135274&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;核对表：类的质量&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;2-高质量的子程序&quot;&gt;&lt;a href=&quot;#2-高质量的子程序&quot; class=&quot;headerlink&quot; title=&quot;2. 高质量的子程序&quot;&gt;&lt;/a&gt;2. 高质量的子程序&lt;/h1&gt;&lt;h2 id=&quot;2-1-创建子程序的理由&quot;&gt;&lt;a href=&quot;#2-1-创建子程序的理由&quot; class=&quot;headerlink&quot; title=&quot;2.1 创建子程序的理由&quot;&gt;&lt;/a&gt;2.1 创建子程序的理由&lt;/h2&gt;&lt;p&gt;创建子程序的理由包括但不限于：降低复杂度，引入中间的、易懂的抽象，避免代码重复，支持子类化，隐藏顺序，隐藏指针操作，提高可移植性，简化复杂的逻辑判断，改善性能。同样很多创建类的理由也是创建子程序的理由。&lt;/p&gt;
&lt;p&gt;注意一些过于简单的看上去似乎没必要写成子程序的操作，写一个只有两三行代码的子程序看起来有些大才小用，经常会成为心理障碍。但实际上小的子程序有许多优点，可以看看以下这个例子。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/* 不使用子程序：经常可以看到以下代码出现在十几处地方 */
// 从设备单位（device unit）到磅数（point）的转换计算
points = deviceUnits * （POINTS_PER_INCH / DeviceUnitsPerInch());

/* 使用子程序：不仅更具可读性（甚至达到自我注解的程度），可以更易于维护和测试 */
int DeviceUnitsToPoints(int deviceUnits) {
    if (DeviceUnitsPerInch() != 0)
        return deviceUnits * （POINTS_PER_INCH / DeviceUnitsPerInch();
    else
        return 0;
}
points = DeviceUnitsToPoints(deviceUnits);
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;2-2-好的子程序名字&quot;&gt;&lt;a href=&quot;#2-2-好的子程序名字&quot; class=&quot;headerlink&quot; title=&quot;2.2 好的子程序名字&quot;&gt;&lt;/a&gt;2.2 好的子程序名字&lt;/h2&gt;&lt;p&gt;一个子程序由名字、参数列表和程序体组成。一个好的名字能清晰地描述子程序所做的一切，是一个好的子程序的起点。子程序命名应该遵循如下原则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;描述子程序所做的&lt;strong&gt;所有&lt;/strong&gt;事情&lt;/li&gt;
&lt;li&gt;避免使用无意义的、模糊或表述不清的动词：像&lt;code&gt;Handle&lt;/code&gt;、&lt;code&gt;Perform&lt;/code&gt;、&lt;code&gt;Process&lt;/code&gt;等等动词都没有精确地描述操作，例如把&lt;code&gt;HandleOutput()&lt;/code&gt;改为&lt;code&gt;FormatAndPrintOutput()&lt;/code&gt;就能更容易看清楚子程序的功能。&lt;/li&gt;
&lt;li&gt;不要仅通过数字来形成不同的子程序各字：不要出现像&lt;code&gt;OutputUser1&lt;/code&gt;、&lt;code&gt;OutputUser2&lt;/code&gt;子程序然后将它们组成一个大程序的情况。&lt;/li&gt;
&lt;li&gt;根据需要确定子程序名字的长度：变量名的最佳长度是9到15个字符，而子程序要更复杂些，长短要视该名字是否清晰易懂而定。&lt;/li&gt;
&lt;li&gt;给函数命名时要对返回值有所描述：&lt;code&gt;customerid.Next()&lt;/code&gt;、&lt;code&gt;printer.IsReady()&lt;/code&gt;、&lt;code&gt;pen.CurrentColor()&lt;/code&gt;等都是不错的例子。&lt;/li&gt;
&lt;li&gt;给过程起名时使用语气强烈的动词加宾语的形式：如&lt;code&gt;PrintDocument()&lt;/code&gt;、&lt;code&gt;CheckOrderInfo()&lt;/code&gt;。对于面向对象语言是特例，因为对象（宾语）本身已经包含在调用语句中了，如&lt;code&gt;document.Print()&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;为常用操作确立命名规则：在实际项目中，约定一套语义命名规则。避免出现不同人写出像&lt;code&gt;employee.id.Get()&lt;/code&gt;，&lt;code&gt;employee.GetId()&lt;/code&gt;，&lt;code&gt;employee.id()&lt;/code&gt;这样难以记住的细节。&lt;/li&gt;
&lt;li&gt;准确使用对仗词：有助于保持一致性和可读性&lt;ul&gt;
&lt;li&gt;&lt;code&gt;add/remove&lt;/code&gt;，&lt;code&gt;open/close&lt;/code&gt;，&lt;code&gt;begin/end&lt;/code&gt;，&lt;code&gt;insert/delete&lt;/code&gt;，&lt;code&gt;show/hide&lt;/code&gt;，&lt;code&gt;create/destroy&lt;/code&gt;，&lt;code&gt;source/target&lt;/code&gt;，&lt;code&gt;first/last&lt;/code&gt;，&lt;code&gt;min/max&lt;/code&gt;，&lt;code&gt;start/stop&lt;/code&gt;，&lt;code&gt;get/set&lt;/code&gt;，&lt;code&gt;next/previous&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-3-写好子程序的参数&quot;&gt;&lt;a href=&quot;#2-3-写好子程序的参数&quot; class=&quot;headerlink&quot; title=&quot;2.3 写好子程序的参数&quot;&gt;&lt;/a&gt;2.3 写好子程序的参数&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;按照输入-修改-输出的顺序排列参数：不要随机地或按字母顺序排列参数&lt;/li&gt;
&lt;li&gt;&lt;em&gt;考虑自己创建IN和OUT关键字&lt;/em&gt;（特指C++）：定义无值的宏扩展C++语言，在项目中要极其谨慎&lt;/li&gt;
&lt;li&gt;如果几个子程序都用了类似的一些参数，应该让这些参数的排列顺序保持一致：如C语言中的&lt;code&gt;fprintf()/printf()&lt;/code&gt;，&lt;code&gt;strncpy()/memcpy()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用所有的参数：既然往子程序中传递了一个参数，就一定要用到这个参数。&lt;em&gt;使用条件编译而忽略了某一些参数的情况除外。&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;把状态或出错变量放在最后&lt;/li&gt;
&lt;li&gt;不要把子程序的参数用做工作变量：&lt;strong&gt;不要修改任何输入参数&lt;/strong&gt;，应明确引入一些中间的工作变量&lt;/li&gt;
&lt;li&gt;在接口中对参数的假定加以说明：用注释甚至断言，说明参数的单位、状态或错误值的含义、数值的范围、不该出现的特定数值等等&lt;/li&gt;
&lt;li&gt;把子程序的参数个数限制在大约7个以内：若传参过多，说明子程序之间的耦合过紧，应重新设计子程序&lt;/li&gt;
&lt;li&gt;考虑对参数采用某种表示输入、修改、输出的命名规则：如i&lt;em&gt;、m&lt;/em&gt;、Output_等前缀&lt;/li&gt;
&lt;li&gt;为子程序传递用以维持其接口抽象的变量或对象：考虑传入的是若干底层数据，还是一个包装对象&lt;/li&gt;
&lt;li&gt;确保实际参数与形式参数的类型相匹配：注意传入参数时可能发生的隐式类型转换&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-4-子程序的内容&quot;&gt;&lt;a href=&quot;#2-4-子程序的内容&quot; class=&quot;headerlink&quot; title=&quot;2.4 子程序的内容&quot;&gt;&lt;/a&gt;2.4 子程序的内容&lt;/h2&gt;&lt;p&gt;关于子程序的长度没有定论。与其对子程序的长度强加限制，还不如让下面这些因素——如子程序的内聚性、嵌套的层次、变量的数量、决策点的数量、解释子程序用意所需的注释数量以及其他些跟复杂度相关的考虑事项等——来决定子程度的长度。但是，这里要引用一下《代码整洁之道》3.1节“短小”中的内容来辅助参考子程序应该达到的长度。我个人总结，决定子程序的长短的唯一标准，是&lt;strong&gt;一个函数只做一件事&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;……经过漫长的试错，经验告诉我，函数就该小……函数也不该有100行那么长，20行封顶最佳……每个函数都一目了然。每个函数都只说一件事。而且，每个函数都依序把你带到下一个函数。这就是函数应该达到的短小程度！……通常来说，应该短于代码清单3-2中的函数（该函数有10行）……&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在子程序的设计上，应该注重其内聚性，即子程序中各种操作之间联系的紧密程度。我们的目标是让&lt;strong&gt;每个子程序只把一件事做好，不再做任何其他事情&lt;/strong&gt;。理解下面几个关于内聚性层次的概念有助于思考如何让子程序尽可能地内聚。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最好的内聚&lt;ul&gt;
&lt;li&gt;功能的内聚性：如&lt;code&gt;GetCustomerName()&lt;/code&gt;、&lt;code&gt;EraseFile()&lt;/code&gt;，前提是子程序所执行的操作与其名字相符。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;不够理想的内聚&lt;ul&gt;
&lt;li&gt;顺序上的内聚性：子程序内包含有需要按特定顺序执行的操作，这些步骤需要共享数据，而且只有在全部执行完毕后才完成了一项完整的功能。&lt;/li&gt;
&lt;li&gt;通信上的内聚性：一个子程序中的不同操作使用了同样的数据，但不存在其他任何联系。&lt;/li&gt;
&lt;li&gt;临时的内聚性：含有一些因为需要同时执行才放到一起的操作的子程序，如&lt;code&gt;Startup()&lt;/code&gt;中塞进一堆互不相关的初始化代码，应该把临时性的子程序看做是一系列事件的组织者，并去调用其他子程序。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;不可取的内聚&lt;ul&gt;
&lt;li&gt;过程上的内聚性：一个子程序中的操作是按特定的顺序进行的。&lt;/li&gt;
&lt;li&gt;逻辑上的内聚性：若干操作被放入同一个子程序中，通过传入的控制标志（由if/else或switch/case控制）选择执行其中的一项操作。这种情况下子程序唯一的功能应该是发布各种命令调用底层子程序，其自身并不做任何处理。&lt;/li&gt;
&lt;li&gt;巧合的内聚性：指子程序中的各个操作之间没有任何可以看到的关联。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://www.kancloud.cn/raytaylorlin/code-complete-checklist/135273&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;核对表：高质量的子程序&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;参考文献：电子工业出版社《代码大全（第2版）》第6、7章&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在计算时代的早期，程序员基于语句思考编程问题。到了20世纪七八十年代，程序员开始基于子程序去思考编程。进入21世纪，程序员以类为基础思考编程问题。类是由一组数据和子程序构成的集合，这些数据和子程序共同拥有一组内聚的、明确定义的职责。由此可见类和子程序在现代编程中的地位。本文将就如何创建高质量的类和子程序提供一些建议。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="综合" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/"/>
    
      <category term="软件工程" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="软件构建" scheme="http://raytaylorlin.com/tags/%E8%BD%AF%E4%BB%B6%E6%9E%84%E5%BB%BA/"/>
    
      <category term="软件工程" scheme="http://raytaylorlin.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>软件构建（二）——架构与设计</title>
    <link href="http://raytaylorlin.com/tech/complex/software/software-construction-2/"/>
    <id>http://raytaylorlin.com/tech/complex/software/software-construction-2/</id>
    <published>2016-04-01T03:37:35.000Z</published>
    <updated>2016-04-01T03:27:53.374Z</updated>
    
    <content type="html">&lt;p&gt;软件架构（software architecture）是软件设计的高层部分，是用于支撑更细节的设计的框架。本文关注的并不是如何开发一个软件的架构，而是设计一个架构时应该关注的部分。此外，设计就是把需求分析和编码调试连在一起的活动，好的高层设计能提供一个可以稳妥容纳多个较低层次设计的结构，其对于小型项目非常有用，对大型项目更是不可或缺。因此，本文将总结软件构建中设计的基础概念及基本方法。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-软件构建的主要活动&quot;&gt;&lt;a href=&quot;#1-软件构建的主要活动&quot; class=&quot;headerlink&quot; title=&quot;1. 软件构建的主要活动&quot;&gt;&lt;/a&gt;1. 软件构建的主要活动&lt;/h1&gt;&lt;h2 id=&quot;1-1-软件架构的概念&quot;&gt;&lt;a href=&quot;#1-1-软件架构的概念&quot; class=&quot;headerlink&quot; title=&quot;1.1 软件架构的概念&quot;&gt;&lt;/a&gt;1.1 软件架构的概念&lt;/h2&gt;&lt;p&gt;一个经过慎重考虑的架构为“从顶层到底层维护系统的概念完整性”提供了必备的结构和体系，它为程序员提供了指引，将工作分为几个部分，使多个开发者可以独立工作。好的架构使得构建活动变得更容易。糟糕的架构则使构建活动几乎寸步难行。在构建期间或者更晚的时候进行架构变更，代价也是高昂的。&lt;/p&gt;
&lt;h2 id=&quot;1-2-架构的典型组成部分&quot;&gt;&lt;a href=&quot;#1-2-架构的典型组成部分&quot; class=&quot;headerlink&quot; title=&quot;1.2 架构的典型组成部分&quot;&gt;&lt;/a&gt;1.2 架构的典型组成部分&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;程序组织：定义程序的主要构造块（子系统或模块），它们的责任以及它们之间的通信规则&lt;/li&gt;
&lt;li&gt;主要的类：指出每个主要的类的责任，以及该类如何与其他类交互（继承体系、状态转换、对象持久化等）&lt;/li&gt;
&lt;li&gt;数据设计：描述所用到的主要数据文件和数据表的设计&lt;/li&gt;
&lt;li&gt;业务规则：描述某些特殊的业务规则对系统设计的影响&lt;/li&gt;
&lt;li&gt;用户界面设计：架构应模块化，以便替换UI部分&lt;/li&gt;
&lt;li&gt;资源管理：描述管理稀缺资源（数据库连接、线程、内存等）的计划&lt;/li&gt;
&lt;li&gt;安全性：描述实现设计层面和代码层面的安全性的方法，并建立威胁模型&lt;/li&gt;
&lt;li&gt;性能：如果需要关注性能，就应该在需求中详细定义性能目标&lt;/li&gt;
&lt;li&gt;可伸缩性：描述系统如何应对未来需求的增长（如用户数量、服务器数量、网络节点数量等等）&lt;/li&gt;
&lt;li&gt;国际化/本地化：考虑典型的字符串和字符集问题&lt;/li&gt;
&lt;li&gt;输入/输出：定义数据的读取和写入策略&lt;/li&gt;
&lt;li&gt;错误处理：确定一种“一致处理错误”的策略（纠正还是检测错误？主动还是被动检测错误？程序如何传播错误？程序在什么层次处理错误？等等）&lt;/li&gt;
&lt;li&gt;容错性：考虑系统在出错时，让系统转入“部分运转”状态，还是某种“功能退化”状态，甚至自动关闭或重启&lt;/li&gt;
&lt;li&gt;架构的可行性：必须论证系统在技术上是否可实现&lt;/li&gt;
&lt;li&gt;关于“买”还是“造”的决策：决定购买组件，使用第三方组件，还是自己造轮子&lt;/li&gt;
&lt;li&gt;关于复用的决策：说明如何对复用的软件进行加工，使之符合其他架构目标&lt;/li&gt;
&lt;li&gt;变更策略：考虑如何让架构足够灵活，能够适应可能出现的变化&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://www.kancloud.cn/raytaylorlin/code-complete-checklist/133369&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;核对表：架构&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;2-软件构建中设计的基础&quot;&gt;&lt;a href=&quot;#2-软件构建中设计的基础&quot; class=&quot;headerlink&quot; title=&quot;2. 软件构建中设计的基础&quot;&gt;&lt;/a&gt;2. 软件构建中设计的基础&lt;/h1&gt;&lt;h2 id=&quot;2-1-理解设计的挑战&quot;&gt;&lt;a href=&quot;#2-1-理解设计的挑战&quot; class=&quot;headerlink&quot; title=&quot;2.1 理解设计的挑战&quot;&gt;&lt;/a&gt;2.1 理解设计的挑战&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;设计是一个险恶的问题：必须首先把这个问题“解决”一遍以便能够明确地定义它，然后再次解决该问题&lt;/li&gt;
&lt;li&gt;设计是个了无章法的过程：设计过程中会犯很多错，并且很难判断设计何时算是“足够好”&lt;/li&gt;
&lt;li&gt;设计就是确定取舍和调整顺序的过程&lt;/li&gt;
&lt;li&gt;设计受到诸多限制：时间、资源、空间等等&lt;/li&gt;
&lt;li&gt;设计是不确定的：让三个人设计同一套程序，可能会做出三套截然不同而且都不错的设计&lt;/li&gt;
&lt;li&gt;设计是一个启发式过程：由于充满不确定性，设计是具有探索性的不是能保证产生预期结果的可重复过程&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-2-关键的设计概念&quot;&gt;&lt;a href=&quot;#2-2-关键的设计概念&quot; class=&quot;headerlink&quot; title=&quot;2.2 关键的设计概念&quot;&gt;&lt;/a&gt;2.2 关键的设计概念&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;软件的首要技术使命便是管理复杂度。&lt;/strong&gt;在软件架构的层次上，可以通过把整个系统分解为多个子系统来降低问题的复杂度。子系统间的相互依赖越少，就越容易在同一时间里专注问题的一小部分。精心设计的对象关系使关注点相互分离，从而使你能在每个时刻只专注于一件事情。可以用这两种方法来管理复杂度：把任何人在同一时间需要处理的本质复杂度的量减到最少；不要让偶然性的复杂度无谓地快速增长。一旦你能理解软件开发中任何其他技术目标都不如管理复杂度重要时，众多设计上的考虑就都变得直截了当了。&lt;/p&gt;
&lt;h2 id=&quot;2-3-理想的设计特征&quot;&gt;&lt;a href=&quot;#2-3-理想的设计特征&quot; class=&quot;headerlink&quot; title=&quot;2.3 理想的设计特征&quot;&gt;&lt;/a&gt;2.3 理想的设计特征&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;最小的复杂度：设计要简单且易于理解&lt;/li&gt;
&lt;li&gt;易维护：为做维护工作的程序猿着想&lt;/li&gt;
&lt;li&gt;松散耦合：让程序的各个组成部分之间关联最小&lt;/li&gt;
&lt;li&gt;可扩展性：增强系统的功能而无须破坏其底层结构&lt;/li&gt;
&lt;li&gt;可重用性：系统的组成部分能在其他系统中重复使用&lt;/li&gt;
&lt;li&gt;高扇入：让大量的类使用某个给定的类（系统很好地利用了在较低层次上的工具类）&lt;/li&gt;
&lt;li&gt;低扇出：让一个类里少量或适中地使用其他的类&lt;/li&gt;
&lt;li&gt;可移植性：方便移植到其他环境中&lt;/li&gt;
&lt;li&gt;精简性：系统没有多余的部分&lt;/li&gt;
&lt;li&gt;层次性：保持系统各个分解层的层次性，使你能在任意的层面观察系统，并得到某种具有一致性的看法&lt;/li&gt;
&lt;li&gt;标准技术：尽量用标准化的、常用的方法，而不是依赖许多外来的稀奇古怪的技术或组件&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-4-设计的层次&quot;&gt;&lt;a href=&quot;#2-4-设计的层次&quot; class=&quot;headerlink&quot; title=&quot;2.4 设计的层次&quot;&gt;&lt;/a&gt;2.4 设计的层次&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://raytaylorlin-blog.qiniudn.com/image%2Fsoftware%2F%E4%B8%80%E4%B8%AA%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%B1%82%E6%AC%A1.png&quot; alt=&quot;一个软件系统的设计层次&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;3-软件构建中设计的方法&quot;&gt;&lt;a href=&quot;#3-软件构建中设计的方法&quot; class=&quot;headerlink&quot; title=&quot;3. 软件构建中设计的方法&quot;&gt;&lt;/a&gt;3. 软件构建中设计的方法&lt;/h1&gt;&lt;h2 id=&quot;3-1-启发式方法&quot;&gt;&lt;a href=&quot;#3-1-启发式方法&quot; class=&quot;headerlink&quot; title=&quot;3.1 启发式方法&quot;&gt;&lt;/a&gt;3.1 启发式方法&lt;/h2&gt;&lt;p&gt;由于软件设计是非确定性的，因此灵活熟练地运用一组有效的启发式方法（试探法），便成了合理的软件设计的核心工作。下面根据管理软件复杂度的原则，给出了一些参考的启发式设计方法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;找出现实世界中的对象&lt;ul&gt;
&lt;li&gt;辨识对象及其属性（数据）&lt;/li&gt;
&lt;li&gt;确定可以对各个对象进行的操作（方法）&lt;/li&gt;
&lt;li&gt;确定各个对象能对其他对象进行的操作&lt;/li&gt;
&lt;li&gt;确定对象的哪些部分对其他对象不可见&lt;/li&gt;
&lt;li&gt;定义每个对象的公开接口&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;形成一致的抽象：注意参考2.4中层次对系统分层抽象，抽象可以让你忽略无关的细节&lt;/li&gt;
&lt;li&gt;封装实现细节：抽象可以“让你从高层的细节来看待一个对象”，而封装则让你“不能看到对象的任何其他细节层次”&lt;/li&gt;
&lt;li&gt;信息隐藏&lt;ul&gt;
&lt;li&gt;类的接口应该尽可能少地暴露其内部工作机制&lt;/li&gt;
&lt;li&gt;隐藏复杂度，包括复杂的数据类型、文件结构、布尔判断以及晦涩的算法&lt;/li&gt;
&lt;li&gt;隐藏变化源，当变化发生时，其影响就能被限制在局部范围内&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;当继承能简化设计时就继承：继承很强大，但如果使用不当，也有极大的弊端&lt;/li&gt;
&lt;li&gt;找出容易改变的区域&lt;ul&gt;
&lt;li&gt;应对变化的措施：找出看起来容易变化的部分，单独划分成类，并设计好类接口将变化隔离开来&lt;/li&gt;
&lt;li&gt;容易变化的区域：业务规则、对硬件的依赖、输入输出、非标准的编程语言特性、困难的设计区域和构建区域、状态变量、数据量的限制等等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;保持松散耦合&lt;ul&gt;
&lt;li&gt;衡量模块间耦合度的参考标准：规模（模块间的连接数）、可见性（模块间连接的显著程度）、灵活性（模块间的连接是否容易改动）&lt;/li&gt;
&lt;li&gt;耦合的种类：简单数据参数耦合（模块间传简单类型数据，&lt;strong&gt;正常&lt;/strong&gt;）、简单对象耦合（一个模块实例化一个对象，&lt;strong&gt;正常&lt;/strong&gt;）、对象参数耦合（模块间传对象参数，&lt;strong&gt;谨慎&lt;/strong&gt;）、语义上的耦合（必须知道另一个模块内部工作细节才能使用，&lt;strong&gt;危险&lt;/strong&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;查阅常用的设计模式&lt;ul&gt;
&lt;li&gt;通过提供现成的抽象来减少复杂度&lt;/li&gt;
&lt;li&gt;通过把常见解决方案的细节予以制度化来减少出错&lt;/li&gt;
&lt;li&gt;通过提供多种设计方案而带来启发性的价值&lt;/li&gt;
&lt;li&gt;通过把设计对话提升到一个更高的层次上来简化与同事间的交流&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;其他启发式方法&lt;ul&gt;
&lt;li&gt;高内聚性：使类所达到的目标（内聚性）尽可能高&lt;/li&gt;
&lt;li&gt;为测试而设计：思考诸如“如果为了便于测试而设计这个系统，那么系统会是什么样子”的问题很有益处&lt;/li&gt;
&lt;li&gt;避免失误：充分考虑系统可能的失败模式&lt;/li&gt;
&lt;li&gt;画一个图：图可以在一个更高的抽象层次上表达问题&lt;/li&gt;
&lt;li&gt;创建中央控制点&lt;/li&gt;
&lt;li&gt;考虑使用蛮力突破&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;3-2-设计实践&quot;&gt;&lt;a href=&quot;#3-2-设计实践&quot; class=&quot;headerlink&quot; title=&quot;3.2 设计实践&quot;&gt;&lt;/a&gt;3.2 设计实践&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;迭代：在备选的设计方案之中&lt;strong&gt;循环并且尝试一些不同的做法&lt;/strong&gt;时，将同时从高层和低层的不同视角去审视问题。&lt;/li&gt;
&lt;li&gt;分而治之：把程序分解为不同的关注区域，然后分别处理每一个区域。&lt;/li&gt;
&lt;li&gt;自上而下和自下而上：前者始于抽象，逐步向底层分解；后者始于细节，向一般性延伸。两者并不冲突，可以相互协作。&lt;/li&gt;
&lt;li&gt;建立试验性原型：写出用于&lt;strong&gt;回答特定设计问题的、量最少且能够随时扔掉&lt;/strong&gt;的代码。注意不要把原型用在最终产品中。&lt;/li&gt;
&lt;li&gt;合作设计：与同事讨论，审查，甚至共同设计&lt;/li&gt;
&lt;li&gt;要做多少设计才够：若编码前还判断不了应该坐多深入的设计，宁可继续做更详细的设计，也不要事后才发现设计得还不够。&lt;/li&gt;
&lt;li&gt;记录设计成果：把设计文档插入到代码里、用Wiki来记录设计讨论和决策、写总结邮件、拍照、保留设计挂图、使用CRC（类、职责、合作者）卡片、在适当的细节层创建UML图&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://www.kancloud.cn/raytaylorlin/code-complete-checklist/134109&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;核对表：软件构造中的设计&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;参考文献：电子工业出版社《代码大全（第2版）》3.5节，第5章&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;软件架构（software architecture）是软件设计的高层部分，是用于支撑更细节的设计的框架。本文关注的并不是如何开发一个软件的架构，而是设计一个架构时应该关注的部分。此外，设计就是把需求分析和编码调试连在一起的活动，好的高层设计能提供一个可以稳妥容纳多个较低层次设计的结构，其对于小型项目非常有用，对大型项目更是不可或缺。因此，本文将总结软件构建中设计的基础概念及基本方法。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="综合" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/"/>
    
      <category term="软件工程" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="软件构建" scheme="http://raytaylorlin.com/tags/%E8%BD%AF%E4%BB%B6%E6%9E%84%E5%BB%BA/"/>
    
      <category term="软件工程" scheme="http://raytaylorlin.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>软件构建（一）——软件构建基础</title>
    <link href="http://raytaylorlin.com/tech/complex/software/software-construction-1/"/>
    <id>http://raytaylorlin.com/tech/complex/software/software-construction-1/</id>
    <published>2016-03-29T08:17:53.000Z</published>
    <updated>2016-03-29T06:59:19.601Z</updated>
    
    <content type="html">&lt;p&gt;开发计算机软件是一个非常复杂的过程，而软件“构建”是指建设过程中“动手”的部分，其中不仅仅包括“写代码”，还包含了计划、设计、测试、集成等等其他工作。本文首先总结软件构建的含义以及其主要活动；接着列举了一个比较合理的隐喻——建造房子——来理解软件开发；最后阐述了软件构建的前期准备工作的重要性，阐述了定义问题和分析需求的重要性，以及应该准备哪些事情。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-软件构建的主要活动&quot;&gt;&lt;a href=&quot;#1-软件构建的主要活动&quot; class=&quot;headerlink&quot; title=&quot;1. 软件构建的主要活动&quot;&gt;&lt;/a&gt;1. 软件构建的主要活动&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://raytaylorlin-blog.qiniudn.com/image%2Fsoftware%2F%E8%BD%AF%E4%BB%B6%E6%9E%84%E5%BB%BA%E7%9A%84%E4%B8%BB%E8%A6%81%E6%B4%BB%E5%8A%A8.png&quot; alt=&quot;软件构建的主要活动（阴影覆盖的部分）&quot;&gt;&lt;/p&gt;
&lt;p&gt;如图所示，软件构建活动主要是编码与调试，但也涉及详细设计、规划构建、单元测试、集成、集成测试等其他活动。下面列出一些具体的构建活动中的任务：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;验证有关的基础工作已经完成，因此构建活动可以顺利地进行下去&lt;/li&gt;
&lt;li&gt;确定如何测试所写的代码&lt;/li&gt;
&lt;li&gt;设计并编写类和子程序&lt;/li&gt;
&lt;li&gt;创建并命名变量和具名常量&lt;/li&gt;
&lt;li&gt;选择控制结构，组织语句块&lt;/li&gt;
&lt;li&gt;对代码进行单元测试和集成测试，并排除其中的错误&lt;/li&gt;
&lt;li&gt;评审开发团队其他成员的底层设计和代码，并让他们评审你的工作&lt;/li&gt;
&lt;li&gt;润饰代码，仔细进行代码的格式化和注释&lt;/li&gt;
&lt;li&gt;将单独开发的多个软件组件集成为一体&lt;/li&gt;
&lt;li&gt;调整代码，让它更快、更省资源&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;2-用隐喻来更充分地理解软件开发&quot;&gt;&lt;a href=&quot;#2-用隐喻来更充分地理解软件开发&quot; class=&quot;headerlink&quot; title=&quot;2. 用隐喻来更充分地理解软件开发&quot;&gt;&lt;/a&gt;2. 用隐喻来更充分地理解软件开发&lt;/h1&gt;&lt;p&gt;当向一个非程序员解释什么是软件开发的时候，最好的办法就是通过某种隐喻或类比来解释。隐喻把软件开发过程与其他你熟系的活动联系在一起，帮助你更好地理解。不同的隐喻彼此并不排斥，应当使用对你最有益处的某种隐喻组合。&lt;/p&gt;
&lt;p&gt;使用&lt;strong&gt;建造房子&lt;/strong&gt;是一个很好的隐喻，此处做个引用摘录：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;首先你要决定准备建一个什么类型的房子一一在软件开发里的类似事项称为问题定义。接下来，你必须和某个建筑师探讨这一总体设计，并得到批准。这跟软件架构设计十分相似。然后你画出详细的蓝图，雇一个承包人，就像软件的详细设计。再然后，你要准备好建造地点，打好地基，搭建房屋框架，砌好边墙，盖好房顶，通好水、电、煤气等。这就如同是软件的构建一样。在房子大部分完成之后，庭院设计师、油漆匠和装修工还要来把你新盖的家以及里面的家什美化一番。这就好比软件的优化过程。在整个过程中，还会有各种监查人员来检查工地、地基、框架、布线以及其他需要检查的地方。这相当于软件复查评审。&lt;/p&gt;
&lt;p&gt;建造一个房子的时候，你不会去试着建造那些能买得到的现成的东西。你会买洗衣机、烘干机、洗碗机、电冰箱以及冷藏柜……当开发软件时，你会大量使用高级语言所提供的功能，而不会自己去编写操作系统层次的代码。你可能还要用些现成的程序库，比如说一些容器类、科学计算函数、用户界面组件、数据库访问组件，等等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;3-前期准备&quot;&gt;&lt;a href=&quot;#3-前期准备&quot; class=&quot;headerlink&quot; title=&quot;3. 前期准备&quot;&gt;&lt;/a&gt;3. 前期准备&lt;/h1&gt;&lt;h2 id=&quot;3-1-前期准备的重要性&quot;&gt;&lt;a href=&quot;#3-1-前期准备的重要性&quot; class=&quot;headerlink&quot; title=&quot;3.1 前期准备的重要性&quot;&gt;&lt;/a&gt;3.1 前期准备的重要性&lt;/h2&gt;&lt;p&gt;就像修建建筑物一样，项目的成败很大程度上在构建活动开始之前就已经注定了。建造住宅小区的施工人员，在开始建造第一栋房子之前，并不需要知道小区里面每一栋房子的每一个细节。但他会调查施工场所，制定下水道和电线的走向等。如果施工人员准备不充分，那么建造过程很可能会因为“需要在某所已经造好的房子的地下挖一条下水道”而延误。&lt;/p&gt;
&lt;p&gt;准备工作的中心目标就是降低风险：一个好的项目规划者能够尽可能早地将主要的风险清除掉，以便项目的大部分工作能够尽可能平稳地进行。有时候用户在一开始并不完全确定自己想要的是什么，因此值得花费比理想情况下更多的力气，找出他们真正想要的东西。但这至少比“先做一个错误的东西出来，然后扔掉，并从头来过”的成本要低廉。&lt;/p&gt;
&lt;h2 id=&quot;3-2-准备工作和构建活动的平衡&quot;&gt;&lt;a href=&quot;#3-2-准备工作和构建活动的平衡&quot; class=&quot;headerlink&quot; title=&quot;3.2 准备工作和构建活动的平衡&quot;&gt;&lt;/a&gt;3.2 准备工作和构建活动的平衡&lt;/h2&gt;&lt;p&gt;真实项目大致可以分为“商业系统”（Web站点、游戏、信息管理系统等），“使命攸关的系统”（软件工具、盒装软件、Web服务等）和“使命攸关的嵌入式系统”（航空软件、医疗设备、操作系统等）三大类。不同种类的软件项目，需要在“准备工作”和“构建活动”之间做出不同的平衡。你应该首先确定哪些前期准备活动适合你的项目。有些项目在前期准备土面花的时间太少了，结果使得在构建活动中遇到大量不必要的反复修改，同时阻碍了项目的稳步前进。有些项目则预先做了太多的事情，固执地坚持原有的需求和计划，后来事实证明这些需求和计划是无效的，这同样阻止了构建活动的顺利进展。此外，项目的实际情况也决定了哪一种开发方法更加合适，下表给出了参考。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;需求&lt;/th&gt;
&lt;th&gt;设计&lt;/th&gt;
&lt;th&gt;领域熟悉程度&lt;/th&gt;
&lt;th&gt;项目风险&lt;/th&gt;
&lt;th&gt;后期改动代价&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;序列式开发&lt;/td&gt;
&lt;td&gt;稳定&lt;/td&gt;
&lt;td&gt;直截了当&lt;/td&gt;
&lt;td&gt;熟悉&lt;/td&gt;
&lt;td&gt;小&lt;/td&gt;
&lt;td&gt;昂贵&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;迭代式开发&lt;/td&gt;
&lt;td&gt;不稳定&lt;/td&gt;
&lt;td&gt;复杂，有挑战性&lt;/td&gt;
&lt;td&gt;不熟悉&lt;/td&gt;
&lt;td&gt;大&lt;/td&gt;
&lt;td&gt;较低&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&quot;3-3-明确问题和需求&quot;&gt;&lt;a href=&quot;#3-3-明确问题和需求&quot; class=&quot;headerlink&quot; title=&quot;3.3 明确问题和需求&quot;&gt;&lt;/a&gt;3.3 明确问题和需求&lt;/h2&gt;&lt;p&gt;在开始构建之前，必须对这个系统要解决的&lt;strong&gt;问题&lt;/strong&gt;做出清楚的描述。“问题定义”只定义了“问题是什么”，应该从客户的角度用客户的语言来描述问题，而不应该用计算机的专业术语叙述（除非需要解决的就是与计算机本身相关的问题）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;需求&lt;/strong&gt; 详细描述软件系统应该做什么。明确的需求有助于确保是用户（而不是程序员〉驾驭系统的功能，有助于减少开始编程开发之后的系统变更情况，有助于避免争论。但是在构建期间，需求通常会有25%的变化，要更好地应对需求变更，可以采用以下方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用&lt;a href=&quot;http://www.kancloud.cn/raytaylorlin/code-complete-checklist/132375&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;需求核对表&lt;/a&gt;来评估你的需求的质量&lt;/li&gt;
&lt;li&gt;确保每一个人都知道需求变更的代价&lt;/li&gt;
&lt;li&gt;建立一套变更控制程序&lt;/li&gt;
&lt;li&gt;使用能适应变更的开发方法（如演进原型、演进交付）&lt;/li&gt;
&lt;li&gt;考虑项目的商业价值&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;3-4-花费在前期准备上的时间&quot;&gt;&lt;a href=&quot;#3-4-花费在前期准备上的时间&quot; class=&quot;headerlink&quot; title=&quot;3.4 花费在前期准备上的时间&quot;&gt;&lt;/a&gt;3.4 花费在前期准备上的时间&lt;/h2&gt;&lt;p&gt;一般说来，一个运作良好的项目会在需求、架构以及其他前期计划方面投入10%~20%的工作量和20%~30%的时间。如果需求不稳定，同时你从事的是一个大型正式项目，那你就很可能需要为“与需求分析师协商”预留一些时间，以解决构建活动早期指出的需求问题；如果从事的是小型非正式项目，要预留足够的时间，将需求定义足够清晰，让需求的不稳定性对构建活动的负面影响降至最低。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这就好比你是一名承包商，有人请你建一栋房子。客户问你：“完成这项工作要花多少钱？”你会合理地询间：“你想要我做什么？”客户说：“我不能告诉你，不过我想知道需要花费多少钱？”你该明智地感谢他浪费了你的时间，然后转身回家。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;参考文献：电子工业出版社《代码大全（第2版）》第1-4章&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;开发计算机软件是一个非常复杂的过程，而软件“构建”是指建设过程中“动手”的部分，其中不仅仅包括“写代码”，还包含了计划、设计、测试、集成等等其他工作。本文首先总结软件构建的含义以及其主要活动；接着列举了一个比较合理的隐喻——建造房子——来理解软件开发；最后阐述了软件构建的前期准备工作的重要性，阐述了定义问题和分析需求的重要性，以及应该准备哪些事情。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="综合" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/"/>
    
      <category term="软件工程" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="软件构建" scheme="http://raytaylorlin.com/tags/%E8%BD%AF%E4%BB%B6%E6%9E%84%E5%BB%BA/"/>
    
      <category term="软件工程" scheme="http://raytaylorlin.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>新版Hexo主题Raytaylorism v2发布</title>
    <link href="http://raytaylorlin.com/daily/hexo-theme-raytaylorism-v2/"/>
    <id>http://raytaylorlin.com/daily/hexo-theme-raytaylorism-v2/</id>
    <published>2016-03-18T03:28:32.000Z</published>
    <updated>2016-03-29T07:03:33.085Z</updated>
    
    <content type="html">&lt;p&gt;时隔两年多，我自制的Hexo主题Raytaylorism（&lt;a href=&quot;https://github.com/raytaylorlin/hexo-theme-raytaylorism&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Github地址&lt;/a&gt;）终于喜迎v2版本的发布。这个项目可以说是我在学生时代Web前端领域中的收官之作，因此在本次升级主题的过程中，一切都尽量做到精细。例如所有的页面都经过重新设计，采用清新的的响应式的Material Design风格，加入了个性化的“读书”“关于”页面，以及皮肤自定义、分类目录、正文滚动目录、打赏等等特色功能，并且该主题支持最新的Hexo 3.1版本。由于主题的功能较为复杂，所有的安装说明和配置事项都写在了Github项目的README中，需要使用主题的同学请&lt;strong&gt;认真仔细阅读README&lt;/strong&gt;哦，&lt;strong&gt;特别是&lt;a href=&quot;https://github.com/raytaylorlin/hexo-theme-raytaylorism#启用重要&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;启用&lt;/a&gt;那一节的说明很重要！很重要！很重要！一定要照做否则你会发现hexo启动不起来或最终效果和截图上的不一样。&lt;/strong&gt; 使用过程中有任何问题欢迎给我开issue。下面正文将介绍主题在Github上没有详细解释但又非常有特色的功能。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-换肤功能&quot;&gt;&lt;a href=&quot;#1-换肤功能&quot; class=&quot;headerlink&quot; title=&quot;1. 换肤功能&quot;&gt;&lt;/a&gt;1. 换肤功能&lt;/h1&gt;&lt;p&gt;我个人非常喜欢Material Design这种简洁清新的设计风格，也非常喜欢其定义的各种颜色。博客主题是一种非常个性化的东西，我喜欢的配色方案（包括主题默认的indigo-pink方案）不一定是你喜欢的，因此raytaylorism在几乎所有带颜色的区域都预留了配置的接口（具体参见&lt;a href=&quot;https://github.com/raytaylorlin/hexo-theme-raytaylorism#样式&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;README-样式-主题颜色配置&lt;/a&gt;）。不过，总有一些设计感不强的同学不知道如何下手，所以下面给出了3款参考的皮肤配置方案，大家可以各取所需随意发挥。配色的一个基本原则，就是选好一种主色和强调色。&lt;/p&gt;
&lt;h2 id=&quot;1-1-夏日甜橙&quot;&gt;&lt;a href=&quot;#1-1-夏日甜橙&quot; class=&quot;headerlink&quot; title=&quot;1.1 夏日甜橙&quot;&gt;&lt;/a&gt;1.1 夏日甜橙&lt;/h2&gt;&lt;p&gt;主色：blue 强调色：deep-orange&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://raytaylorlin-blog.qiniudn.com/image%2Fdaily%2Fblue_deeporange.jpg&quot; alt=&quot;夏日甜橙&quot;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;color:
    header: indigo
    footer: indigo
    page_nav: indigo
    side_nav: indigo darken-1
    tag: green accent-4
    link: indigo
    pagination: green
    tab: green
    archive_item: grey
    fab: green
    fab_2: blue
    fab_3: orange
    new: pink
    about_header: indigo
    about_title: indigo
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;1-2-绿野仙踪&quot;&gt;&lt;a href=&quot;#1-2-绿野仙踪&quot; class=&quot;headerlink&quot; title=&quot;1.2 绿野仙踪&quot;&gt;&lt;/a&gt;1.2 绿野仙踪&lt;/h2&gt;&lt;p&gt;主色：green 强调色：red&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://raytaylorlin-blog.qiniudn.com/image%2Fdaily%2Fgreen_red.jpg&quot; alt=&quot;绿野仙踪&quot;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;color:
    header: green
    footer: green
    page_nav: green
    side_nav: green darken-1
    tag: red lighten-1
    article_title_link: green
    link: red
    pagination: red
    tab: red
    archive_item: grey
    fab: red
    fab_2: cyan
    fab_3: light-green
    new: red
    about_header: green
    about_title: green
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;1-3-林地木屋&quot;&gt;&lt;a href=&quot;#1-3-林地木屋&quot; class=&quot;headerlink&quot; title=&quot;1.3 林地木屋&quot;&gt;&lt;/a&gt;1.3 林地木屋&lt;/h2&gt;&lt;p&gt;主色：brown 强调色：light-green&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://raytaylorlin-blog.qiniudn.com/image%2Fdaily%2Fbrown_lightgreen.jpg&quot; alt=&quot;林地木屋&quot;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;color:
    header: brown darken-1
    footer: brown darken-1
    page_nav: brown darken-1
    side_nav: brown darken-1
    tag: light-green
    article_title_link: brown
    link: light-green
    pagination: light-green
    tab: light-green
    archive_item: grey
    fab: light-green
    fab_2: red
    fab_3: purple
    new: light-green
    about_header: brown darken-1
    about_title: brown
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;2-文章分类目录&quot;&gt;&lt;a href=&quot;#2-文章分类目录&quot; class=&quot;headerlink&quot; title=&quot;2. 文章分类目录&quot;&gt;&lt;/a&gt;2. 文章分类目录&lt;/h1&gt;&lt;p&gt;如果点击我的博客菜单中的“分类”按钮，会发现左侧侧滑栏会出来一个带有多个层级的文章分类列表。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://raytaylorlin-blog.qiniudn.com/image%2Fdaily%2Fraytaylorism-category.png&quot; alt=&quot;主题的分类目录&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果你也想要得到类似的效果（包括标签tag），需要按照&lt;a href=&quot;https://hexo.io/docs/front-matter.html#Categories-amp-Tags&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;hexo官方的categories/tags说明文档&lt;/a&gt;给你的博客文章设置正确的&lt;code&gt;categories&lt;/code&gt;和&lt;code&gt;tags&lt;/code&gt;配置项。也就是说你的每一篇博文的markdown文件中，需要设置类似于下方的几行配置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;categories:
- 一级目录
- 二级目录
- 三级目录
tags:
- 第一个标签
- 第二个标签
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;准确设置后，启动hexo时主题会自动解析所有文章并形成分类树，最终生成上图那样的分类层次。&lt;/p&gt;
&lt;h1 id=&quot;3-读书页面&quot;&gt;&lt;a href=&quot;#3-读书页面&quot; class=&quot;headerlink&quot; title=&quot;3. 读书页面&quot;&gt;&lt;/a&gt;3. 读书页面&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://raytaylorlin-blog.qiniudn.com/image%2Fdaily%2Fraytaylorism-reading.png&quot; alt=&quot;读书页面截图&quot;&gt;&lt;/p&gt;
&lt;p&gt;在&lt;a href=&quot;https://github.com/raytaylorlin/hexo-theme-raytaylorism#数据&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;README-数据-读书页面&lt;/a&gt;中其实已经说明了如何配置读书页面的数据，照着例子来改就行了。值得注意的是，“已读”“在读”“想读”这些标签的文字是可以通过&lt;code&gt;reading.json&lt;/code&gt;中的&lt;code&gt;define&lt;/code&gt;字段来修改的，甚至你还可以仿照读书页面，扩展出自己的专属页面，例如“作品”页面等。只要是满足这种列表条目的数据均可以在其上自由发挥。&lt;/p&gt;
&lt;h1 id=&quot;4-关于页面&quot;&gt;&lt;a href=&quot;#4-关于页面&quot; class=&quot;headerlink&quot; title=&quot;4. 关于页面&quot;&gt;&lt;/a&gt;4. 关于页面&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://raytaylorlin-blog.qiniudn.com/image%2Fdaily%2Fraytaylorism-about.png&quot; alt=&quot;关于页面截图&quot;&gt;&lt;/p&gt;
&lt;p&gt;在&lt;a href=&quot;https://github.com/raytaylorlin/hexo-theme-raytaylorism#数据&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;README-数据-关于页面&lt;/a&gt;中也说明了个&lt;code&gt;about.json&lt;/code&gt;中各个字段的含义，照着例子改就行了。&lt;/p&gt;
&lt;p&gt;另外关于页面的末尾还有一个“打赏”功能，点开后会出现微信和支付宝的二维码，这个需要你自己去制作自己的付款二维码，然后把&lt;code&gt;reward&lt;/code&gt;字段的两个图片链接替换掉。如果暂时不需要的话请将该字段设为null，&lt;strong&gt;千万不要傻乎乎地把主题照搬让别人给我的账号打赏了=。=&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;关于主题任何使用上的疑问，欢迎在&lt;a href=&quot;https://github.com/raytaylorlin/hexo-theme-raytaylorism/issues&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Issues&lt;/a&gt;上提问。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;时隔两年多，我自制的Hexo主题Raytaylorism（&lt;a href=&quot;https://github.com/raytaylorlin/hexo-theme-raytaylorism&quot;&gt;Github地址&lt;/a&gt;）终于喜迎v2版本的发布。这个项目可以说是我在学生时代Web前端领域中的收官之作，因此在本次升级主题的过程中，一切都尽量做到精细。例如所有的页面都经过重新设计，采用清新的的响应式的Material Design风格，加入了个性化的“读书”“关于”页面，以及皮肤自定义、分类目录、正文滚动目录、打赏等等特色功能，并且该主题支持最新的Hexo 3.1版本。由于主题的功能较为复杂，所有的安装说明和配置事项都写在了Github项目的README中，需要使用主题的同学请&lt;strong&gt;认真仔细阅读README&lt;/strong&gt;哦，&lt;strong&gt;特别是&lt;a href=&quot;https://github.com/raytaylorlin/hexo-theme-raytaylorism#启用重要&quot;&gt;启用&lt;/a&gt;那一节的说明很重要！很重要！很重要！一定要照做否则你会发现hexo启动不起来或最终效果和截图上的不一样。&lt;/strong&gt; 使用过程中有任何问题欢迎给我开issue。下面正文将介绍主题在Github上没有详细解释但又非常有特色的功能。&lt;/p&gt;
    
    </summary>
    
      <category term="日常" scheme="http://raytaylorlin.com/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="博客" scheme="http://raytaylorlin.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="Hexo" scheme="http://raytaylorlin.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>2015年秋季学期总结</title>
    <link href="http://raytaylorlin.com/daily/2015-autumn-summary/"/>
    <id>http://raytaylorlin.com/daily/2015-autumn-summary/</id>
    <published>2016-02-14T05:28:13.000Z</published>
    <updated>2016-02-14T05:51:54.054Z</updated>
    
    <content type="html">&lt;p&gt;好久没有写学期总结了。2015年秋季学期是我研究生阶段的倒数第二个学期，时间线上主要由实习、找工作、学（zhuang）习（bi）和写论文组成。由于这学期找完工作之后导师没有给我安排什么实验室的工作，所以有比较大段的自由时间可以支配。在外人看来我好像这学期过得很悠闲，实际上是在自己的合理安排下过得非常充实，现在写篇简短的文章总结一下。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;关于实习&quot;&gt;&lt;a href=&quot;#关于实习&quot; class=&quot;headerlink&quot; title=&quot;关于实习&quot;&gt;&lt;/a&gt;关于实习&lt;/h1&gt;&lt;p&gt;本学期比较特殊，要从七八两个月份的实习开始说起，而这次实习也可以说是我择业的转折点。本来原先在实验室一直从事的是Web前端开发，在这个领域也小有建树，但不知道从什么时候起，早些年内心里埋下的游戏开发的种子就开始生根发芽快速成长，直到15年的五月份找实习时，开始打定主意抛弃前端，只找游戏开发的岗位，而且是&lt;strong&gt;只找广州和深圳的游戏开发岗&lt;/strong&gt;。如此一来，其实真正理想的就只有腾讯和网易游戏两家可选。拿许总的话讲，就是“谈了多年的女孩到谈婚论嫁的时候，突然发现其实深爱的是另一个人”“自己给自己挖了一个巨大的坑”。突然的转行导致找实习乃至后面正式找工作都非常不顺，网易游戏是简历直接挂，腾讯游戏则是二面被刷。所幸后来拿到了多益网络的offer，抱着刷个游戏公司实习经历的想法，便果断放弃阿里的前端内推offer，义无反顾地投身到游戏开发的行业。&lt;/p&gt;
&lt;p&gt;许多同学在其他互联网公司实习后都觉得没什么太大收获，但是我却在多益实习收获了许多。技术方面，是提高了Python和Cocos2d-x引擎的熟练度，项目经历让我第一次真正接触到了游戏真机性能优化的过程；项目方面，积累了项目管理和带小团队（3程序3策划）的经验，产出了2D游戏作品《跳跳格鲁特》（&lt;a href=&quot;http://pan.baidu.com/s/1kTYrNfD&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;演示视频【密码8mm5】&lt;/a&gt;），以及利用下班时间个人打造的日式3D RPG demo《Fantasy Adventure》（&lt;a href=&quot;http://pan.baidu.com/s/1bnVkv9P&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;演示视频【密码dg67】&lt;/a&gt;），这两个作品也成为后面找工作时简历打动面试官的重要筹码；人脉方面，结识了一帮热爱游戏的志同道合的朋友，即使实习结束后也还经常联系交流，其中甚至有好几位还即将成为我未来的同事。当然，公司待我们不薄，我也可以很负责任地为多益正一下名，基本上没有知乎上说的那么离谱，具体情况嘛，想去多益的倒是可以私底下找我了解。总而言之，多益实习的生活丰富多彩，确实是一段难忘的经历。&lt;/p&gt;
&lt;h1 id=&quot;关于找工作&quot;&gt;&lt;a href=&quot;#关于找工作&quot; class=&quot;headerlink&quot; title=&quot;关于找工作&quot;&gt;&lt;/a&gt;关于找工作&lt;/h1&gt;&lt;p&gt;实习结束回校之后，马上就开始投身到找工作的浪潮，目标依旧是腾讯和网易游戏。然而即使认真准备了C++、算法、Cocos2d-x源码、Unity3D的深入知识，即使有了游戏公司实习经历的光环，即使有两个较为成型游戏作品的加持，面对腾讯面试依旧是浑身使不上力的感觉，依旧挂在二面。所幸网易游戏看得起我，给了第一份理想的offer，让我解了游戏开发道路的后顾之忧。后来又经贵人相助，得到了直面腾讯天美的机会，几经折腾最终是拿到了理想公司的理想部门的理想岗位。到国庆，终于华丽转身，找工作尘埃落定。当然，整个过程就只找了两家公司，没有体验过offer收割机的快感，也算是小小的遗憾。&lt;/p&gt;
&lt;h1 id=&quot;自由学习期&quot;&gt;&lt;a href=&quot;#自由学习期&quot; class=&quot;headerlink&quot; title=&quot;自由学习期&quot;&gt;&lt;/a&gt;自由学习期&lt;/h1&gt;&lt;p&gt;可能是因为我的offer是大转行，找完工作后导师也没有安排什么任务给我，所以国庆过后两个月开始进入了一段相对较长的自由学（zhuang）习（bi）期。这段时期就是看书看书再看书，看似悠哉，其实产出还是比较大的，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;看完《Windows游戏编程大师技巧（第2版）》&lt;/li&gt;
&lt;li&gt;看完《DirectX 9.0 3D游戏开发编程基础》&lt;/li&gt;
&lt;li&gt;看完《3D数学基础：图形与游戏开发》&lt;/li&gt;
&lt;li&gt;看完《武器屋》&lt;/li&gt;
&lt;li&gt;看完《圣剑传说》&lt;/li&gt;
&lt;li&gt;看完《游戏设计的100个原理》&lt;/li&gt;
&lt;li&gt;看完《Web全栈工程师的自我修养》&lt;/li&gt;
&lt;li&gt;看一部分《网络游戏核心技术与实战》&lt;/li&gt;
&lt;li&gt;看一部分DirectX 11 Tutorial&lt;/li&gt;
&lt;li&gt;其他杂七杂八的资料……&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;关于实验室培训&quot;&gt;&lt;a href=&quot;#关于实验室培训&quot; class=&quot;headerlink&quot; title=&quot;关于实验室培训&quot;&gt;&lt;/a&gt;关于实验室培训&lt;/h1&gt;&lt;p&gt;学习期间，大概是导师看我实在太闲，便让我开始培训实验室一批新人Web前端。早在两年以前，我便在Github上建立了&lt;a href=&quot;https://github.com/ITEC-ELWG/FE-Study&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ELWG前端学习&lt;/a&gt;项目，旨在推行一套比较规范的流程，来作为实验室一代又一代新人的Web前端入门培训。趁着这一次机会，我精练了整个前端培训项目，再加入一些后端的知识，形成了新的培训项目&lt;a href=&quot;https://github.com/ITEC-ELWG/WebSystemIntroduction&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Web系统导论&lt;/a&gt;。在此基础上，本学期我在实验室一共开了8次课（其中3次后端课由屌刘同学主讲），并有7位新人培训毕业上了课程的&lt;a href=&quot;https://github.com/ITEC-ELWG/FE-Study/blob/master/hero.md&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;英雄榜&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;当然，带新人之余也不能忘了实验室中坚力量的培养。做完新人培训之后，经过一番酝酿终于收了两个真正意义上的徒弟（邱邱和刘贵）。我在实验室所剩时间不多，现在又转行不再做Web前端，因此希望在毕业前能够将他们培养成前端大神兼接班人。既然是要往大神方向培养，那就得按照大神的标准来训练，打字、编辑器、计算机科学素养、前端基础、前端进阶、后端基础、设计基础等等一个都不能少。如今两个徒弟按照我初步制定的&lt;a href=&quot;https://www.processon.com/view/566543b8e4b0fd9299902eb4&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;前端大神培养计划&lt;/a&gt;稳步成长，我内心也甚是欣慰。&lt;/p&gt;
&lt;p&gt;除了实验室这两条培养主线之外，还有许许多多其他的带新人支线，比如带一位新生学C#、面向对象和Unity3D，带点团队移动组两位新人学入门前端，协同两位徒弟开办了若干次技术交流会等等。虽然事情都比较小，但也要分散不少精力去备课，设计教程和题目，心虽累，但仍收获颇丰，乐在其中。&lt;/p&gt;
&lt;h1 id=&quot;关于毕业论文&quot;&gt;&lt;a href=&quot;#关于毕业论文&quot; class=&quot;headerlink&quot; title=&quot;关于毕业论文&quot;&gt;&lt;/a&gt;关于毕业论文&lt;/h1&gt;&lt;p&gt;到了十二月份，就开始考虑写论文的事情了。早在写本科毕业论文的时候，就受尽了垃圾Word的折磨，比如混乱的多级标题、低效率的多级交叉引用、经常出问题的目录生成等等。同理，配套的画图工具Visio也是用户体验特别差。既然是程序员，那写论文最好也要按照程序员的基本法。一般科研界的论文用的是Latex，而程序员则惯用markdown。于是我在前人的基础上推陈出新，建立了一个开源项目&lt;a href=&quot;https://github.com/raytaylorlin/hust-graduation-thesis-pandoc&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;hust-graduation-thesis-pandoc&lt;/a&gt;可以使用markdown来华科的毕业论文，具体可以参见我之前的博文&lt;a href=&quot;/tech/complex/project/write-thesis-using-markdown/&quot;&gt;《使用markdown来写毕业论文》&lt;/a&gt;。Anyway，Word辣鸡，Visio辣鸡。&lt;/p&gt;
&lt;p&gt;Markdown在手，写起论文正文自然专注，正文还可以按章节拆分成多个md文件，用Git做版本控制，用&lt;a href=&quot;https://coding.net/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;coding.net&lt;/a&gt;做私有仓库托管。画图用&lt;a href=&quot;https://www.processon.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ProcessOn&lt;/a&gt;，打开浏览器即用，随时云端存储，又能导出矢量PDF，基本上可以抛弃Visio。绘制表格可以用&lt;a href=&quot;http://www.tablesgenerator.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;TablesGenerator&lt;/a&gt;在线可视化编辑再生成Latex粘贴到正文。交叉引用用&lt;code&gt;\label&lt;/code&gt;和&lt;code&gt;\ref&lt;/code&gt;设置，文献引用则用Google学术复制出bibtex来管理。经过了一个月的实践考验，学期结束的时候论文完成度已经达到90%，这套解决方案被证明是可行的，撰写体验也是愉悦的。&lt;/p&gt;
&lt;h1 id=&quot;关于新版博客&quot;&gt;&lt;a href=&quot;#关于新版博客&quot; class=&quot;headerlink&quot; title=&quot;关于新版博客&quot;&gt;&lt;/a&gt;关于新版博客&lt;/h1&gt;&lt;p&gt;新版博客大概计划在11月，但实施起来已经是寒假在家的时候了。这一次博客改版为了兼容最新版本的Hexo3（老版仅能支持Hexo2是一大痛点），几乎推翻了原有主题raytaylorism的所有设计，UI上采用全新的Material Design风格，内部结构和配置也重写以提高稳定性。大家看到这篇总结的时候，正是新版博客第一次正式亮相，也意味着hexo主题raytaylorism开始进入内测阶段（目前内测人员已招募完毕）。在内测过程中，我还会继续完善和优化这个项目，并计划推出全新的个人简介页面，等一两周之后再在Github上发布主题，敬请期待。&lt;/p&gt;
&lt;h1 id=&quot;结语&quot;&gt;&lt;a href=&quot;#结语&quot; class=&quot;headerlink&quot; title=&quot;结语&quot;&gt;&lt;/a&gt;结语&lt;/h1&gt;&lt;p&gt;回首上一学期，总体来说还是过得比较愉快和充实。下学期是研究生阶段的最后一个学期，除了正常的修改论文和答辩之外，基本上也没什么事了，所以计划还是以学习为主，毕业旅行为辅。抓紧最后的大段自由时光多打好技术基础，将会是下学期的主旋律。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;好久没有写学期总结了。2015年秋季学期是我研究生阶段的倒数第二个学期，时间线上主要由实习、找工作、学（zhuang）习（bi）和写论文组成。由于这学期找完工作之后导师没有给我安排什么实验室的工作，所以有比较大段的自由时间可以支配。在外人看来我好像这学期过得很悠闲，实际上是在自己的合理安排下过得非常充实，现在写篇简短的文章总结一下。&lt;/p&gt;
    
    </summary>
    
      <category term="日常" scheme="http://raytaylorlin.com/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="日常" scheme="http://raytaylorlin.com/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>使用Markdown来写毕业论文</title>
    <link href="http://raytaylorlin.com/tech/complex/project/write-thesis-using-markdown/"/>
    <id>http://raytaylorlin.com/tech/complex/project/write-thesis-using-markdown/</id>
    <published>2015-12-17T08:17:53.000Z</published>
    <updated>2016-02-09T12:31:39.838Z</updated>
    
    <content type="html">&lt;p&gt;最近很长一段时间没有写博客，主要是因为“学”的时间减少了，但私底下“做”的时间增加了。作为研三的老人，马上就要进入写毕业论文的阶段了，所以最近一直都在准备论文的事情，所所以博客的更新也会稍微缓一缓，估计到放假回家就可以恢复正常了。&lt;/p&gt;
&lt;p&gt;说到准备论文，最近一直都在研究如何使用Markdown来写毕业论文，而本文就是研究成果&lt;a href=&quot;https://github.com/raytaylorlin/hust-graduation-thesis-pandoc&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;hust-graduation-thesis-pandoc&lt;/a&gt;的展示。项目现已放在Github上，欢迎各位使用和反馈。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;实验室以前的学长学姐写毕业论文，都是规规矩矩地在前人的Word文档基础上修改。但是作为一个程序猿，用Word来写论文未免太不够档（zhuang）次（bi）。更重要的是用Word来写论文时，&lt;strong&gt;经常在格式上会出现一些莫名其妙的问题&lt;/strong&gt;，比如保存时明明是好的下次打开时多级标题全错乱了啊，正文的字体有时会突然错乱了啊等等，而且无论怎么调都调不好，最后只能在那气得干瞪眼，然后重新找一份前人“及格”的文档重新编辑。&lt;/p&gt;
&lt;p&gt;当然，科研界的投稿，很多都是用&lt;a href=&quot;https://zh.wikipedia.org/wiki/LaTeX&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Latex&lt;/a&gt;来编写。Latex虽然超级好用，但是学习曲线太陡峭了，并不适合我们这种在一个月内就要写完论文的人士。当然，经过考验的格式编排没有问题的Latex模板网上有很多，一般拿过来直接往里面填充内容就可以了。不管怎么说，除去折腾Latex的安装和模板的制作，直接站在前人的肩膀上使用Latex模板绝对要比使用Word模板靠谱得多。&lt;/p&gt;
&lt;p&gt;但是Latex本身是“内容和样式”混排的，&lt;a href=&quot;https://zh.wikipedia.org/wiki/Markdown&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Markdown&lt;/a&gt;这种简洁优雅只专注于内容的标记语言才是程序猿的最爱。至于用Markdown来写作的优势，此处就不赘述了，懂的人应该都懂的。而最近的研究成果，就是实现了一套方案，既能让人利用Markdown的语法优势快速编写内容，又能利用Latex的强大和稳定，生成漂亮的pdf论文。要注意的是，原生的Markdown提供的功能并不足以胜任论文的编写，因为论文可能会包含公式、表格、交叉引用等等。幸运的是，使用&lt;a href=&quot;http://pandoc.org/README.html#pandocs-markdown&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Pandoc Markdown&lt;/a&gt;这种增强版的Markdown语法，再混编一点点Latex指令，就可以解决我们的问题。&lt;/p&gt;
&lt;p&gt;事实上，早在几年前我的好基友&lt;a href=&quot;https://github.com/pyrocat101&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@pyrocat101&lt;/a&gt;就已经用Markdown完成了他的本科毕业论文。而我的这个项目也是参考了他的项目&lt;a href=&quot;https://github.com/Sicun/hust-thesis-pandoc&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;hust-thesis-pandoc&lt;/a&gt;，同时也略微修改了同系同学&lt;a href=&quot;https://github.com/xu-cheng&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@xu-cheng&lt;/a&gt;提供的&lt;a href=&quot;https://github.com/hust-latex/hustthesis&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;华中科技大学毕业论文Latex模板&lt;/a&gt;，加上自己的一套构建方法而成。所以我也要向这两位伟大的先驱者致敬。&lt;/p&gt;
&lt;p&gt;项目的使用方法和注意事项，Github项目的文档已经写得很清楚了，这里就只简单说下我所做的工作。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;@xu-cheng 提供的Latex模板适用于纯Latex用户，我运行了其提供的&lt;code&gt;makewin32.bat unpack&lt;/code&gt;脚本，从&lt;a href=&quot;https://github.com/hust-latex/hustthesis/blob/master/hustthesis/hustthesis.dtx&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;hustthesis.dtx&lt;/a&gt;模板中提取出了cls和bst文件，这两个才是编写latex时真正要用到的模板。&lt;/li&gt;
&lt;li&gt;用Markdown写一份论文示例，使用&lt;a href=&quot;http://pandoc.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Pandoc&lt;/a&gt;这款工具，将md转换为tex。&lt;/li&gt;
&lt;li&gt;用&lt;a href=&quot;https://www.tug.org/texlive/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Tex Live&lt;/a&gt;提供的&lt;code&gt;xelatex&lt;/code&gt;工具（&lt;code&gt;lualatex&lt;/code&gt;亦可），编译上述tex文件，生成最终的pdf文件。&lt;/li&gt;
&lt;li&gt;参考机油项目中的&lt;a href=&quot;https://github.com/Sicun/hust-thesis-pandoc/blob/master/Makefile&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Makefile&lt;/a&gt;，编写一份&lt;a href=&quot;http://gulpjs.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Gulp&lt;/a&gt;构建脚本，将上述过程自动化。&lt;/li&gt;
&lt;li&gt;将latex模板中的个人信息、摘要、致谢等内容分离出单独的tex文件，并整理整个项目结构。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本项目目前仍处于试验期，我会在写毕业论文期间不断维护这个项目，欢迎各位评测指正。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;最近很长一段时间没有写博客，主要是因为“学”的时间减少了，但私底下“做”的时间增加了。作为研三的老人，马上就要进入写毕业论文的阶段了，所以最近一直都在准备论文的事情，所所以博客的更新也会稍微缓一缓，估计到放假回家就可以恢复正常了。&lt;/p&gt;
&lt;p&gt;说到准备论文，最近一直都在研究如何使用Markdown来写毕业论文，而本文就是研究成果&lt;a href=&quot;https://github.com/raytaylorlin/hust-graduation-thesis-pandoc&quot;&gt;hust-graduation-thesis-pandoc&lt;/a&gt;的展示。项目现已放在Github上，欢迎各位使用和反馈。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="综合" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/"/>
    
      <category term="项目" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="Markdown" scheme="http://raytaylorlin.com/tags/Markdown/"/>
    
      <category term="论文" scheme="http://raytaylorlin.com/tags/%E8%AE%BA%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>网络游戏的基本架构</title>
    <link href="http://raytaylorlin.com/tech/game/server/network-game-architecture/"/>
    <id>http://raytaylorlin.com/tech/game/server/network-game-architecture/</id>
    <published>2015-11-23T08:09:57.000Z</published>
    <updated>2016-02-09T13:12:29.195Z</updated>
    
    <content type="html">&lt;p&gt;游戏的最大价值就是可玩性，为了保持游戏的可玩性，游戏必须具备能够“顺畅进行”的特性，而网游还需要能够“快速响应”。本文前半部分先讨论如何维持网络游戏的可玩性，后半部分说明了网络游戏常用的物理架构（C/S、P2P）和逻辑架构（MO、MMO）。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-网络游戏编程的特性&quot;&gt;&lt;a href=&quot;#1-网络游戏编程的特性&quot; class=&quot;headerlink&quot; title=&quot;1. 网络游戏编程的特性&quot;&gt;&lt;/a&gt;1. 网络游戏编程的特性&lt;/h1&gt;&lt;h2 id=&quot;1-1-游戏客户端的特性&quot;&gt;&lt;a href=&quot;#1-1-游戏客户端的特性&quot; class=&quot;headerlink&quot; title=&quot;1.1 游戏客户端的特性&quot;&gt;&lt;/a&gt;1.1 游戏客户端的特性&lt;/h2&gt;&lt;p&gt;视频游戏的最大特点是：为了最大限度发挥其可玩性，必须流畅地持续进行实时的高速处理，网络游戏程序还必须始终保持高速响应。为了达到这种要求，一般会将实时的数据存放在内存中（而不是在数据库中），这是因为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;游戏数据要在“16毫秒”即1帧这一短暂的时间内持续变化&lt;/li&gt;
&lt;li&gt;需要同时显示大量对象&lt;/li&gt;
&lt;li&gt;不知道玩家会在什么时候进行操作，所以无法事先计算&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-2-网络游戏客户端的特性&quot;&gt;&lt;a href=&quot;#1-2-网络游戏客户端的特性&quot; class=&quot;headerlink&quot; title=&quot;1.2 网络游戏客户端的特性&quot;&gt;&lt;/a&gt;1.2 网络游戏客户端的特性&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;通信延迟低：不同类型的游戏对延迟的要求不同，但均无法避免由地域距离所带来的延迟&lt;/li&gt;
&lt;li&gt;控制带宽传输量：C/S MMO每人10kbit/s~100kbit/s，P2P MO为前者的3倍&lt;/li&gt;
&lt;li&gt;服务器成本估算：C/S MMO每台服务器有1000~3000个并发连接，P2P MO为前者的3~5倍&lt;/li&gt;
&lt;li&gt;安全性：防作弊，放破坏&lt;ol&gt;
&lt;li&gt;动机：纯粹个人利益、与其他玩家相关的利益、与运营公司相关的利益&lt;/li&gt;
&lt;li&gt;作弊手段：内存破解、数据包破解、数据文件破解、时钟破解、UI工具自动模拟、服务器攻击、伪造客户端&lt;/li&gt;
&lt;li&gt;作弊的操作对象：本地内存和文件、其他玩家的内存和文件、数据中心服务器的内存和文件、本地和其他玩家之间的数据包、本地和中心服务器之间的数据包&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;2-物理架构详解&quot;&gt;&lt;a href=&quot;#2-物理架构详解&quot; class=&quot;headerlink&quot; title=&quot;2. 物理架构详解&quot;&gt;&lt;/a&gt;2. 物理架构详解&lt;/h1&gt;&lt;p&gt;主流的网络游戏物理架构，大致可以分为C/S架构和P2P架构。网络拓扑结构主要使用星型（包括总线型）以及全网状结构（每个节点均和其他所有节点连接）。采用这些结构，主要是因为相对于游戏的容错性和吞吐量，优先级最高的还是要把通信延迟降至最低。&lt;/p&gt;
&lt;p&gt;对于C/S架构，又分为纯服务器型和反射型，前者服务器会对各个客户端发送来的数据进行检测，后者只是单纯转发数据。对于P2P架构，有同步和异步两种方式。此外，还有C/S+P2P混合型架构和ad-hoc模式，因为比较少见，不赘述。&lt;/p&gt;
&lt;h1 id=&quot;3-逻辑架构详解&quot;&gt;&lt;a href=&quot;#3-逻辑架构详解&quot; class=&quot;headerlink&quot; title=&quot;3. 逻辑架构详解&quot;&gt;&lt;/a&gt;3. 逻辑架构详解&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;MO（Multiplayer Online）：同时在线人数2~100人，游戏时间较短，一般在几个小时，每次开始游戏时，游戏状态都会被重置，游戏数据时一次性的。适用于FPS、RTS等在线人数较少，实时性很高的游戏。&lt;/li&gt;
&lt;li&gt;MMO（Massively Multiplayer Online）：同时在线人数达数百、数千以上，游戏时间长达几十个小时，也不能重置游戏数据，游戏数据时永久性的。&lt;/li&gt;
&lt;li&gt;MMO和MO混合：根据游戏策划内容，有时需要采用这种混合架构，例如在MMO游戏的某些供少数人在短时间内重复进行游戏的特殊地图，会采用MO架构。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;3-1-MO架构&quot;&gt;&lt;a href=&quot;#3-1-MO架构&quot; class=&quot;headerlink&quot; title=&quot;3.1 MO架构&quot;&gt;&lt;/a&gt;3.1 MO架构&lt;/h2&gt;&lt;h3 id=&quot;3-1-1-同步方式与全网状架构&quot;&gt;&lt;a href=&quot;#3-1-1-同步方式与全网状架构&quot; class=&quot;headerlink&quot; title=&quot;3.1.1 同步方式与全网状架构&quot;&gt;&lt;/a&gt;3.1.1 同步方式与全网状架构&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;参与游戏的所有终端都拥有主数据，这些终端只互相传输所有的控制设备输入信息&lt;/strong&gt;，在获得所有终端的输入数据之前，游戏始终处于等待状态。这种架构要成立，必须满足这些条件：初始状态完全相同；所有输入信息数据包都确确实实毫无遗漏地发送到其他所有终端；游戏过程数据不会随机变化（伪随机数没有问题）；游戏过程数据变化不会发生波动。要满足这些条件并不苦难，但这种架构依旧有如下问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;人数增加后，收发信息完整性极易崩溃。根据“混沌理论”，即使是细微的差异，经过不断重复单纯的规则，最终也会产生截然不同的结果。&lt;/li&gt;
&lt;li&gt;最慢的终端会拖长整体的传输时间（同步方式都会存在）&lt;/li&gt;
&lt;li&gt;不能中途加入游戏（同步方式都会存在）。因为在中途加入游戏的一刻，为了传输游戏状态数据，所有玩家都必须长时间暂停游戏。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;3-1-2-同步方式与星型架构&quot;&gt;&lt;a href=&quot;#3-1-2-同步方式与星型架构&quot; class=&quot;headerlink&quot; title=&quot;3.1.2 同步方式与星型架构&quot;&gt;&lt;/a&gt;3.1.2 同步方式与星型架构&lt;/h3&gt;&lt;p&gt;网络中的一个玩家终端A充当服务器，客户端将控制设备上的输入信息发送至服务器，服务器在接收完所有数据前一直处于等待状态，接收完成后将信息同时发送给所有客户端。这种方式的最大优点就是，所需增加的传输线路与所增加的玩家数成正比，传输线路不会爆发性增长。但依旧有如下问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;响应较慢&lt;/li&gt;
&lt;li&gt;若玩家A中途离线，游戏无法恢复，只能强行终止&lt;/li&gt;
&lt;li&gt;程序结构比全网状结构稍微复杂&lt;/li&gt;
&lt;li&gt;玩家A终端上的传输负荷比其他终端高出很多，不公平&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;3-1-3-异步方式&quot;&gt;&lt;a href=&quot;#3-1-3-异步方式&quot; class=&quot;headerlink&quot; title=&quot;3.1.3 异步方式&quot;&gt;&lt;/a&gt;3.1.3 异步方式&lt;/h3&gt;&lt;p&gt;异步方式下，各个终端的游戏状态是不同的，必须在游戏数据的一致性方面做出妥协。由于这种妥协，异步方式下可以使用更加不稳定和延迟更大的传输线路，也可以支持更多的同时在线数。另一方面，程序相比同步方式会略显复杂，且有些情况下游戏体验更差一些。在实现方面，对游戏数据做出何种妥协完全依赖于游戏的具体内容。异步实现的指导方针是：将游戏世界的基本要素分为三大类，即自己的状态，对手的状态和环境状态。这三大类之间的两两关系又需要分别对待处理，此处不赘述。（具体参见《网络游戏核心技术与实战》3.4.7-3.4.13）&lt;/p&gt;
&lt;h2 id=&quot;3-2-MMO架构——浏览器方式&quot;&gt;&lt;a href=&quot;#3-2-MMO架构——浏览器方式&quot; class=&quot;headerlink&quot; title=&quot;3.2 MMO架构——浏览器方式&quot;&gt;&lt;/a&gt;3.2 MMO架构——浏览器方式&lt;/h2&gt;&lt;p&gt;MMO游戏也被称为“持久的游戏”，因为其累计的游戏时长可能高达数千个小时。为此必须在服务器的内存和磁盘上准确无误地完整地保存各种游戏数据，当玩家需要时瞬间取出来展现给玩家。因为数据一致性方面的要求非常严苛，所以在构建系统时要&lt;strong&gt;将客户端和服务器完全分离&lt;/strong&gt;。在MMO架构中，&lt;strong&gt;客户端将控制设备输入信息发送给服务器，服务器只想客户端发送游戏过程中的结果，客户端则把游戏结果可视化展现给玩家。&lt;/strong&gt;这就是逻辑架构中所谓的浏览器方式。&lt;/p&gt;
&lt;p&gt;在这种架构下，即使没有客户端，游戏也会在服务器上持续运行，所有的逻辑都在服务器上处理，而客户端只进行与渲染、音效、输入有关的处理。&lt;/p&gt;
&lt;p&gt;最后，总结比较一下3种逻辑架构之间的差异：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;浏览器方式和同步方式：最大差异在“传输内容”，即同步方式下收发的都是玩家输入信息（原因），而在浏览器方式下，客户端发送玩家输入信息（原因），服务器发送游戏过程的结果。&lt;/li&gt;
&lt;li&gt;同步方式和异步方式：两种方式下，所有终端都共享游戏过程的所有主数据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考文献：人民邮电出版社《网络游戏核心技术与实战》第3章&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;游戏的最大价值就是可玩性，为了保持游戏的可玩性，游戏必须具备能够“顺畅进行”的特性，而网游还需要能够“快速响应”。本文前半部分先讨论如何维持网络游戏的可玩性，后半部分说明了网络游戏常用的物理架构（C/S、P2P）和逻辑架构（MO、MMO）。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="游戏开发" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
      <category term="服务器端" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF/"/>
    
    
      <category term="网络游戏编程" scheme="http://raytaylorlin.com/tags/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>网络游戏编程基础知识</title>
    <link href="http://raytaylorlin.com/tech/game/server/network-programming/"/>
    <id>http://raytaylorlin.com/tech/game/server/network-programming/</id>
    <published>2015-11-11T02:27:40.000Z</published>
    <updated>2016-02-09T12:31:39.857Z</updated>
    
    <content type="html">&lt;p&gt;本文首先介绍网络游戏开发者需了解的网络编程基础，包括对应的OSI七层分层模型，与游戏架构的关系。然后介绍套接字API及RPC相关的内容。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-开发者需了解的网络编程基础&quot;&gt;&lt;a href=&quot;#1-开发者需了解的网络编程基础&quot; class=&quot;headerlink&quot; title=&quot;1. 开发者需了解的网络编程基础&quot;&gt;&lt;/a&gt;1. 开发者需了解的网络编程基础&lt;/h1&gt;&lt;h2 id=&quot;1-1-网络游戏对应的OSI模型&quot;&gt;&lt;a href=&quot;#1-1-网络游戏对应的OSI模型&quot; class=&quot;headerlink&quot; title=&quot;1.1 网络游戏对应的OSI模型&quot;&gt;&lt;/a&gt;1.1 网络游戏对应的OSI模型&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://raytaylorlin-blog.qiniudn.com/image/server/网络游戏对应的OSI模型.png&quot; alt=&quot;网络游戏对应的OSI模型&quot;&gt;&lt;/p&gt;
&lt;p&gt;一般来说，第4层以下的分层，交由操作系统来处理即可。第4层大多使用TCP，只有在有必要的情况下才使用UDP（例如&lt;strong&gt;发送那些与可靠性相比到达速度更为重要的数据&lt;/strong&gt;（如FPS游戏），实现NAT遍历功能等等）。由于游戏类型和策划内容千差万别无法统一，第5层及以上的功能需要网游开发人员自己实现。&lt;/p&gt;
&lt;h2 id=&quot;1-2-网络编程特性与游戏架构的关系&quot;&gt;&lt;a href=&quot;#1-2-网络编程特性与游戏架构的关系&quot; class=&quot;headerlink&quot; title=&quot;1.2 网络编程特性与游戏架构的关系&quot;&gt;&lt;/a&gt;1.2 网络编程特性与游戏架构的关系&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;C/S架构游戏（C/S MMO、C/S MO）：高性能高功能服务器端编程+一般程度的客户端编程&lt;/li&gt;
&lt;li&gt;P2P架构游戏（P2P MO）：一般程度的服务器编程+高性能高功能呢的客户端编程（因为客户端要扮演服务器的角色）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;高性能高功能服务器的特性：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;小带宽：每秒几次至20几次，达到几百位通信量的持续连接&lt;/li&gt;
&lt;li&gt;极高的连接数：每台服务器需要维持数千至数万个连接&lt;/li&gt;
&lt;li&gt;低延迟：处理并返回结果的延迟，只能在几毫秒至20毫秒以内&lt;/li&gt;
&lt;li&gt;稳定：服务器端保持游戏状态、敌人等可以移动的物体实时地持续行动&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;与服务器端相比，客户端的连接数较少，但是需要进行渲染等重要处理，还必须在延迟很低的情况下进行通信，并应对网络状况的多样性（如防火墙、各ISP的策略间差异等等）。&lt;/p&gt;
&lt;h1 id=&quot;2-套接字API&quot;&gt;&lt;a href=&quot;#2-套接字API&quot; class=&quot;headerlink&quot; title=&quot;2. 套接字API&quot;&gt;&lt;/a&gt;2. 套接字API&lt;/h1&gt;&lt;h2 id=&quot;2-1-网络游戏中的套接字API&quot;&gt;&lt;a href=&quot;#2-1-网络游戏中的套接字API&quot; class=&quot;headerlink&quot; title=&quot;2.1 网络游戏中的套接字API&quot;&gt;&lt;/a&gt;2.1 网络游戏中的套接字API&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/Berkeley%E5%A5%97%E6%8E%A5%E5%AD%97&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;BSD套接字API&lt;/a&gt;（即Scoket API）是为了实现互联网连接而开发的API，是在所有操作系统上进行网络开发的首选。关于套接字API编程基础可见WIKI及网上各种资料。&lt;/p&gt;
&lt;p&gt;使用第4层的套接字API，可以在不具可靠性的IP协议上实现两种类型的通信：一种是&lt;strong&gt;面向连接的流式（Stream）通信&lt;/strong&gt;，在简历了连接的两台主机间维持通信线路畅通，保证通信持续进行；另一种是&lt;strong&gt;无连接的数据报（DGram）通信&lt;/strong&gt;，只进行一次数据报交换，不维持主机间的通信线路。&lt;/p&gt;
&lt;p&gt;套接字API中的&lt;code&gt;accept()&lt;/code&gt;函数在“新的连接请求到来前一直等待着”，显然不能满足网络游戏服务器为多个客户端同时提供服务的要求。为了解决这个问题必须处理多个并发连接，方法大致有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每次连接时启动一个进程：&lt;strong&gt;不可用&lt;/strong&gt;，因为网络游戏中需要多个用户连接实时共享同一个游戏状态&lt;/li&gt;
&lt;li&gt;使用线程并行进行同步处理：&lt;strong&gt;不可用&lt;/strong&gt;，几千个连接启动几千个线程会使服务器性能大幅下降&lt;/li&gt;
&lt;li&gt;异步多重输入输出：使用&lt;code&gt;select&lt;/code&gt;函数事先查询所带的消息（数据及连接请求）是否已经到达，即轮询。（使用&lt;code&gt;poll&lt;/code&gt;及更高速的&lt;code&gt;epoll&lt;/code&gt;函数也可实现同样的功能&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;网络游戏编程中同时处理数千个可移动物体是很平常的，因此客户端和服务器端通常都使用select（或poll/epoll）在&lt;strong&gt;单线程&lt;/strong&gt;中实现简单的&lt;strong&gt;事件驱动&lt;/strong&gt;的&lt;strong&gt;非阻塞&lt;/strong&gt;模式。通过这种模式，还可以充分发挥出&lt;strong&gt;多核&lt;/strong&gt;服务器的性能。&lt;/p&gt;
&lt;p&gt;实现服务器端的最佳程序库是&lt;a href=&quot;http://libevent.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;libevent&lt;/a&gt;，这是一个跨平台的基于事件和回调的库，全世界应用广泛，不管是性能还是稳定性都比较成熟。&lt;/p&gt;
&lt;h2 id=&quot;2-2-多核处理器与网络吞吐量&quot;&gt;&lt;a href=&quot;#2-2-多核处理器与网络吞吐量&quot; class=&quot;headerlink&quot; title=&quot;2.2 多核处理器与网络吞吐量&quot;&gt;&lt;/a&gt;2.2 多核处理器与网络吞吐量&lt;/h2&gt;&lt;p&gt;服务器通常用以太网连接至数据中心的网络中，通信速度为1Gbit。但是网游中经常会发送大量的小数据包，由于以太网在发送IP数据包时会向数据包中添加IP数据意外的信息一起发送，所以实际上应用程序能够使用的带宽要更小。&lt;/p&gt;
&lt;p&gt;根据经验，将理论值的1/10作为基准，1Gbit/s以太网每秒可以发送100MB的数据，能够发送的数据包最好以每秒10W-15W为上限。如果在有10个内核的机器使用1Gbit/s以太网，每个内核可以处理大约1W个数据包，若同时连接数为每个内核1000个连接，则每个连接必须设计为发送频率限制在10次/s以内；或者，安装多个网络适配器，连接4根LAN电缆来实现4倍的吞吐量。&lt;/p&gt;
&lt;h1 id=&quot;3-RPC通信中间件&quot;&gt;&lt;a href=&quot;#3-RPC通信中间件&quot; class=&quot;headerlink&quot; title=&quot;3. RPC通信中间件&quot;&gt;&lt;/a&gt;3. RPC通信中间件&lt;/h1&gt;&lt;p&gt;远程过程调用协议RPC（Remote Procedure Call），将与通信有关的一些复杂细节封装起来，与一般的函数调用形式相同，是确保与远程主机进行简单、安全通信的一种方法。有了RPC，就不需要直接使用复杂的套接字API进行网络编程了。&lt;/p&gt;
&lt;h2 id=&quot;3-1-通信库的必要性&quot;&gt;&lt;a href=&quot;#3-1-通信库的必要性&quot; class=&quot;headerlink&quot; title=&quot;3.1 通信库的必要性&quot;&gt;&lt;/a&gt;3.1 通信库的必要性&lt;/h2&gt;&lt;p&gt;单纯使用套接字API之所以会很复杂，是因为会根据网络状况产生这些问题：不一定能成功收发期望数据，之后需要再次调用；可能会发生错误；发送缓存满了的话，write()函数会等待；发送了不完整的内容。&lt;/p&gt;
&lt;p&gt;套接字API中的send在发送成功前不会阻塞，每次编写错误处理造成的代码重复也是引起很多错误的根源。因此需要一个能独自负责这些工作的程序库，这个库应首先针对网络的IO要求装入缓存中，接着准确地执行，再将数据发送出去直至完成，若一段时间内无法发送则返回错误信息。总而言之，通信库会对诸如&lt;code&gt;send&lt;/code&gt;这样的函数进行封装，并确定像&lt;code&gt;[数据类型代码][数据内容]&lt;/code&gt;的数据格式，来收发数据。&lt;/p&gt;
&lt;h2 id=&quot;3-2-网游中使用的RPC整体结构&quot;&gt;&lt;a href=&quot;#3-2-网游中使用的RPC整体结构&quot; class=&quot;headerlink&quot; title=&quot;3.2 网游中使用的RPC整体结构&quot;&gt;&lt;/a&gt;3.2 网游中使用的RPC整体结构&lt;/h2&gt;&lt;p&gt;RPC的基本原理是在本地模拟远程主机的函数调用，主要通过将数据流进行编码后发送出去，远程主机接收数据并解码，然后调用相应的函数。下图展示了网游中RPC的基本模式。注意到调用侧应用程序调用了&lt;code&gt;attackAtEnemy&lt;/code&gt;函数，该函数定义在源文件“RPC存根代码”中，存根代码是用工具自动生成的，不需要手工编写。其中“123”固定值表示要调用&lt;code&gt;attackAtEnemy&lt;/code&gt;这个函数，“99”表示要攻击id为99的敌人。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://raytaylorlin-blog.qiniudn.com/image/server/网络游戏中使用的RPC模式.jpg&quot; alt=&quot;网络游戏中使用的RPC模式&quot;&gt;&lt;/p&gt;
&lt;p&gt;RPC存根代码文件中调用方和被调用方的函数参数列表必须完全一致，如果有大量函数，应该采用RPC工具来自动生成。通常使用Ruby或Python等很容易进行DSL（领域特定语言）定义的语言来设计&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%8E%A5%E5%8F%A3%E6%8F%8F%E8%BF%B0%E8%AF%AD%E8%A8%80&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;IDL（接口描述语言）&lt;/a&gt;，然后执行脚本生成存根函数的源代码和头文件。&lt;/p&gt;
&lt;h1 id=&quot;4-确保开发效率和可移植性&quot;&gt;&lt;a href=&quot;#4-确保开发效率和可移植性&quot; class=&quot;headerlink&quot; title=&quot;4. 确保开发效率和可移植性&quot;&gt;&lt;/a&gt;4. 确保开发效率和可移植性&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;正式服务器采用Linux，但开发环境则是在Windows下用Visual Studio以高效地开发&lt;/li&gt;
&lt;li&gt;服务器端和客户端在碰撞检测等方面使用相同的游戏处理代码，确保可移植性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了降低操作系统的差异性，需要对以下这些基础API进行封装以保持可移植性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内存管理：malloc几乎在所有的操作系统中都会使用，所以很容易封装&lt;/li&gt;
&lt;li&gt;套接字API：Windows和UNIX系统（包括iOS）有所不同&lt;/li&gt;
&lt;li&gt;线程：封装pthread的基本API即可&lt;/li&gt;
&lt;li&gt;信号：远程管理服务器的情况下需要使用信号，但这是一种可移植性很低的方法，并不推荐&lt;/li&gt;
&lt;li&gt;事件与计时：使用libevent&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;网络编程中，对所有套接字调用select函数进行轮询，对于需要处理的内容执行read和write操作，调用回调函数来逐个处理；在客户端游戏编程中，对所有可移动物体以帧为单位进行轮询，对于需要进行处理的物体调用回调函数来使其行动。因此，无论是服务器端还是客户端，大多使用&lt;strong&gt;单线程&lt;/strong&gt;来完成开发。&lt;/p&gt;
&lt;p&gt;参考文献：人民邮电出版社《网络游戏核心技术与实战》第0章&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;本文首先介绍网络游戏开发者需了解的网络编程基础，包括对应的OSI七层分层模型，与游戏架构的关系。然后介绍套接字API及RPC相关的内容。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="游戏开发" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
      <category term="服务器端" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF/"/>
    
    
      <category term="网络游戏编程" scheme="http://raytaylorlin.com/tags/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Cocos2d-x 3.0绘制系统</title>
    <link href="http://raytaylorlin.com/tech/game/client/cocos2dx-render-system/"/>
    <id>http://raytaylorlin.com/tech/game/client/cocos2dx-render-system/</id>
    <published>2015-09-08T06:55:08.000Z</published>
    <updated>2016-02-09T12:31:39.844Z</updated>
    
    <content type="html">&lt;p&gt;在Cocos2d-x 3.0之前，Cocos2d-x每个元素的绘制逻辑都分布在每个元素内部的draw()方法里，并紧密地依赖UI树的遍历。Cocos2d-x 3.0对绘制部分进行了重构，新的架构将绘制部分从UI树的遍历中分离出来，其设计更优雅、更灵活、更易于扩展。本文将介绍Cocos2d-x 3.0新绘制系统的特点、架构及绘制细节。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-新绘制系统的特点&quot;&gt;&lt;a href=&quot;#1-新绘制系统的特点&quot; class=&quot;headerlink&quot; title=&quot;1. 新绘制系统的特点&quot;&gt;&lt;/a&gt;1. 新绘制系统的特点&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;将绘制逻辑从主循环中分离。&lt;/li&gt;
&lt;li&gt;采用应用程序级别的视口剪裁。如果一个UI元素在场景中的坐标位移视口之外，那么它不会发送任何绘制命令到绘制栈上。&lt;/li&gt;
&lt;li&gt;采用自动批绘制技术。如果一个场景中多个不同类型的UI元素使用相同的纹理，可以只调用一次绘制命令。&lt;/li&gt;
&lt;li&gt;更简单地实现绘制的自定义。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;2-绘制系统概览&quot;&gt;&lt;a href=&quot;#2-绘制系统概览&quot; class=&quot;headerlink&quot; title=&quot;2. 绘制系统概览&quot;&gt;&lt;/a&gt;2. 绘制系统概览&lt;/h1&gt;&lt;p&gt;Cocos2d-x 3.0新绘制系统分为三个阶段：生成绘制命令、对绘制命令进行排序、执行绘制命令。&lt;/p&gt;
&lt;p&gt;首先，通过UI树的遍历给每个元素生成一个RenderCommand（定义了怎样绘制一个UI元素），并将该命令添加到renderer的绘制栈中，如下图所示。接着引擎使用&lt;code&gt;globalZOrder&lt;/code&gt;及元素的遍历顺序对绘制命令进行排序。最后执行绘制命令，对一般的RenderCommand，按顺序执行，对Sprite使用的QuadCommand，若两个命令相邻且使用相同的纹理、着色器等，则会组合成一个命令（即自动批处理）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://raytaylorlin-blog.qiniudn.com/image/game/遍历UI树并将绘制命令发送到绘制栈.png&quot; alt=&quot;遍历UI树并将绘制命令发送到绘制栈&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;2-1-RenderCommand概况&quot;&gt;&lt;a href=&quot;#2-1-RenderCommand概况&quot; class=&quot;headerlink&quot; title=&quot;2.1 RenderCommand概况&quot;&gt;&lt;/a&gt;2.1 RenderCommand概况&lt;/h2&gt;&lt;p&gt;每个RenderCommand实例包含一个&lt;code&gt;globalOrder&lt;/code&gt;属性，用于决定绘制顺序，实际上，它们几乎都来自Node的&lt;code&gt;globalZOrder&lt;/code&gt;属性&lt;/p&gt;
&lt;p&gt;5种RenderCommand类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;QUAD_COMMAND：根据1个纹理和4个顶点绘制一幅图片，所有绘制图片的命令都会调用到这里，处理这个类型命令的代码就是绘制贴图的OpenGL代码。&lt;/li&gt;
&lt;li&gt;GROUP_COMMAND：用于包装多个RenderCommand的集合，可以用来实现子元素剪裁（对应ClippingNode）和绘制子元素到纹理（对应RenderTexture）。&lt;/li&gt;
&lt;li&gt;BATCH_COMMAND：用于绘制一个TextureAtalas，如Label、TileMap。这种类型的命令不能参与自动批绘制。&lt;/li&gt;
&lt;li&gt;CUSTOM_COMMAND：自定义绘制命令&lt;/li&gt;
&lt;li&gt;UNKNOWN_COMMAND：未知绘制命令&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-2-RenderQueue和GroupCommand概况&quot;&gt;&lt;a href=&quot;#2-2-RenderQueue和GroupCommand概况&quot; class=&quot;headerlink&quot; title=&quot;2.2 RenderQueue和GroupCommand概况&quot;&gt;&lt;/a&gt;2.2 RenderQueue和GroupCommand概况&lt;/h2&gt;&lt;p&gt;每个UI元素的RenderCommand会被发送到一个叫RenderQueue的绘制命令栈上，Renderer持有多个RenderQueue（用&lt;code&gt;_renderGroups&lt;/code&gt;来存储）。&lt;strong&gt;但GroupCommand比较特殊，它只指向一个RenderQueue。可以认为一个RenderQueue就是一个GroupCommand，而创建一个GroupCommand时会将其作为一个普通的RenderCommand发送到当前的RenderQueue上，并在Renderer上创建一个新的RenderQueue。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;2-3-RenderCommand的排序&quot;&gt;&lt;a href=&quot;#2-3-RenderCommand的排序&quot; class=&quot;headerlink&quot; title=&quot;2.3 RenderCommand的排序&quot;&gt;&lt;/a&gt;2.3 RenderCommand的排序&lt;/h2&gt;&lt;p&gt;由于每一帧都可能执行数百个RenderCommand，所以Cocos2d-x对此进行了优化，每个RenderQueue只对其包含的&lt;strong&gt;globalOrder非0&lt;/strong&gt;的RenderCommand进行排序，而RenderCommand被添加到RenderQueue中的顺序使由Node的&lt;code&gt;localZOrder&lt;/code&gt;决定的。所以，实际上只需要对少数特殊设置了globalOrder属性的Node进行排序即可。注意，每个RenderQueue实例中实际包含了3个RenderCommand数组，分别存放globalOrder小于0、等于0和大于0的RenderCommand，这样可以最大限度地减少排序的量。&lt;/p&gt;
&lt;h1 id=&quot;3-绘制系统相关机制&quot;&gt;&lt;a href=&quot;#3-绘制系统相关机制&quot; class=&quot;headerlink&quot; title=&quot;3. 绘制系统相关机制&quot;&gt;&lt;/a&gt;3. 绘制系统相关机制&lt;/h1&gt;&lt;h2 id=&quot;3-1-QuadCommand&quot;&gt;&lt;a href=&quot;#3-1-QuadCommand&quot; class=&quot;headerlink&quot; title=&quot;3.1 QuadCommand&quot;&gt;&lt;/a&gt;3.1 QuadCommand&lt;/h2&gt;&lt;p&gt;QuadCommand用于绘制一个或多个矩形区域，每个矩形是一个纹理的一部分。这是最基础的绘制命令，包含了TextureID（使用的纹理）、Shader Program、BlendFunc（混合模式）和Quads（绘制的矩形区域的定义，包括每个点的坐标、颜色和纹理坐标）4部分内容。&lt;/p&gt;
&lt;p&gt;Cocos2d-x使用&lt;code&gt;Renderer::render()&lt;/code&gt;方法进行自动批绘制的过程是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第一次遇到一个QuadCommand时不会理你绘制，而是将其放到一个数组中缓存起来，然后继续迭代&lt;/li&gt;
&lt;li&gt;若遇到第二个RenderCommand仍然是QuadCommand，并且使用相同的Material（纹理、着色器、混合模式等等），则继续添加到缓存数组，若不是，则首先绘制之前的缓存数组的指令。这样就能实现自动合并绘制命令。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如何判断是否是相同的Material？&lt;code&gt;QuadCommand::generateMaterialID()&lt;/code&gt;方法检查是否包含自定义的着色器（包含自定义着色器就不能参与批绘制），如果不包含就使用与着色器名称、纹理名称及混合方程相关的参数计算一个Hash值，Hash值相同表明是相同的Material。&lt;/p&gt;
&lt;h2 id=&quot;3-2-元素可见性&quot;&gt;&lt;a href=&quot;#3-2-元素可见性&quot; class=&quot;headerlink&quot; title=&quot;3.2 元素可见性&quot;&gt;&lt;/a&gt;3.2 元素可见性&lt;/h2&gt;&lt;p&gt;在OpenGL ES的图元装配阶段，渲染管线会对每个图元执行视锥体裁剪操作，位于视锥体之外的图元会被丢弃或裁剪。所谓的自动裁剪（Auto Culling）技术，是在遍历UI树时对Sprite进行位置计算，如果发现其位于屏幕之外，则不会发送绘制命令到Renderer中。Node类还有一个visible属性，用于控制一个元素是否显示，如果为false，则该元素在遍历UI树时会被忽略。&lt;/p&gt;
&lt;p&gt;如果一个应用程序有很大的应用场景，则不应该完全依赖自动裁剪。因为自动裁剪只是减少了绘制命令调用的次数，而这些元素所使用的纹理仍然占据着内存，所以还要注意对纹理内存的管理。&lt;/p&gt;
&lt;h2 id=&quot;3-3-绘制时机&quot;&gt;&lt;a href=&quot;#3-3-绘制时机&quot; class=&quot;headerlink&quot; title=&quot;3.3 绘制时机&quot;&gt;&lt;/a&gt;3.3 绘制时机&lt;/h2&gt;&lt;p&gt;将绘制和UI树遍历分离带来一个问题：我们不知道元素什么时候被绘制了，我们只有等到下一帧才能确定所有绘制命令被执行了。这种机制对一些操作（如RenderTexture需要等到绘制完毕后操作纹理）显得很不方便，一般有两种方法来处理这种情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;注册一个一次性Schedule，在下一帧被执行时读取上一帧的绘制结果，并注销该Schedule。&lt;/li&gt;
&lt;li&gt;若要精确把握绘制时机，可以添加一个CustomCommand，将其func属性重写为不包含GL命令调用的自定义回调。这样只要把CustomCommand放在合适的绘制位置（通过globalOrder或localZOrder来调节）。像RenderTexture中的saveToFile方法就是采用这种方法来控制绘制时机。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;参考文献：电子工业出版社《我所理解的Cocos2d-x》第4章&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在Cocos2d-x 3.0之前，Cocos2d-x每个元素的绘制逻辑都分布在每个元素内部的draw()方法里，并紧密地依赖UI树的遍历。Cocos2d-x 3.0对绘制部分进行了重构，新的架构将绘制部分从UI树的遍历中分离出来，其设计更优雅、更灵活、更易于扩展。本文将介绍Cocos2d-x 3.0新绘制系统的特点、架构及绘制细节。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="游戏开发" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
      <category term="客户端" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
    
    
      <category term="Cocos2d-x" scheme="http://raytaylorlin.com/tags/Cocos2d-x/"/>
    
  </entry>
  
  <entry>
    <title>设计模式六大原则</title>
    <link href="http://raytaylorlin.com/tech/complex/DP/design-pattern-principles/"/>
    <id>http://raytaylorlin.com/tech/complex/DP/design-pattern-principles/</id>
    <published>2015-05-15T12:22:31.000Z</published>
    <updated>2016-02-09T12:31:39.801Z</updated>
    
    <content type="html">&lt;p&gt;设计模式除了常见的23种模式之外，还有六大原则。对这六个原则的遵守并非是和否的问题，而是多和少的问题。制定这六个原则的目的并不是要我们刻板的遵守，而需要根据实际情况灵活运用。&lt;/p&gt;
&lt;p&gt;设计模式经常要涉及到UML类图，这里附上&lt;a href=&quot;http://design-patterns.readthedocs.org/zh_CN/latest/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;图说设计模式&lt;/a&gt;中的一章&lt;a href=&quot;http://design-patterns.readthedocs.org/zh_CN/latest/read_uml.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;看懂UML类图和时序图&lt;/a&gt;，以方便快速复习UML类图中各种符号的含义。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-单一职责原则（SRP&quot;&gt;&lt;a href=&quot;#1-单一职责原则（SRP&quot; class=&quot;headerlink&quot; title=&quot;1. 单一职责原则（SRP)&quot;&gt;&lt;/a&gt;1. 单一职责原则（SRP)&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;定义： 就一个类而言，应该仅有一个引起它变化的原因。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意向不到的破坏。如果能够想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责。&lt;/p&gt;
&lt;h1 id=&quot;2-里氏替换原则&quot;&gt;&lt;a href=&quot;#2-里氏替换原则&quot; class=&quot;headerlink&quot; title=&quot;2. 里氏替换原则&quot;&gt;&lt;/a&gt;2. 里氏替换原则&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;定义：子类必须能够替换掉它们的父类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;软件里把父类替换成它的子类，程序的行为没有变化。只有当子类可以替换掉父类，软件单位的功能不受到影响时，父类才能真正被复用，而子类也能够在父类的基础上增加新的行为。&lt;/p&gt;
&lt;p&gt;例子：一个鸟类，一个企鹅类。鸟有“飞”的行为，企鹅不会飞，所以企鹅不能以父类——鸟的身份出现，即企鹅类不能继承鸟类。&lt;/p&gt;
&lt;h1 id=&quot;3-依赖倒置原则&quot;&gt;&lt;a href=&quot;#3-依赖倒置原则&quot; class=&quot;headerlink&quot; title=&quot;3. 依赖倒置原则&quot;&gt;&lt;/a&gt;3. 依赖倒置原则&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;定义：高层模块不应该依赖底层模块，两者都应该依赖抽象；抽象不应该依赖细节，细节应该依赖抽象。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;要针对接口编程，不要对实现编程。在Java或C#语言中的表现就是：实现类之间不发生直接的依赖关系，依赖关系是通过接口产生的。依赖倒置是面向对象设计的标志，如果程序中所有的依赖关系都终止于抽象类或接口，就是面向对象的设计。&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;CPU、内存等都是针对接口设计的，如果针对实现来设计，内存就要对应到具体的某个品牌的主板，就会出现换内存也要把主板换了的尴尬。&lt;/li&gt;
&lt;li&gt;做项目大多要访问数据库，把访问数据库的代码写成函数，每次做新项目时去调用这些函数，这就叫高层模块依赖低层模块。做新项目时，发现业务逻辑的高层模块都是一样的额，但客户却希望使用不同的数据库，高层模块与低层的访问数据库绑定在一起，没办法复用高层模块。应该两者都依赖约定的接口。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;4-接口隔离原则&quot;&gt;&lt;a href=&quot;#4-接口隔离原则&quot; class=&quot;headerlink&quot; title=&quot;4. 接口隔离原则&quot;&gt;&lt;/a&gt;4. 接口隔离原则&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;定义：客户端不应该依赖它不需要的接口（接口尽量细化），类见的依赖关系应该建立在最小的接口上。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接口“小”是要有限度的，首先不能违反单一职责原则，其次是要高内聚。一个接口只服务于一个子模块或业务逻辑，通过业务逻辑压缩接口中的public方法。&lt;/p&gt;
&lt;h1 id=&quot;5-迪米特法则&quot;&gt;&lt;a href=&quot;#5-迪米特法则&quot; class=&quot;headerlink&quot; title=&quot;5. 迪米特法则&quot;&gt;&lt;/a&gt;5. 迪米特法则&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;定义：如果两个类不必彼此直接通信，那么这两个类就不应该发生直接的相互作用。一个对象应该对其他对象有最少的了解。&lt;/strong&gt;如果一个类需要调用另一个类的某一个方法，可以通过第三者转发这个调用。&lt;/p&gt;
&lt;p&gt;该法则的根本思想，是强调了类之间的松耦合。一个类公开的public属性或方法越多，修改时涉及的面和风险也就越大。在设计时需要反复衡量：是否还可以再减少public方法和属性。&lt;em&gt;实践中，如果一个类跳转两次以上才能访问到另一个类，就说明系统过于复杂，需要想办法进行重构了。&lt;/em&gt;&lt;/p&gt;
&lt;h1 id=&quot;6-开闭原则&quot;&gt;&lt;a href=&quot;#6-开闭原则&quot; class=&quot;headerlink&quot; title=&quot;6. 开闭原则&quot;&gt;&lt;/a&gt;6. 开闭原则&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;定义：软件实体（类、模块、函数等等）应该可以扩展开放，对修改封闭。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;面对需求变化，对程序的改动是通过增加新代码进行的，而不是更改现有的代码。但在最初编写代码时，难以预测到变化的产生，这就要求变化发生时，就创建抽象来隔离以后发生的同类变化。开发人员应该仅对程序中呈现出频繁变化的那些部分作出抽象，拒绝不成熟的抽象和抽象本身一样重要。&lt;/p&gt;
&lt;p&gt;例子：书店管理图书，&lt;code&gt;IBook&lt;/code&gt;接口有&lt;code&gt;getName&lt;/code&gt;、&lt;code&gt;getPrice&lt;/code&gt;、&lt;code&gt;getAuthor&lt;/code&gt;方法，实现类&lt;code&gt;NovelBook&lt;/code&gt;实现&lt;code&gt;IBook&lt;/code&gt;接口，客户端类&lt;code&gt;BookStore&lt;/code&gt;关联&lt;code&gt;IBook&lt;/code&gt;接口。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当&lt;em&gt;获取原价格&lt;/em&gt;的业务变化成&lt;em&gt;获取打折处理后的价格&lt;/em&gt;时，应该扩展一个子类（继承&lt;code&gt;NovelBook&lt;/code&gt;）&lt;code&gt;OffNovelBook&lt;/code&gt;，覆写&lt;code&gt;getPrice&lt;/code&gt;方法来获取打折价格。&lt;/li&gt;
&lt;li&gt;若要新增一种计算机类图书，且可以获取其领域，可以新增&lt;code&gt;IComputerBook&lt;/code&gt;接口继承&lt;code&gt;IBook&lt;/code&gt;，其中包含&lt;code&gt;getScope&lt;/code&gt;方法，再增加一个&lt;code&gt;ComputerBook&lt;/code&gt;实现类。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最后总结一下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单一职责原则告诉我们实现类要职责单一&lt;/li&gt;
&lt;li&gt;里氏替换原则告诉我们不要破坏继承体系&lt;/li&gt;
&lt;li&gt;依赖倒置原则告诉我们要面向接口编程&lt;/li&gt;
&lt;li&gt;接口隔离原则告诉我们在设计接口的时候要精简单一&lt;/li&gt;
&lt;li&gt;迪米特法则告诉我们要降低耦合&lt;/li&gt;
&lt;li&gt;开闭原则是总纲，它告诉我们要对扩展开放，对修改关闭&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考文献：《设计模式之禅（第2版）》第1-6章、《大话设计模式》&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;设计模式除了常见的23种模式之外，还有六大原则。对这六个原则的遵守并非是和否的问题，而是多和少的问题。制定这六个原则的目的并不是要我们刻板的遵守，而需要根据实际情况灵活运用。&lt;/p&gt;
&lt;p&gt;设计模式经常要涉及到UML类图，这里附上&lt;a href=&quot;http://design-patterns.readthedocs.org/zh_CN/latest/index.html&quot;&gt;图说设计模式&lt;/a&gt;中的一章&lt;a href=&quot;http://design-patterns.readthedocs.org/zh_CN/latest/read_uml.html&quot;&gt;看懂UML类图和时序图&lt;/a&gt;，以方便快速复习UML类图中各种符号的含义。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="综合" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/"/>
    
      <category term="设计模式" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BB%BC%E5%90%88/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://raytaylorlin.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Lua学习笔记（7）——面向对象编程</title>
    <link href="http://raytaylorlin.com/tech/language/lua/lua-note-7/"/>
    <id>http://raytaylorlin.com/tech/language/lua/lua-note-7/</id>
    <published>2015-05-11T03:10:08.000Z</published>
    <updated>2016-02-09T12:31:39.898Z</updated>
    
    <content type="html">&lt;p&gt;Lua中的table就是一种对象，因为它和对象一样可以拥有状态，也拥有一个独立于其值的标识（一个self），也和对象一样具有独立于创建者的生命周期。但是Lua中没有类的概念，只能用元表来实现原型，用原型来模拟类和继承等面向对象特性。本文将介绍Lua关于面向对象编程的内容。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-对象与类&quot;&gt;&lt;a href=&quot;#1-对象与类&quot; class=&quot;headerlink&quot; title=&quot;1. 对象与类&quot;&gt;&lt;/a&gt;1. 对象与类&lt;/h1&gt;&lt;h2 id=&quot;1-1-self与冒号语法&quot;&gt;&lt;a href=&quot;#1-1-self与冒号语法&quot; class=&quot;headerlink&quot; title=&quot;1.1 self与冒号语法&quot;&gt;&lt;/a&gt;1.1 self与冒号语法&lt;/h2&gt;&lt;p&gt;使用self参数是所有面向对象语言的一个核心，Lua只需使用冒号语法，就能隐藏该参数，例如下面两段代码是等价的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Account = {balance=0}
funtion Account.withdraw(self, v)
    self.balance = self.balance - v
end
a1 = Account; Account = nil
a1.withdraw(a1, 100.0)  -- 注意这是可以运行的

function Account:withdraw(v)
    self.balance = self.balance - v
end
a2 = Account
a2:withdraw(100.0)  -- 省略了a2参数传入
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;1-2-类的编写&quot;&gt;&lt;a href=&quot;#1-2-类的编写&quot; class=&quot;headerlink&quot; title=&quot;1.2 类的编写&quot;&gt;&lt;/a&gt;1.2 类的编写&lt;/h2&gt;&lt;p&gt;在一些基于原型的语言中，对象是没有类型的，但每个对象都有一个原型。原型是一种常规的对象，当其他对象遇到一个未知操作时，原型会先查找它。在这种语言中要表示一个类，只需创建一个专用做其他对象的原型。Lua中实现原型很简单，只需用元表的&lt;code&gt;__index&lt;/code&gt;来实现继承。&lt;/p&gt;
&lt;p&gt;（当访问一个table中不存在的字段key时，一般得到结果为nil。事实上，访问会促使解释器去查找一个叫&lt;code&gt;__index&lt;/code&gt;的元方法，如果没有这个元方法，则访问结果如前述的nil，否则由这个元方法来提供结果。元方法除了是一个函数，还可以是一个table，如果是table则直接返回该table中key对应的内容。）&lt;/p&gt;
&lt;p&gt;如果有两个对象a和b，要让b作为a的一个原型，只需&lt;code&gt;setmetatable(a, {__index=b})&lt;/code&gt;。a就会在b中查找它没有的操作。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function Account:new(o)
    o = o or {}  -- 如果用户没有提供table，则创建一个
    setmetatable(o, self)
    self.__index = self
    return o
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当调用&lt;code&gt;a = Account:new{balance = 0}&lt;/code&gt;时，a会将Account（函数中的self）作为其元表。当调用&lt;code&gt;a:withdraw(100.0)&lt;/code&gt;时，Lua无法在table a中找到条目withdraw，则进一步搜索元表的&lt;code&gt;__index&lt;/code&gt;条目，即&lt;code&gt;getmetatable(a).__index.withdraw(a, 100.0)&lt;/code&gt;。由于new方法中做了&lt;code&gt;self.__index = self&lt;/code&gt;，所以上面的表达式又等价于&lt;code&gt;Account.withdraw(a, 100.0)&lt;/code&gt;，这样就传入了a作为self参数，又调用了Account类的withdraw函数。&lt;strong&gt;这种创建对象的方式不仅可以作用于方法，还可以作用于所有其他新对象中没有的字段。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-3-继承&quot;&gt;&lt;a href=&quot;#1-3-继承&quot; class=&quot;headerlink&quot; title=&quot;1.3 继承&quot;&gt;&lt;/a&gt;1.3 继承&lt;/h2&gt;&lt;p&gt;现在要从Account类派生出一个子类SpecialAccount（以使客户能够透支），只需：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SpecialAccount = Account:new()
s = SpecialAccount:new{limit=1000.00}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;SpecialAccount从Account继承了new，当执行&lt;code&gt;SpecialAccount:new&lt;/code&gt;时，其self参数为SpecialAccount，因此s的元表为SpecialAccount。当调用s不存在的字段时，会向上查找，也可以编写新的重名方法覆盖父类方法。&lt;/p&gt;
&lt;h2 id=&quot;1-4-多重继承&quot;&gt;&lt;a href=&quot;#1-4-多重继承&quot; class=&quot;headerlink&quot; title=&quot;1.4 多重继承&quot;&gt;&lt;/a&gt;1.4 多重继承&lt;/h2&gt;&lt;p&gt;上面介绍中为&lt;code&gt;__index&lt;/code&gt;元方法赋值一个table实现了单继承，如果要实现多重继承，可以让&lt;code&gt;__index&lt;/code&gt;字段成为一个函数，在该函数中搜索多个基类的方法字段。由于这种搜索具有一定复杂性，多重继承的性能不如单一继承。还有一种改进性能的简单做法是将继承的方法复制到子类中，但这种做法的缺点是当系统运行后就较难修改方法的定义，因为这些修改不会沿着继承体系向下传播。&lt;/p&gt;
&lt;h2 id=&quot;1-5-私密性&quot;&gt;&lt;a href=&quot;#1-5-私密性&quot; class=&quot;headerlink&quot; title=&quot;1.5 私密性&quot;&gt;&lt;/a&gt;1.5 私密性&lt;/h2&gt;&lt;p&gt;Lua在设计对象时，没有提供私密性机制（private），但其各种元机制使得程序员可以模拟对象的访问控制。这种实现不常用，因此只做基本的了解：通过两个table来表示一个对象，一个用来保存对象的状态，一个用于对象的操作（即接口）。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function newAccount(initialBalance)
    local self = {balance = initialBalance}
    local withdraw = function(v)
        self.balance = self.balance -v
    end
    return {
        withdraw = withdraw
    }
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通过闭包的方式，将具有私密性的字段（如balance）保存在self table中，并只公开了withdraw接口，这样就能实现私密性机制。&lt;/p&gt;
&lt;p&gt;参考文献：电子工业出版社《Lua程序设计（第2版）》第16章&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Lua中的table就是一种对象，因为它和对象一样可以拥有状态，也拥有一个独立于其值的标识（一个self），也和对象一样具有独立于创建者的生命周期。但是Lua中没有类的概念，只能用元表来实现原型，用原型来模拟类和继承等面向对象特性。本文将介绍Lua关于面向对象编程的内容。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="编程语言" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Lua" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/"/>
    
    
      <category term="Lua" scheme="http://raytaylorlin.com/tags/Lua/"/>
    
  </entry>
  
  <entry>
    <title>Lua学习笔记（6）——环境与模块</title>
    <link href="http://raytaylorlin.com/tech/language/lua/lua-note-6/"/>
    <id>http://raytaylorlin.com/tech/language/lua/lua-note-6/</id>
    <published>2015-05-10T02:39:41.000Z</published>
    <updated>2016-02-09T12:31:39.892Z</updated>
    
    <content type="html">&lt;p&gt;模块就是一个程序库，而包是一系列模块。Lua中可以通过require来加载模块，然后得到一个全局变量表示一个table。Lua将其所有的全局变量保存在一个被称为“环境”的常规table中。本文首先介绍环境的一些实用技术，然后介绍如何引用模块及编写模块的基本方法。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-环境&quot;&gt;&lt;a href=&quot;#1-环境&quot; class=&quot;headerlink&quot; title=&quot;1. 环境&quot;&gt;&lt;/a&gt;1. 环境&lt;/h1&gt;&lt;p&gt;Lua将环境table保存在一个全局变量&lt;code&gt;_G&lt;/code&gt;中，可以对其访问和设置。有时我们想操作一个全局变量，而它的名称却存储在另一个变量中，或者需要通过运行时的计算才能得到，可以通过&lt;code&gt;value = _G[varname]&lt;/code&gt;来获得动态名字的全局变量。&lt;/p&gt;
&lt;p&gt;关于“环境”的一大问题是它是全局的，任何对它的修改都会影响程序的所有部分。Lua 5允许每个函数拥有一个子集的环境来查找全局变量，可以通过&lt;code&gt;setfenv&lt;/code&gt;来改变一个函数的环境，第一个参数若是1则表示当前函数，2则表示调用当前函数的函数（依次类推），第二个参数是一个新的环境table。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;a = 1
setfenv(1, {})
print(a) -- 会报错，print是一个nil。这是因为一旦改变环境，所有的全局访问都会使用新的table
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;为了避免上述问题，可以使用&lt;code&gt;setfenv(1, {_G = _G})&lt;/code&gt;将原来的环境保存起来，然后用&lt;code&gt;_G.print&lt;/code&gt;来引用。另一种组装新环境的方法是使用继承，下面的代码新环境从源环境中继承了print和a，任何赋值都发生在新的table中。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;a = 1
local newgt = {}
setmetatable(newgt, {__index = _G})
setfenv(1, newgt)
print(a)
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;2-模块与包&quot;&gt;&lt;a href=&quot;#2-模块与包&quot; class=&quot;headerlink&quot; title=&quot;2. 模块与包&quot;&gt;&lt;/a&gt;2. 模块与包&lt;/h1&gt;&lt;h2 id=&quot;2-1-调用模块&quot;&gt;&lt;a href=&quot;#2-1-调用模块&quot; class=&quot;headerlink&quot; title=&quot;2.1 调用模块&quot;&gt;&lt;/a&gt;2.1 调用模块&lt;/h2&gt;&lt;p&gt;要调用模块mod中的foo方法，可以用&lt;code&gt;require&lt;/code&gt;函数来加载，如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;require &amp;quot;mod&amp;quot;
mod.foo()
-- 或者
local m = require &amp;quot;mod&amp;quot;
m.foo()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;require&lt;/code&gt;函数的行为： （关于require使用的路径查找策略不赘述）&lt;br&gt;在&lt;code&gt;package.loaded&lt;/code&gt;这个table中检查模块是否已加载&lt;br&gt;=&amp;gt; 已加载，就返回相应的值（可见一个模块只会加载一次）&lt;br&gt;=&amp;gt; 未加载，就试着在&lt;code&gt;package.preload&lt;/code&gt;中查询传入的模块名&lt;br&gt;===&amp;gt; 找到一个函数，就以该函数作为模块的加载器&lt;br&gt;===&amp;gt; 找不到，则尝试从Lua文件或C程序库中加载模块&lt;br&gt;=====&amp;gt; 找到Lua文件，通过&lt;code&gt;loadfile&lt;/code&gt;来加载文件&lt;br&gt;=====&amp;gt; 找到C程序库，通过&lt;code&gt;loadlib&lt;/code&gt;来加载文件&lt;/p&gt;
&lt;h2 id=&quot;2-2-使用环境&quot;&gt;&lt;a href=&quot;#2-2-使用环境&quot; class=&quot;headerlink&quot; title=&quot;2.2 使用环境&quot;&gt;&lt;/a&gt;2.2 使用环境&lt;/h2&gt;&lt;p&gt;下面的代码说明了如何用环境来创建一个复数（complex）模块：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-- 模块设置
local modname = &amp;quot;complex&amp;quot;
local M = {}
_G[modname] = M
package.loaded[modname] = M

-- 声明模块从外界所需的所有东西
local _G = _G  -- 保留旧环境的引用，使用时需要像_G.print这样用
local io = io

-- 运行这句之后环境就变了
setfenv(1, M)

function new(r, i) return {r=r, i=i} end

function add(c1, c2)
    return new(c1.r + c2.r, c1.i + c2.i)
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样声明函数add时，就成为了&lt;code&gt;complex.add&lt;/code&gt;，调用同一模块的其他函数也不需要加前缀。&lt;/p&gt;
&lt;h2 id=&quot;2-3-module函数&quot;&gt;&lt;a href=&quot;#2-3-module函数&quot; class=&quot;headerlink&quot; title=&quot;2.3 module函数&quot;&gt;&lt;/a&gt;2.3 module函数&lt;/h2&gt;&lt;p&gt;Lua 5.1提供了一个新函数&lt;code&gt;module&lt;/code&gt;，囊括了上面一系列定义环境的功能。在开始编写一个模块时，可以直接用&lt;code&gt;module(&amp;quot;modname&amp;quot;, package.seeall)&lt;/code&gt;来取代前面的设置代码。在一个模块文件开头有这句调用后，后续所有代码都不需要限定模块名和外部名字，同样也不需要返回模块table了。&lt;/p&gt;
&lt;h2 id=&quot;2-4-子模块与包&quot;&gt;&lt;a href=&quot;#2-4-子模块与包&quot; class=&quot;headerlink&quot; title=&quot;2.4 子模块与包&quot;&gt;&lt;/a&gt;2.4 子模块与包&lt;/h2&gt;&lt;p&gt;Lua支持具有层级的模块名，用一个点来分隔名称中的层级。例如一个模块名为&lt;code&gt;mod.sub&lt;/code&gt;，就是mod的一个子模块。一个包（package）就是一个完整的模块树，它是Lua中发型的单位。注意，当搜索一个子模块文件时，require会把点号当做目录分隔符来搜索，也就是说调用&lt;code&gt;require &amp;quot;a.b&amp;quot;&lt;/code&gt;会尝试打开&lt;code&gt;./a/b.lua&lt;/code&gt;，&lt;code&gt;/usr/local/lua/a/b.lua&lt;/code&gt;，&lt;code&gt;/usr/local/lua/a/b/init.lua&lt;/code&gt;。通过这种加载策略，可以将包的所有模块组织到一个目录中。&lt;/p&gt;
&lt;p&gt;参考文献：电子工业出版社《Lua程序设计（第2版）》第14-15章&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;模块就是一个程序库，而包是一系列模块。Lua中可以通过require来加载模块，然后得到一个全局变量表示一个table。Lua将其所有的全局变量保存在一个被称为“环境”的常规table中。本文首先介绍环境的一些实用技术，然后介绍如何引用模块及编写模块的基本方法。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="编程语言" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Lua" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/"/>
    
    
      <category term="Lua" scheme="http://raytaylorlin.com/tags/Lua/"/>
    
  </entry>
  
  <entry>
    <title>Lua学习笔记（5）——迭代器，错误处理</title>
    <link href="http://raytaylorlin.com/tech/language/lua/lua-note-5/"/>
    <id>http://raytaylorlin.com/tech/language/lua/lua-note-5/</id>
    <published>2015-05-07T05:05:11.000Z</published>
    <updated>2016-02-09T12:31:39.886Z</updated>
    
    <content type="html">&lt;p&gt;本文首先介绍如何编写适用于泛型for的迭代器，再介绍Lua的编译、执行与错误处理相关的内容。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-迭代器&quot;&gt;&lt;a href=&quot;#1-迭代器&quot; class=&quot;headerlink&quot; title=&quot;1. 迭代器&quot;&gt;&lt;/a&gt;1. 迭代器&lt;/h1&gt;&lt;h2 id=&quot;1-1-泛型for原理&quot;&gt;&lt;a href=&quot;#1-1-泛型for原理&quot; class=&quot;headerlink&quot; title=&quot;1.1 泛型for原理&quot;&gt;&lt;/a&gt;1.1 泛型for原理&lt;/h2&gt;&lt;p&gt;迭代器是一种可以遍历集合中所有元素的机制，在Lua中通常将迭代器表示为函数，每调用一次函数，就返回集合中“下一个”元素。每个迭代器都需要在每次成功调用之间保持一些状态，这样才能知道它所在的位置及如何步进到下一个位置，closure就可以完成此项工作。下面的示例是列表的一个简单的迭代器：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function values(t)
    local i = 0
    return function() i = i + 1; return t[i] end
end

-- 循环调用
t = {10, 20, 30}
iter = values(t)
while true do
    local el = iter()
    if el == nil then break end
    print(el)
end

-- 泛型for调用
for el in values(t) do print(el) end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;泛型for为一次迭代循环做了所有的簿记工作。它在内部保存了迭代器函数，并在每次迭代时调用迭代器，在迭代器返回nil时结束循环。实际上泛型for保存了3个值：迭代器函数f、恒定状态s、控制变量a。&lt;strong&gt;for做的第一件事就是对in后面的表达式求值，并返回3个值供for保存；接着for会以s和a来调用f。在循环过程中控制变量的值依次为&lt;code&gt;a1 = f(s, a0)&lt;/code&gt;，&lt;code&gt;a2 = f(s, a1)&lt;/code&gt;，依次类推，直至ai为nil结束循环。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-2-迭代器的状态&quot;&gt;&lt;a href=&quot;#1-2-迭代器的状态&quot; class=&quot;headerlink&quot; title=&quot;1.2 迭代器的状态&quot;&gt;&lt;/a&gt;1.2 迭代器的状态&lt;/h2&gt;&lt;p&gt;无状态的迭代器本身不保存任何状态，for循环只会用恒定状态和控制变量来调用迭代器函数。这类迭代器典型例子就是ipairs，下面是ipairs的Lua实现：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;local function iter(s, i)
    i = i + 1
    local v = s[i]
    if v then return i, v end
end
function ipairs(s)
    return iter, s, 0
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当for循环调用ipairs(list)时，会获得3个值，然后Lua调用iter(list, 0)得到list, list[1]，调用iter(list, 1)得到list, list[2]，知道得到一个nil为止。&lt;/p&gt;
&lt;p&gt;虽然泛型for只提供一个恒定状态和一个控制变量用于状态的保存，但有时需要保存许多其他状态。这时可以用closure来保存，或者将所需的状态打包为一个table，并保存在恒定状态中。&lt;/p&gt;
&lt;h1 id=&quot;2-编译与错误机制&quot;&gt;&lt;a href=&quot;#2-编译与错误机制&quot; class=&quot;headerlink&quot; title=&quot;2. 编译与错误机制&quot;&gt;&lt;/a&gt;2. 编译与错误机制&lt;/h1&gt;&lt;h2 id=&quot;2-1-编译&quot;&gt;&lt;a href=&quot;#2-1-编译&quot; class=&quot;headerlink&quot; title=&quot;2.1 编译&quot;&gt;&lt;/a&gt;2.1 编译&lt;/h2&gt;&lt;p&gt;尽管Lua是一种解释型语言，但它确实允许在运行代码前，先将代码预编译为一种中间形式。其实，&lt;strong&gt;区别解释型语言的主要特征并不在于是否能编译它们，而在于编译器是否是语言运行时库的一部分，即是否有能力执行动态生成的代码。&lt;/strong&gt;可以说正因为存在了诸如&lt;code&gt;dofile&lt;/code&gt;这样的函数，才可以将Lua称为解释型语言。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dofile&lt;/code&gt;用于运行Lua代码块，而&lt;code&gt;loadfile&lt;/code&gt;会从一个文件加载Lua代码块，然后编译代码，把编译结果作为一个函数返回。要注意&lt;code&gt;loadfile&lt;/code&gt;不会引发错误，它只是返回错误值但不处理错误。&lt;code&gt;dofile&lt;/code&gt;的基本原理如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function dofile(filename)
    local f = assert(loadfile(filename))
    return f()
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;loadstring&lt;/code&gt;是从一个字符串读取代码，并返回一个对应的函数。注意，&lt;code&gt;loadstring&lt;/code&gt;总是在全局环境中编译它的字符串。此外，这些函数不会带来任何副作用，它们只是将程序块编译为一种中间表示，然后将结果作为一个匿名函数返回。此时如果不将此匿名函数赋值给一个变量并调用，是不会产生任何结果的。&lt;/p&gt;
&lt;h2 id=&quot;2-2-错误处理与异常&quot;&gt;&lt;a href=&quot;#2-2-错误处理与异常&quot; class=&quot;headerlink&quot; title=&quot;2.2 错误处理与异常&quot;&gt;&lt;/a&gt;2.2 错误处理与异常&lt;/h2&gt;&lt;p&gt;Lua遇到任何非预期条件都会引发一个错误，我们也可以显式地调用&lt;code&gt;error&lt;/code&gt;函数并传入一个错误消息得参数来引发一个错误。像&lt;code&gt;if not &amp;lt;condition&amp;gt; then error(&amp;lt;anything&amp;gt;) end&lt;/code&gt;这样的组合是非常通用的代码，所以可以用&lt;code&gt;assert(&amp;lt;condition&amp;gt;, &amp;lt;msg&amp;gt;)&lt;/code&gt;来完成此类工作。另外一种处理的方式是返回错误代码（如nil）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pcall&lt;/code&gt;函数以一种“保护模式”来调用它的第一个参数，并捕获所有执行中引发的错误。如果没有发生错误，pcall会返回true及函数调用的返回值，否则返回false及错误消息。因此可以用error来抛出一个异常或使用pcall来捕获异常，错误消息则可以标识出错误的类型或内容。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if pcall(function()
    &amp;lt;受保护的代码&amp;gt;
end) then
    &amp;lt;常规代码&amp;gt;
else
    &amp;lt;错误处理代码&amp;gt;
end
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;2-3-追溯错误&quot;&gt;&lt;a href=&quot;#2-3-追溯错误&quot; class=&quot;headerlink&quot; title=&quot;2.3 追溯错误&quot;&gt;&lt;/a&gt;2.3 追溯错误&lt;/h2&gt;&lt;p&gt;当&lt;code&gt;pcall&lt;/code&gt;返回其错误消息时，它已经销毁了调用栈的部分内容（pcall到错误发生点之间的这部分调用）。而&lt;code&gt;xpcall&lt;/code&gt;函数除了接受一个需要被调用的函数外，还接受一个&lt;em&gt;错误处理函数&lt;/em&gt;。当发生错误时，Lua会在调用栈展开前调用这个错误处理函数，里面可以用debug库来获取错误的额外信息。如&lt;code&gt;debug.debug&lt;/code&gt;会提供一个Lua提示符，让用户检查错误原因，&lt;code&gt;debug.traceback&lt;/code&gt;获取当前执行的调用栈。&lt;/p&gt;
&lt;p&gt;参考文献：电子工业出版社《Lua程序设计（第2版）》第7-8章&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;本文首先介绍如何编写适用于泛型for的迭代器，再介绍Lua的编译、执行与错误处理相关的内容。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="编程语言" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Lua" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/"/>
    
    
      <category term="Lua" scheme="http://raytaylorlin.com/tags/Lua/"/>
    
  </entry>
  
  <entry>
    <title>Lua学习笔记（4）——函数</title>
    <link href="http://raytaylorlin.com/tech/language/lua/lua-note-4/"/>
    <id>http://raytaylorlin.com/tech/language/lua/lua-note-4/</id>
    <published>2015-05-06T05:05:11.000Z</published>
    <updated>2016-02-09T12:31:39.881Z</updated>
    
    <content type="html">&lt;p&gt;本文介绍了Lua的函数，包括多重返回值、变长参数、具名实参，以及比较高级的主题如闭包、递归的尾调用等等。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-基础知识&quot;&gt;&lt;a href=&quot;#1-基础知识&quot; class=&quot;headerlink&quot; title=&quot;1. 基础知识&quot;&gt;&lt;/a&gt;1. 基础知识&lt;/h1&gt;&lt;p&gt;调用函数都需要写圆括号，即使没有参数，但有一种特殊例外：函数若只有一个参数且参数是字面字符串或table构造式，则圆括号可有可无，如&lt;code&gt;dofile &amp;#39;a.lua&amp;#39;&lt;/code&gt;，&lt;code&gt;f{x=10, y=20}&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;Lua为面向对象式的调用提供冒号操作符的特殊语法，如&lt;code&gt;o.foo(o, x)&lt;/code&gt;等价于&lt;code&gt;o:foo(x)&lt;/code&gt;。和Javascript类似，调用函数时提供的实参数量可以与形参数量不同，若实参多了则舍弃，不足则多余的形参初始化为nil。&lt;/p&gt;
&lt;h2 id=&quot;1-1-多重返回值&quot;&gt;&lt;a href=&quot;#1-1-多重返回值&quot; class=&quot;headerlink&quot; title=&quot;1.1 多重返回值&quot;&gt;&lt;/a&gt;1.1 多重返回值&lt;/h2&gt;&lt;p&gt;Lua允许函数返回多个结果，函数返回如&lt;code&gt;return max, index&lt;/code&gt;，接收如&lt;code&gt;s, e = string.find(&amp;quot;hello Lua world&amp;quot;, &amp;quot;Lua&amp;quot;)&lt;/code&gt;。如果一个函数调用不是一系列表达式的最后一个元素，则只产生一个值：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function foo() return &amp;quot;a&amp;quot;, &amp;quot;b&amp;quot; end
x, y = foo(), 20    -- x=&amp;quot;a&amp;quot;, y=20（foo的第二个返回值被丢弃）
print(foo() .. &amp;quot;x&amp;quot;)    -- 输出ax，这是因为当函数出现在一个表达式中时，Lua会将其返回值数量调整为1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;另外，只有当一个函数调用作为最后一个元素时，返回值才不会被调整，在其他位置都会被调整为1个，如&lt;code&gt;t = {foo2()}&lt;/code&gt;则t={“a”, “b”}，&lt;code&gt;t = {foo2(), 4}&lt;/code&gt;则t={“a”, 4}。&lt;/p&gt;
&lt;p&gt;特殊函数unpack接受一个数组作为参数，并从下标1开始返回该数组的所有元素，如&lt;code&gt;a, b = unpack({10, 20, 30})&lt;/code&gt;，则30被丢弃。unpack的一项重要用途体现在“泛型调用”机制中。&lt;/p&gt;
&lt;h2 id=&quot;1-2-变长参数&quot;&gt;&lt;a href=&quot;#1-2-变长参数&quot; class=&quot;headerlink&quot; title=&quot;1.2 变长参数&quot;&gt;&lt;/a&gt;1.2 变长参数&lt;/h2&gt;&lt;p&gt;函数参数表中3个点（…）表示该函数可接受不同数量的实参。&lt;strong&gt;在Lua 5.0中，没有提供“…”表达式，如果要遍历变长参数，可以访问函数内隐含的局部变量&lt;code&gt;arg&lt;/code&gt;。&lt;/strong&gt;如果还有固定参数，则必须放在变长参数之前。&lt;/p&gt;
&lt;h1 id=&quot;2-高级主题&quot;&gt;&lt;a href=&quot;#2-高级主题&quot; class=&quot;headerlink&quot; title=&quot;2. 高级主题&quot;&gt;&lt;/a&gt;2. 高级主题&lt;/h1&gt;&lt;h2 id=&quot;2-1-closure闭合函数&quot;&gt;&lt;a href=&quot;#2-1-closure闭合函数&quot; class=&quot;headerlink&quot; title=&quot;2.1 closure闭合函数&quot;&gt;&lt;/a&gt;2.1 closure闭合函数&lt;/h2&gt;&lt;p&gt;和Javascript的闭包基本是一个东西，此处不再赘述。从技术上说，Lua中只有closure，而不存在“函数”，因为函数本身就是一种特殊的closure。closure的应用很广泛，如用于高阶函数的参数、为GUI工具包创建回调、重定义函数并在新实现中调用旧实现、创建“沙盒”安全运行环境等等。&lt;/p&gt;
&lt;h2 id=&quot;2-2-非全局的函数&quot;&gt;&lt;a href=&quot;#2-2-非全局的函数&quot; class=&quot;headerlink&quot; title=&quot;2.2 非全局的函数&quot;&gt;&lt;/a&gt;2.2 非全局的函数&lt;/h2&gt;&lt;p&gt;大部分Lua库都采用了将函数存储在table中的机制（如io.read，math.sin），例如下面采用了三种方式来定义table的成员函数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MathLib = {
    plus = function(x, y) return x + y end
}
MathLib.minus = function(x, y) return x - y end
function MathLib.multiply(x, y) return x * y end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;局部函数的定义：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;local f = function(&amp;lt;参数&amp;gt;) &amp;lt;函数体&amp;gt; end
local function f(&amp;lt;参数&amp;gt;) &amp;lt;函数体&amp;gt; end  -- Lua提供的语法糖
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;**注意如果定义递归函数，不能使用上面第一种定义方式（因为在函数体调用f时，f尚未定义完毕），使用第二种“语法糖”则没问题；或者使用“前向声明”，先&lt;code&gt;local f&lt;/code&gt;再&lt;code&gt;f = function ...&lt;/code&gt;这样定义。&lt;/p&gt;
&lt;h2 id=&quot;2-3-正确的尾调用&quot;&gt;&lt;a href=&quot;#2-3-正确的尾调用&quot; class=&quot;headerlink&quot; title=&quot;2.3 正确的尾调用&quot;&gt;&lt;/a&gt;2.3 正确的尾调用&lt;/h2&gt;&lt;p&gt;当一个函数调用时另一个函数的最后一个动作时，该调用算是一条“尾调用”，例如&lt;code&gt;function f(x) return g(x) end&lt;/code&gt;。由于在尾调用后程序不要保存任何关于该函数的栈信息，所以递归调用不会耗费栈空间，可以递归调用无数次。有一些看似是“尾调用”的代码，其实都违背了这条准则：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function f(x) g(x) end    -- 调用g后，f没有立即返回，还需要丢弃g返回的临时结果
function f(x) return g(x) + 1    -- 还要做一次加法
function f(x) return x or g(x)    -- 必须调整为一个返回值
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;所以，只有形如&lt;code&gt;return &amp;lt;func&amp;gt;(&amp;lt;args&amp;gt;)&lt;/code&gt;这样的调用形式才算是尾调用。&lt;/p&gt;
&lt;p&gt;参考文献：电子工业出版社《Lua程序设计（第2版）》第5-6章&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍了Lua的函数，包括多重返回值、变长参数、具名实参，以及比较高级的主题如闭包、递归的尾调用等等。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="编程语言" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Lua" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/"/>
    
    
      <category term="Lua" scheme="http://raytaylorlin.com/tags/Lua/"/>
    
  </entry>
  
  <entry>
    <title>Linux学习笔记——用户及文件权限管理</title>
    <link href="http://raytaylorlin.com/tech/linux/linux-user-and-file-manage/"/>
    <id>http://raytaylorlin.com/tech/linux/linux-user-and-file-manage/</id>
    <published>2015-02-19T11:38:05.000Z</published>
    <updated>2016-02-09T12:31:39.965Z</updated>
    
    <content type="html">&lt;p&gt;Linux是一个可以实现多用户登录的操作系统，本文记录了Linux的用户管理，包括查看、创建用户和用户组，以及文件的权限机制。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;Linux是一个可以实现多用户登录的操作系统，比如李雷和韩梅梅都可以同时登陆同一台主机，他们共享一些主机的资源，但他们也分别有自己的用户空间，用于存放各自的文件。实际上他们的文件都是放在同一个物理磁盘上的甚至同一个逻辑分区或者目录里，但他们互相不可以看到或操作对方的文件，这正是Linux用户管理和权限机制。&lt;/p&gt;
&lt;h1 id=&quot;Linux用户管理&quot;&gt;&lt;a href=&quot;#Linux用户管理&quot; class=&quot;headerlink&quot; title=&quot;Linux用户管理&quot;&gt;&lt;/a&gt;Linux用户管理&lt;/h1&gt;&lt;h2 id=&quot;查看用户&quot;&gt;&lt;a href=&quot;#查看用户&quot; class=&quot;headerlink&quot; title=&quot;查看用户&quot;&gt;&lt;/a&gt;查看用户&lt;/h2&gt;&lt;p&gt;直接使用&lt;code&gt;whoami&lt;/code&gt;命令可以查看当前登录用户的用户名，此外还有&lt;code&gt;who&lt;/code&gt;命令可以查看更多详细的信息。&lt;/p&gt;
&lt;h2 id=&quot;创建用户&quot;&gt;&lt;a href=&quot;#创建用户&quot; class=&quot;headerlink&quot; title=&quot;创建用户&quot;&gt;&lt;/a&gt;创建用户&lt;/h2&gt;&lt;p&gt;root权限，是系统权限的一种。root是Linux和unix系统中的超级管理员用户帐户，该帐户拥有整个系统至高无上的权力，所有对象他都可以操作，所以很多黑客在入侵系统的时候，都要把权限提升到root权限。root账户就相当于Linux的“上帝”。&lt;/p&gt;
&lt;p&gt;一般登录系统时都是以普通账户的身份登录的（即“凡人”）。如果要添加一个用户（上帝造人），那么需要“借用”一下上帝的权力，即使用&lt;code&gt;sudo&lt;/code&gt;命令。使用这个命令有两个大前提，一是你要知道当前登录用户的密码，二是&lt;strong&gt;当前用户必须在sudo用户组&lt;/strong&gt;。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;sudo adduser &amp;lt;user&amp;gt;&lt;/code&gt;：创建一个新用户（默认会自动创建一个同名的用户组），同时会在&lt;code&gt;/home&lt;/code&gt;目录下创建一个对应的文件夹&lt;/li&gt;
&lt;li&gt;&lt;code&gt;su -l &amp;lt;user&amp;gt;&lt;/code&gt;：切换登录用户&lt;/li&gt;
&lt;li&gt;&lt;code&gt;exit&lt;/code&gt;（或CTRL+D）：退出当前登录用户&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;用户组&quot;&gt;&lt;a href=&quot;#用户组&quot; class=&quot;headerlink&quot; title=&quot;用户组&quot;&gt;&lt;/a&gt;用户组&lt;/h2&gt;&lt;p&gt;在linux里面每个用户都有一个归属（用户组），用户组简单地理解就是一组用户的集合，它们共享一些资源和权限，同时拥有私有资源。一个用户可以属于多个用户组。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;groups &amp;lt;user&amp;gt;&lt;/code&gt;：查看user属于哪个用户组。输出内容冒号之前表示用户，之后表示该用户所属的用户组。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cat /etc/group |sort&lt;/code&gt;：输出如下所示。&lt;code&gt;/etc/group&lt;/code&gt;文件内容包括用户组（Group）、用户组口令、GID及该用户组所包含的用户（User），每个用户组一条记录。格式为&lt;code&gt;group_name:password:GID:user_list&lt;/code&gt;，其中密码字段为&lt;em&gt;表示密码不可见。&lt;br&gt; daemon:&lt;/em&gt;:1:root&lt;br&gt; kmem:&lt;em&gt;:2:root&lt;br&gt; sys:&lt;/em&gt;:3:root ……&lt;/li&gt;
&lt;li&gt;&lt;code&gt;usermod -G &amp;lt;group&amp;gt; &amp;lt;user&amp;gt;&lt;/code&gt;：为用户添加用户组（需要root权限）。可以用这个命令把用户加入sudo组，这样这个用户就能借用root权限。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;deluser &amp;lt;user&amp;gt; --remove-home&lt;/code&gt;：删除用户（需要root权限）。&lt;code&gt;--remove-home&lt;/code&gt;参数表示连带删除home目录下的文件夹。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;Linux文件权限&quot;&gt;&lt;a href=&quot;#Linux文件权限&quot; class=&quot;headerlink&quot; title=&quot;Linux文件权限&quot;&gt;&lt;/a&gt;Linux文件权限&lt;/h1&gt;&lt;p&gt;&lt;code&gt;ls&lt;/code&gt;命令可以列出当前文件夹的文件，附带参数说明如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-l&lt;/code&gt;：以较详细的格式列出文件（如下所示）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-A&lt;/code&gt;：显示除了&lt;code&gt;.&lt;/code&gt;(当前目录)，&lt;code&gt;..&lt;/code&gt;上一级目录之外的包含隐藏文件的所有文件（Linux下以&lt;code&gt;.&lt;/code&gt;开头的文件为隐藏文件）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-dl &amp;lt;dir&amp;gt;&lt;/code&gt;：查看某一个目录的完整属性，而不是显示目录里面的文件属性&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;-sSh&lt;/code&gt;：小s为显示文件大小，大S为按文件大小排序，h显示所有文件大小，并以普通人类能看懂的方式呈现&lt;/p&gt;
&lt;p&gt;  drwxr-xr-x@   11 root  wheel      374  1 25 22:23 usr&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从左到右依次是：文件类型和权限，链接数，所有者，所属用户组，文件大小，最后修改时间，文件名。&lt;/p&gt;
&lt;p&gt;1、文件类型和权限（drwxr-xr-x@）&lt;/p&gt;
&lt;p&gt;第1位d表示文件类型。其余文件类型有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;d：目录&lt;/li&gt;
&lt;li&gt;l：软链接&lt;/li&gt;
&lt;li&gt;b：块设备&lt;/li&gt;
&lt;li&gt;c：字符设备&lt;/li&gt;
&lt;li&gt;s：Socket&lt;/li&gt;
&lt;li&gt;p：管道&lt;/li&gt;
&lt;li&gt;-：普通文件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;后面9位每3个1组，分为3组，分别是拥有者权限、所属用户组权限、其他用户权限，字符的意义是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;r：允许读权限，比如可以使用&lt;code&gt;cat &amp;lt;file name&amp;gt;&lt;/code&gt;之类的命令来读取某个文件的内容&lt;/li&gt;
&lt;li&gt;w：允许写权限，表示你可以编辑和修改某个文件&lt;/li&gt;
&lt;li&gt;x：允许执行权限，通常指可以运行的二进制程序文件或者脚本文件。Linux上不是通过文件后缀名来区分文件的类型。注意：&lt;strong&gt;一个目录要同时具有读权限和执行权限才可以打开，而一个目录要有写权限才允许在其中创建其它文件，这是因为目录文件实际保存着该目录里面的文件的列表等信息&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2、链接数&lt;/p&gt;
&lt;p&gt;链接到该文件所在的inode结点的文件名数目（关于这个概念涉及到linux文件系统的相关概念知识，自行查阅）&lt;/p&gt;
&lt;p&gt;3、文件大小&lt;/p&gt;
&lt;p&gt;以inode结点大小为单位来表示的文件大小，可以给ls加上&lt;code&gt;-h&lt;/code&gt;参数（表示，这才是给人看的）来更直观的查看文件的大小&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;chown &amp;lt;param&amp;gt; &amp;lt;file&amp;gt;&lt;/code&gt;命令可以修改文件file权限（需要root权限）。其中参数param可以是二进制形式，也可以是加减赋值操作形式。&lt;/p&gt;
&lt;p&gt;二进制形式如&lt;code&gt;chown 755 some_file&lt;/code&gt;，参数中3个数字分别表示拥有者，所属用户组，其他用户的权限值。权限值的计算由r、w、x决定，有权限为1，无权限为0，由二进制加权所得，如7代表rwx，5代表r-x。&lt;/p&gt;
&lt;p&gt;加减赋值操作形式如&lt;code&gt;chmod go-rw some_file&lt;/code&gt;，’g’’o’还有’u’，分别表示group，others，user,’+’,’-‘就分别表示增加和去掉相应的权限。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Linux是一个可以实现多用户登录的操作系统，本文记录了Linux的用户管理，包括查看、创建用户和用户组，以及文件的权限机制。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Linux" scheme="http://raytaylorlin.com/categories/%E6%8A%80%E6%9C%AF/Linux/"/>
    
    
      <category term="Linux" scheme="http://raytaylorlin.com/tags/Linux/"/>
    
  </entry>
  
</feed>
